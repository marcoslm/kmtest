
[InterfaceId("000204F0-0000-0000-C000-000000000046")]
Private Interface IVBPrint Extends stdole.IUnknown
    Sub WriteText(ByVal Value As String)
    Property Let Column(ByVal Value As Long)
    Property Get Column() As Long
End Interface

Private Module GraphicsGlobals
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetObjectW Lib "gdi32" (ByVal hObject As LongPtr, ByVal nCount As Long, ByRef lpObject As Any) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetIconInfo Lib "user32" (ByVal hicon As LongPtr, ByRef iconInfo As ICONINFO) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CopyImage Lib "user32" (ByVal handle As LongPtr, ByVal type As Long, ByVal cx As Long, ByVal cy As Long, ByVal flags As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function OleCreatePictureIndirect Lib "oleaut32" (ByRef lpPictDesc As Any, ByVal riid As LongPtr, ByVal fOwn As Long, ByRef outObject As Any) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function Rectangle Lib "gdi32" (ByVal hdc As LongPtr, ByVal left As Long, ByVal top As Long, ByVal right As Long, ByVal bottom As Long) As Long
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Public DeclareWide PtrSafe Function SaveDC Lib "gdi32" (ByVal hdc As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Public DeclareWide PtrSafe Function RestoreDC Lib "gdi32" (ByVal hdc As LongPtr, ByVal nSavedDC As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Public DeclareWide PtrSafe Function IntersectClipRect Lib "gdi32" (ByVal hdc As LongPtr, ByVal left As Long, ByVal top As Long, ByVal right As Long, ByVal bottom As Long) As Long
    
    Private Type PICTDESC_BITMAP
    	cbSizeofstruct As Long
        picType As Long
        hbitmap As LongPtr
        hpal As LongPtr
    End Type
    
    Private Type ICONINFO
    	fIcon As Long       ' BOOL
        xHotspot As Long
        yHotspot As Long
        hbmMask As LongPtr
        hbmColor As LongPtr
    End Type
    
    Type contigiousPointsTriangle
        points(0 To 3) As WinNativeFormsBASE.POINT
    End Type
    
    Public Function IsInSubRect(ByVal X As Long, ByVal Y As Long, subRect As WinNativeFormsBASE.RECT) As Boolean
        Return (X >= subRect.Left) AndAlso (Y >= subRect.Top) AndAlso (X <= subRect.Right) AndAlso (Y <= subRect.Bottom)
    End Function
    
    Public Sub TranslateXYByAngle(ByRef X As Double, ByRef Y As Double, ByVal AngleDegrees As Double)
        Const pi As Double = 3.14159265358979323846
        Dim angleRadians As Double = (AngleDegrees * pi) / 180
        Dim resultX As Double = (X * Cos(angleRadians)) - (Y * Sin(angleRadians))
        Dim resultY As Double = (X * Sin(angleRadians)) + (Y * Cos(angleRadians))
        X = resultX
        Y = resultY
    End Sub

    Public Sub DrawTriangle(ByVal hdc As LongPtr, ByVal brush As LongPtr, ByVal pen As LongPtr, ByVal X1 As Long, ByVal Y1 As Long, ByVal X2 As Long, ByVal Y2 As Long, ByVal X3 As Long, ByVal Y3 As Long)
            Dim points As contigiousPointsTriangle
            points.points(0).X = X1
            points.points(0).Y = Y1
            points.points(1).X = X2
            points.points(1).Y = Y2
            points.points(2).X = X3
            points.points(2).Y = Y3
            points.points(3).X = X1
            points.points(3).Y = Y1
            Dim oldBrush As LongPtr = WinNativeFormsBASE.GDI32_SelectObject(hdc, brush)
            Dim oldPen As LongPtr = WinNativeFormsBASE.GDI32_SelectObject(hdc, pen)
            GDI32_Polygon(hdc, points, 4)
    End Sub
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DrawTextW Lib "user32" (ByVal hdc As LongPtr, ByVal lpchText As String, ByVal cchText As Long, ByRef lprc As WinNativeFormsBASE.RECT, ByVal format As Long) As Long
        
    Public Sub DrawZoomSelectors(ByVal hdc As LongPtr, rectIn As WinNativeFormsBASE.RECT, ByVal backBrushText As LongPtr, ByVal activebutton As Long, ByVal hoverbutton As Long, ByVal dpiXScale As Double, ByRef zoomOutButtonRect As WinNativeFormsBASE.RECT, ByRef zoomInButtonRect As WinNativeFormsBASE.RECT, ByRef zoomTextRect As WinNativeFormsBASE.RECT, ByVal Text As String, ByVal FontHandle As LongPtr, ByVal TextColor As Long)
        Dim rect As WinNativeFormsBASE.RECT = rectIn
        Dim bfStyle As Long
        Dim bfFlags As Long = BorderFlags.BF_RECT Or BorderFlags.BF_ADJUST Or BorderFlags.BF_FLAT
                                
        bfStyle = BorderStyles.BDR_SUNKENOUTER 'Or BorderStyles.BDR_SUNKENINNER
            
        'WinNativeFormsBASE.DrawEdge(hdc, rect, bfStyle, bfFlags)
        Dim box As WinNativeFormsBASE.RECT
        Dim buttonRect As WinNativeFormsBASE.RECT
        Dim buttonDrawRect As WinNativeFormsBASE.RECT
        Dim normalEdgeFlags As Long = BorderStyles.BDR_RAISEDOUTER 'Or BorderStyles.BDR_RAISEDINNER
        Dim sunkenEdgeFlags As Long = BorderStyles.BDR_SUNKENOUTER Or BorderStyles.BDR_SUNKENINNER

        Dim brushButtonFill As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbButtonFace))
        Dim buttonForeColorBrush As LongPtr = WinNativeFormsBASE.CreateSolidBrush(&H505050) 'TranslateColor(vbButtonText))
        Dim buttonForeColorBrushDisabled As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbGrayText))
        Dim buttonForeColorPen As LongPtr = GDI32_CreatePen(PS_SOLID, 1, &HA0A0A0)
                
        Dim btnWidth As Long = CLng(18 * dpiXScale)
        Dim btnHeight As Long = rect.Bottom - rect.Top
        Dim marginY As Long = CLng(btnHeight / 8)
        Dim marginX As Long = CLng(btnWidth / 8)
                
        buttonRect = rect
        buttonRect.Right = rect.Left + btnWidth
        rect.Left += btnWidth
        bfStyle = If(activebutton = 5 AndAlso hoverbutton = 5, sunkenEdgeFlags, normalEdgeFlags)
        zoomOutButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)

        ' Draw '-'
        box = buttonRect
        box.Left += 5
        box.Right -= 5
        box.Top += CLng(btnHeight / 2) - 2
        box.Bottom = box.Top + 2
        WinNativeFormsBASE.USER32_FillRectangle(hdc, box, buttonForeColorBrush)

        buttonRect = rect
        buttonRect.Left = rect.Right - btnWidth
        rect.Right -= btnWidth
        bfStyle = If(activebutton = 6 AndAlso hoverbutton = 6, sunkenEdgeFlags, normalEdgeFlags)
        zoomInButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)
                
        ' Draw '+'
        box = buttonRect
        box.Left += CLng(btnWidth / 2) - 2
        box.Right = box.Left + 2
        box.Top += 4
        box.Bottom -= 4
        WinNativeFormsBASE.USER32_FillRectangle(hdc, box, buttonForeColorBrush)
        box = buttonRect
        box.Left += 4
        box.Right -= 4
        box.Top += CLng(btnHeight / 2) - 2
        box.Bottom = box.Top + 2
        WinNativeFormsBASE.USER32_FillRectangle(hdc, box, buttonForeColorBrush)
        
        
        ' Fill the text area
        zoomTextRect = rect
        WinNativeFormsBASE.DrawEdge(hdc, rect, bfStyle, BorderFlags.BF_BOTTOM Or BorderFlags.BF_TOP Or BorderFlags.BF_ADJUST Or BorderFlags.BF_FLAT)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, rect, backBrushText)
        
        If Len(Text) > 0 Then
            Dim oldFont As LongPtr = WinNativeFormsBASE.SelectObject(hdc, FontHandle)
            Dim oldTextColor As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, TextColor)
            Dim oldBkMode As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, 1)
                        
            rect.Left += 2
            rect.Right -= 2
            If rect.Left < rect.Right Then
                Const DT_SINGLELINE As Long = 32
                Const DT_VCENTER As Long = 4
                Const DT_END_ELLIPSIS As Long = 32768
                Const DT_CENTER As Long = 1
                DrawTextW(hdc, Text, Len(Text), rect, DT_SINGLELINE Or DT_VCENTER Or DT_CENTER)
            End If
                                        
            WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, oldBkMode)
            WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, oldTextColor)
            WinNativeFormsBASE.SelectObject(hdc, oldFont)
        End If
        
        WinNativeFormsBASE.DeleteObject(brushButtonFill)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrush)
        WinNativeFormsBASE.DeleteObject(buttonForeColorPen)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrushDisabled)
    End Sub
    
    Private Type TRIVERTEX
        PxX As Long
        PxY As Long
        RedLow As Byte
        Red As Byte
        GreenLow As Byte
        Green As Byte
        BlueLow As Byte
        Blue As Byte
        AlphaLow As Byte
        Alpha As Byte
    End Type

    Private Type GRADIENT_RECT
        UpperLeft As Long
        LowerRight As Long
    End Type
    
    Private Type GRADIENT_TRIANGLE
        Vertex1 As Long
        Vertex2 As Long
        Vertex3 As Long
    End Type

    Private Declare PtrSafe Function GradientFill Lib "msimg32" ( _
        ByVal hDC As LongPtr, _
        ByRef Vertex As TRIVERTEX, _
        ByVal nVertex As Long, _
        ByRef Mesh As Any, _
        ByVal nMesh As Long, _
        ByVal Mode As Long) As Long
    
    Type WorldTransformAngleData
        xfPreserved As XFORM
        oldGraphicsMode As Long
        isActive As Boolean
    End Type
    
    Type XFORM
        eM11 As Single
        eM12 As Single
        eM21 As Single
        eM22 As Single
        eDx As Single
        eDy As Single
    End Type
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetWorldTransform Lib "gdi32" (ByVal hdc As LongPtr, ByRef xf As XFORM) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetWorldTransform Lib "gdi32" (ByVal hdc As LongPtr, ByRef xf As XFORM) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetGraphicsMode Lib "gdi32" (ByVal hdc As LongPtr, ByVal iMode As Long) As Long
    
    Public Sub DoWorldTransformAngle(angleData As WorldTransformAngleData, ByVal ps_hdc As LongPtr, ByVal _angle As Double, ByVal Left As Double, ByVal Top As Double)
        Dim xf As XFORM
        Const pi As Double = 3.14159265358979323846
        Dim angle As Single = CSng(_angle * (pi / 180))
        xf.eM11 = CSng(Cos(angle))
        xf.eM12 = CSng(-Sin(angle))
        xf.eM21 = CSng(Sin(angle))
        xf.eM22 = CSng(Cos(angle))
        xf.eDx = CSng(Left)
        xf.eDy = CSng(Top)
                        
        Const GM_ADVANCED As Long = 2
        angleData.oldGraphicsMode = SetGraphicsMode(ps_hdc, GM_ADVANCED)
        GetWorldTransform(ps_hdc, angleData.xfPreserved)
        SetWorldTransform(ps_hdc, xf)
        
        angleData.isActive = True
    End Sub
    
    Public Sub UndoWorldTransformAngle(angleData As WorldTransformAngleData, ByVal ps_hdc As LongPtr)
        If angleData.isActive Then
            SetWorldTransform(ps_hdc, angleData.xfPreserved)
            SetGraphicsMode(ps_hdc, angleData.oldGraphicsMode)
            angleData.isActive = False
        End If
    End Sub
    
    Public Sub GradientFillRect(ByVal hdc As LongPtr, ByRef rect As WinNativeFormsBASE.RECT, ByVal startRGB As Long, ByVal endRGB As Long, ByVal Vertical As Boolean)
        Const GRADIENT_FILL_RECT_H = &H0
        Const GRADIENT_FILL_RECT_V = &H1
        Dim TRIVERTEX(0 To 1) As TRIVERTEX
        Dim GRADIENT_RECT As GRADIENT_RECT
        With GRADIENT_RECT
            .UpperLeft = 0
            .LowerRight = 1
        End With
        With TRIVERTEX(0)
            .PxX = rect.Left
            .PxY = rect.Top
            .Red = CByte(RGB_R(startRGB))
            .Green = CByte(RGB_G(startRGB))
            .Blue = CByte(RGB_B(startRGB))
        End With
        With TRIVERTEX(1)
            .PxX = rect.Right
            .PxY = rect.Bottom
            .Red = CByte(RGB_R(endRGB))
            .Green = CByte(RGB_G(endRGB))
            .Blue = CByte(RGB_B(endRGB))
        End With
        GradientFill(hdc, TRIVERTEX(0), 2, GRADIENT_RECT, 1, If(Vertical, GRADIENT_FILL_RECT_V, GRADIENT_FILL_RECT_H))
    End Sub
    
    Public Sub DrawPrintButton(ByVal hdc As LongPtr, rectIn As WinNativeFormsBASE.RECT, ByVal backBrushText As LongPtr, ByVal activebutton As Long, ByVal hoverbutton As Long, ByVal dpiXScale As Double, ByRef printButtonRect As WinNativeFormsBASE.RECT)
        Dim rect As WinNativeFormsBASE.RECT = rectIn
        Dim bfStyle As Long
        Dim bfFlags As Long = BorderFlags.BF_RECT Or BorderFlags.BF_ADJUST Or BorderFlags.BF_FLAT
                                
        bfStyle = BorderStyles.BDR_SUNKENOUTER 'Or BorderStyles.BDR_SUNKENINNER
            
        'WinNativeFormsBASE.DrawEdge(hdc, rect, bfStyle, bfFlags)
        Dim box As WinNativeFormsBASE.RECT
        Dim buttonRect As WinNativeFormsBASE.RECT
        Dim buttonDrawRect As WinNativeFormsBASE.RECT
        Dim normalEdgeFlags As Long = BorderStyles.BDR_RAISEDOUTER 'Or BorderStyles.BDR_RAISEDINNER
        Dim sunkenEdgeFlags As Long = BorderStyles.BDR_SUNKENOUTER Or BorderStyles.BDR_SUNKENINNER

        Dim brushButtonFill As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbButtonFace))
        Dim buttonForeColorBrush As LongPtr = WinNativeFormsBASE.CreateSolidBrush(&H505050) 'TranslateColor(vbButtonText))
        Dim buttonForeColorBrushDisabled As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbGrayText))
        Dim buttonForeColorPen As LongPtr = GDI32_CreatePen(PS_SOLID, 1, &HA0A0A0)
                
        Dim btnWidth As Long = CLng(18 * dpiXScale)
        Dim btnHeight As Long = rect.Bottom - rect.Top
        Dim marginY As Long = CLng(btnHeight / 8)
        Dim marginX As Long = CLng(btnWidth / 8)
                
        buttonRect = rect
        'buttonRect.Right = rect.Left + btnWidth
        'rect.Left += btnWidth
        bfStyle = If(activebutton = 7 AndAlso hoverbutton = 7, sunkenEdgeFlags, normalEdgeFlags)
        printButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)

        ' Draw .'
        box = buttonRect
        box.Left += (buttonRect.Right - buttonRect.Left) \ 2
        box.Right = box.Left + 2
        box.Top += (buttonRect.Bottom - buttonRect.Top) \ 2
        box.Bottom = box.Top + 2
        WinNativeFormsBASE.USER32_FillRectangle(hdc, box, buttonForeColorBrush)
        
        WinNativeFormsBASE.DeleteObject(brushButtonFill)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrush)
        WinNativeFormsBASE.DeleteObject(buttonForeColorPen)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrushDisabled)
    End Sub
    
    Public Sub DrawRecordSelectors(ByVal hdc As LongPtr, rectIn As WinNativeFormsBASE.RECT, ByVal backBrushText As LongPtr, ByVal activebutton As Long, ByVal hoverbutton As Long, ByVal IsBOFSafe As Boolean, ByVal IsEOFSafe As Boolean, ByVal dpiXScale As Double, ByRef moveFirstButtonRect As WinNativeFormsBASE.RECT, ByRef movePrevButtonRect As WinNativeFormsBASE.RECT, ByRef moveNextButtonRect As WinNativeFormsBASE.RECT, ByRef moveLastButtonRect As WinNativeFormsBASE.RECT, ByVal Text As String, ByVal FontHandle As LongPtr, ByVal TextColor As Long)

        Dim rect As WinNativeFormsBASE.RECT = rectIn
        Dim bfStyle As Long
        Dim bfFlags As Long = BorderFlags.BF_RECT Or BorderFlags.BF_ADJUST Or BorderFlags.BF_FLAT
                                
        bfStyle = BorderStyles.BDR_SUNKENOUTER 'Or BorderStyles.BDR_SUNKENINNER
            
        'WinNativeFormsBASE.DrawEdge(hdc, rect, bfStyle, bfFlags)
                                                
        Dim buttonRect As WinNativeFormsBASE.RECT
        Dim buttonDrawRect As WinNativeFormsBASE.RECT
        Dim normalEdgeFlags As Long = BorderStyles.BDR_RAISEDOUTER 'Or BorderStyles.BDR_RAISEDINNER
        Dim sunkenEdgeFlags As Long = BorderStyles.BDR_SUNKENOUTER Or BorderStyles.BDR_SUNKENINNER

        Dim brushButtonFill As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbButtonFace))
        Dim buttonForeColorBrush As LongPtr = WinNativeFormsBASE.CreateSolidBrush(&H505050) 'TranslateColor(vbButtonText))
        Dim buttonForeColorBrushDisabled As LongPtr = WinNativeFormsBASE.CreateSolidBrush(TranslateColor(vbGrayText))
        Dim buttonForeColorPen As LongPtr = GDI32_CreatePen(PS_SOLID, 1, &HA0A0A0)
                
        Dim btnWidth As Long = CLng(19 * dpiXScale)
        Dim marginY As Long = CLng((rect.Bottom - rect.Top) / 8)
        Dim marginX As Long = CLng(btnWidth / 8)
                
        buttonRect = rect
        buttonRect.Right = rect.Left + btnWidth
        rect.Left += btnWidth
        bfStyle = If(activebutton = 1 AndAlso hoverbutton = 1, sunkenEdgeFlags, normalEdgeFlags)
        moveFirstButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)
                
        buttonDrawRect = buttonRect
        buttonDrawRect.Left += marginX
        buttonDrawRect.Right = buttonDrawRect.Left + marginX
        buttonDrawRect.Top += marginY
        buttonDrawRect.Bottom -= marginY
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonDrawRect, If(IsBOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush))
                
        DrawTriangle(hdc, If(IsBOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush), buttonForeColorPen, (buttonRect.Right - marginX) - 1, buttonRect.Top + marginY, (buttonRect.Right - marginX) - 1, buttonRect.Bottom - marginY - 1, buttonRect.Left + marginX + marginX + 1, CLng(buttonRect.Top + ((buttonRect.Bottom - buttonRect.Top) / 2)))
                
        buttonRect = rect
        buttonRect.Right = rect.Left + btnWidth
        rect.Left += btnWidth
        bfStyle = If(activebutton = 2 AndAlso hoverbutton = 2 AndAlso (IsBOFSafe = False), sunkenEdgeFlags, normalEdgeFlags)
        movePrevButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)

        DrawTriangle(hdc, If(IsBOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush), buttonForeColorPen, buttonRect.Right - marginX - marginX - 1, buttonRect.Top + marginY, buttonRect.Right - marginX - marginX - 1, buttonRect.Bottom - marginY - 1, buttonRect.Left + marginX + 1, CLng(buttonRect.Top + ((buttonRect.Bottom - buttonRect.Top) / 2)))
                
        buttonRect = rect
        buttonRect.Left = rect.Right - btnWidth
        rect.Right -= btnWidth
        bfStyle = If(activebutton = 4 AndAlso hoverbutton = 4, sunkenEdgeFlags, normalEdgeFlags)
        moveLastButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)
                
        buttonDrawRect = buttonRect
        buttonDrawRect.Right -= marginX
        buttonDrawRect.Left = buttonDrawRect.Right - marginX
        buttonDrawRect.Top += marginY
        buttonDrawRect.Bottom -= marginY
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonDrawRect, If(IsEOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush))
                
        DrawTriangle(hdc, If(IsEOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush), buttonForeColorPen, buttonRect.Left + marginX, buttonRect.Top + marginY, buttonRect.Left + marginX, buttonRect.Bottom - marginY - 1, buttonRect.Right - marginX - marginX - 2, CLng(buttonRect.Top + ((buttonRect.Bottom - buttonRect.Top) / 2)))

        buttonRect = rect
        buttonRect.Left = rect.Right - btnWidth
        rect.Right -= btnWidth
        bfStyle = If(activebutton = 3 AndAlso hoverbutton = 3 AndAlso (IsEOFSafe = False), sunkenEdgeFlags, normalEdgeFlags)
        moveNextButtonRect = buttonRect
        WinNativeFormsBASE.DrawEdge(hdc, buttonRect, bfStyle, bfFlags)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, buttonRect, brushButtonFill)

        DrawTriangle(hdc, If(IsEOFSafe, buttonForeColorBrushDisabled, buttonForeColorBrush), buttonForeColorPen, buttonRect.Left + marginX + marginX, buttonRect.Top + marginY, buttonRect.Left + marginX + marginX, buttonRect.Bottom - marginY - 1, buttonRect.Right - marginX - 2, CLng(buttonRect.Top + ((buttonRect.Bottom - buttonRect.Top) / 2)))

        ' Fill the text area
        WinNativeFormsBASE.DrawEdge(hdc, rect, bfStyle, BorderFlags.BF_BOTTOM Or BorderFlags.BF_TOP Or BorderFlags.BF_ADJUST Or BorderFlags.BF_FLAT)
        WinNativeFormsBASE.USER32_FillRectangle(hdc, rect, backBrushText)
        
        If Len(Text) > 0 Then
            Dim oldFont As LongPtr = WinNativeFormsBASE.SelectObject(hdc, FontHandle)
            Dim oldTextColor As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, TextColor)
            Dim oldBkMode As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, 1)
                        
            rect.Left += 2
            rect.Right -= 2
            If rect.Left < rect.Right Then
                Const DT_SINGLELINE As Long = 32
                Const DT_VCENTER As Long = 4
                Const DT_END_ELLIPSIS As Long = 32768
                Const DT_CENTER As Long = 1
                DrawTextW(hdc, Text, Len(Text), rect, DT_SINGLELINE Or DT_VCENTER Or DT_CENTER)
            End If
                                        
            WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, oldBkMode)
            WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, oldTextColor)
            WinNativeFormsBASE.SelectObject(hdc, oldFont)
        End If
        
        WinNativeFormsBASE.DeleteObject(brushButtonFill)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrush)
        WinNativeFormsBASE.DeleteObject(buttonForeColorPen)
        WinNativeFormsBASE.DeleteObject(buttonForeColorBrushDisabled)
    End Sub
    
    Public OLEPictureScaleX As Double
    Public OLEPictureScaleY As Double

    Public Sub DetermineOLEPictureScaling()
            
        ' the Picture.Width and Picture.Height values already reflect DPI, but ole32 library caches a static DPI value, which is no good
        ' We use this routine to determine the cached DPI used by the loaded ole32 library

        ' Load a 1x1-pixel bitmap into a StdPicture, and read the Width / Height values to determine the scale to HIMETRIC units that the OLE32 library is using
        
        'Const ImageData_1x1Bitmap As Variant = LoadResData("1x1.bmp", "OTHER")
    	'Dim tempPicture As OlePicture = Global.LoadPicture(ImageData_1x1Bitmap)
        
        Const ImageData_1000x1000 As Variant = LoadResDataInternal("1000x1000.gif", "OTHER")
    	Dim tempPicture As Any = CType(Of OlePicture)(Global.LoadPicture(ImageData_1000x1000))
        
        OLEPictureScaleX = tempPicture.Width / 1000
        OLEPictureScaleY = tempPicture.Height / 1000

    End Sub

	Public Sub ScaleOLEPictureDimensionsToPixels(ByVal PicType As PictureTypeConstants, ByVal WidthHIMETRIC As Long, ByRef Width As Long, ByVal HeightHIMETRIC As Long, ByRef Height As Long)
    	If OLEPictureScaleX = 0 Then DetermineOLEPictureScaling
        Width = CLng(Round(WidthHIMETRIC / OLEPictureScaleX))
        Height = CLng(Round(HeightHIMETRIC / OLEPictureScaleY))
	End Sub
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function ReleaseDC Lib "user32" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SelectObject Lib "gdi32" (ByVal hdc As LongPtr, ByVal hObject As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetSystemMetrics Lib "user32" (ByVal index As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DrawIcon Lib "user32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal hicon As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DrawIconEx Lib "user32" (ByVal hDC As LongPtr, ByVal xLeft As Long, ByVal yTop As Long, ByVal hicon As LongPtr, ByVal cxWidth As Long, ByVal cyWidth As Long, ByVal istepIfAniCur As Long, ByVal hbrFlickerFreeDraw As LongPtr, ByVal diFlags As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateDIBSection Lib "gdi32" (ByVal hdc As LongPtr, ByRef pbmi As Any, ByVal usage As Long, ByRef ppvBits As LongPtr, ByVal hSection As LongPtr, ByVal offset As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Sub RtlMoveMemory Lib "kernel32" (ByVal lpDest As LongPtr, ByVal lpSource As LongPtr, ByVal Size As LongPtr)
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetDIBits Lib "gdi32" (ByVal hdc As LongPtr, ByVal hbm As LongPtr, ByVal start As Long, ByVal cLines As Long, ByRef lpvBits As LongPtr, ByRef lpbmi As BITMAPINFO_RGBA, ByVal usage As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetDIBits Lib "gdi32" (ByVal hdc As LongPtr, ByVal hbm As LongPtr, ByVal start As Long, ByVal cLines As Long, ByVal lpvBits As LongPtr, ByRef lpbmi As BITMAPINFO_RGBA, ByVal usage As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetPixel Lib "gdi32" (ByVal hDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal crColor As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreatePatternBrush Lib "gdi32" (ByVal hBitmap As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteObject Lib "gdi32" (ByVal hObject As LongPtr) As Long
    
    Type BITMAPINFOHEADER
    	biSize As Long
        biWidth As Long
        biHeight As Long
        biPlanes As Integer
        biBitCount As Integer
        biCompression As Long
        biSizeImage As Long
        biXPelsPerMeter As Long
        biYPelsPerMeter As Long
        biClrUsed As Long
        biClrImportant As Long
    End Type
        
    Type BITMAPINFO_RGBA
    	bmiHeader As BITMAPINFOHEADER
        bmiColors(4) As Long
    End Type
    Type BITMAPINFO_RGBA_LARGE
    	bmiHeader As BITMAPINFOHEADER
        bmiColors(256) As Long
    End Type

    Type CIEXYZ
    	ciexyzX As Long ' FXPT2DOT30
    	ciexyzY As Long ' FXPT2DOT30
    	ciexyzZ As Long ' FXPT2DOT30
    End Type

    Type CIEXYZTRIPLE
    	ciexyzRed As CIEXYZ
    	ciexyzGreen As CIEXYZ
    	ciexyzBlue As CIEXYZ
    End Type
    
    Type BITMAPV5HEADER
    	bV5Size As Long
        bV5Width As Long
        bV5Height As Long
        bV5Planes As Integer
        bV5BitCount As Integer
        bV5Compression As Long
        bV5SizeImage As Long
        bV5XPelsPerMeter As Long
        bV5YPelsPerMeter As Long
        bV5ClrUsed As Long
        bV5ClrImportant As Long
        bV5RedMask As Long
        bV5GreenMask As Long
        bV5BlueMask As Long
        bV5AlphaMask As Long
        bV5CSType As Long
        bV5Endpoints As CIEXYZTRIPLE
        bV5GammaRed As Long
        bV5GammaGreen As Long
        bV5GammaBlue As Long
        bV5Intent As Long
        bV5ProfileData As Long
        bV5ProfileSize As Long
        bV5Reserved As Long
    End Type
    
    Type V5BMPINFO
    	bmiHeader As BITMAPV5HEADER
        bmiColors(2) As Long
    End Type
    
    Public Function CreateCheckeredPatternBrush(ByVal hdc As LongPtr, ByVal color1 As Long, ByVal color2 As Long) As LongPtr
        Dim brush As LongPtr
        Dim hdcCompat As LongPtr = CreateCompatibleDC(hdc)
        If hdcCompat <> 0 Then
            Dim hBmp As LongPtr = CreateCompatibleBitmap(hdc, 2, 2)    ' 2x2 bitmap
            If hBmp <> 0 Then
                Dim hBmpOrig As LongPtr = SelectObject(hdcCompat, hBmp)
                SetPixel(hdcCompat, 0, 0, color1)
                SetPixel(hdcCompat, 0, 1, color2)
                SetPixel(hdcCompat, 1, 1, color1)
                SetPixel(hdcCompat, 1, 0, color2)
                brush = CreatePatternBrush(hBmp)
                SelectObject(hdcCompat, hBmpOrig)
                DeleteObject(hBmp)
            End If
            DeleteDC hdcCompat
        End If
        Return brush
    End Function
    
    Public Function CreatePen(ByVal style As Long, ByVal width As Long, ByVal dpiScale As Double, ByVal color As Long) As LongPtr
        Dim scaledWidth As Long = CLng(Int(width * dpiScale))
        If width = 1 Then
            If (style = PS_DOT) Or (style = PS_DASH) Or (style = PS_DASHDOT) Or (style = PS_DASHDOTDOT) Then
                ' these pen styles only support pen widths of 1, so dpi scaling might break the style behaviour
                scaledWidth = 1
            End If
        End If
    	Return GDI32_CreatePen(style, scaledWidth, color)
    End Function
    
End Module

[InterfaceId("B457184F-7D61-4791-A79B-3D1455955C71")]
Private Class TextRenderPath
    Type TextRenderElement
    	Left As Long
        Top As Long
        Text As String
        MenomicWidth As Long
    End Type
    
    Private ElementsCount As Long = 0
    Private ElementsBufferCount As Long = 10
    Public Elements() As TextRenderElement
    Public HasMnemomnics As Boolean = False
    Public TotalHeight As Long = 0
    Public TotalWidth As Long = 0

    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetDCPenColor Lib "gdi32" (ByVal hdc As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetTextColor Lib "gdi32" (ByVal hdc As LongPtr) As Long
    Const ETO_CLIPPED As Long = 4
                    
    Public Sub RenderWithMnemonics(ByVal hdc As LongPtr, ByRef rect As WinNativeFormsBASE.RECT, _
                                    ByVal offsetLeft As Long, ByVal offsetTop As Long, _
                                    ByVal FontAscentHeight As Long, ByVal UnitPixelScale As Double, ByVal UseDrawText As Boolean)
    
        Dim underlinePen As LongPtr
        Dim underlineOffset As Long
        
        If HasMnemomnics = True Then
        	underlinePen = CreatePen(PS_SOLID, 1, UnitPixelScale, GetTextColor(hdc))
            underlineOffset = FontAscentHeight + 2
        End If
        
        Dim elementIdx As Long
    	For elementIdx = 0 To ElementsCount - 1
            With Elements(elementIdx)
            	Dim elementLeft As Any = rect.Left + .Left + offsetLeft
                Dim elementTop As Any = rect.Top + .Top + offsetTop
            	If .MenomicWidth > 0 Then
                    Dim _origPen As LongPtr = WinNativeFormsBASE.SelectObject(hdc, underlinePen)
                    GDI32_MoveToEx(hdc, elementLeft, elementTop + underlineOffset, 0)
                    GDI32_LineTo(hdc, elementLeft + .MenomicWidth, elementTop + underlineOffset)
                    WinNativeFormsBASE.SelectObject(hdc, _origPen)
                Else
                    If UseDrawText = False Then     ' There's probably no difference, but DrawText() works better with rotated world transforms
                        WinNativeFormsBASE.ExtTextOutW(hdc, elementLeft, elementTop, ETO_CLIPPED, rect, .Text, Len(.Text), 0)
                    Else
                        Const ETO_CLIPPED As Long = 4
                        Const DT_NOPREFIX As Long = &H800
                        Dim outRect As WinNativeFormsBASE.RECT
                        outRect.Left = elementLeft
                        outRect.Top = elementTop
                        outRect.Right = rect.Right
                        outRect.Bottom = rect.Bottom
                        DrawTextW(hdc, .Text, Len(.Text), outRect, DT_NOPREFIX)
                    End If
            	End If
            End With
        Next
        
        If underlinePen <> 0 Then WinNativeFormsBASE.DeleteObject(underlinePen)
    End Sub
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DrawTextW Lib "user32" (ByVal hdc As LongPtr, ByVal lpchText As String, ByVal cchText As Long, ByRef lprc As WinNativeFormsBASE.RECT, ByVal format As Long) As Long
    
    Public Sub Render(ByVal hdc As LongPtr, ByRef rect As WinNativeFormsBASE.RECT, ByVal offsetLeft As Long, ByVal offsetTop As Long, ByVal UseDrawText As Boolean)
        Dim elementIdx As Long
    	For elementIdx = 0 To ElementsCount - 1
            With Elements(elementIdx)
            	If .MenomicWidth = 0 Then
                
                    'Dim X As Double = .Left
                    'Dim Y As Double = .Top
                    'TranslateXYByAngle(X, Y, -40)
                    'WinNativeFormsBASE.ExtTextOutW(hdc, rect.Left + CLng(X) + offsetLeft, rect.Top + CLng(Y) + offsetTop, ETO_CLIPPED, rect, .Text, Len(.Text), 0)
                    'Debug.Print "ExtTextOutW l:" & (rect.Left + .Left + offsetLeft)
                    If UseDrawText = False Then     ' There's probably no difference, but DrawText() works better with rotated world transforms
                        WinNativeFormsBASE.ExtTextOutW(hdc, rect.Left + .Left + offsetLeft, rect.Top + .Top + offsetTop, ETO_CLIPPED, rect, .Text, Len(.Text), 0)
            	    Else
                        Const DT_NOPREFIX As Long = &H800
                        Dim outRect As WinNativeFormsBASE.RECT
                        outRect.Left = rect.Left + .Left + offsetLeft
                        outRect.Top = rect.Top + .Top + offsetTop
                        outRect.Right = rect.Right
                        outRect.Bottom = rect.Bottom
                        DrawTextW(hdc, .Text, Len(.Text), outRect, DT_NOPREFIX)
                    End If
                End If
            End With
        Next
    End Sub
    
    Public Sub New(ByVal hdc As LongPtr, ByVal Str As String, ByVal UseMnemonic As Boolean, _ 
                    ByVal Alignment As AlignmentConstants, ByVal _width As Long, ByVal AutoSize As Boolean, ByVal WordWrap As Boolean, ByVal LineSpacing As Long)
                    
        Dim startPos As Long = 1
        Dim currentLine As String
        Dim lastWidth As Long
        Dim whitespaceType As Long
        Dim Ended As Boolean
        Dim BufferedOutput As String
        Dim MnemonicPositionOnThisLine As Long = -1
        Dim MnemonicPositionInThisPart As Long = -1
        Dim countOfMeuemonicsInThisPart As Long
        Dim mneumonicOffset As Long
        Dim countLines As Long
        Dim topOffset As Long
        
        Dim splitAtSpaces As Boolean = (AutoSize = False) Or (WordWrap = True)
        
        'Stop
        
        ReDim Elements(ElementsBufferCount)
        
        ' FIXME this algo turned out a mess.
        
        Dim newLine As Boolean = False
        
        While Ended = False
            Dim nextSplitPointPos As Long = [_HiddenModule].[_InStrBreak](startPos + mneumonicOffset, Str, whitespaceType, splitAtSpaces)
            mneumonicOffset = 0
            Dim numCharsInSection As Long = nextSplitPointPos - startPos
            
            Select Case whitespaceType
                Case 1 ' SPACE
                    If numCharsInSection = 0 Then
                        If (Len(BufferedOutput) = 0) And (countLines > 0) Then
                            startPos += 1
                            Continue While
                        Else
                            numCharsInSection = 1
                        End If
                    End If
                Case 2 ' vbTab
                    If numCharsInSection = 0 Then
                        startPos += 1
                        Continue While
                    End If
                Case 3 ' vbCrLf
                    If numCharsInSection = 0 Then
                        startPos += 2
                    End If
                Case 4 ' vbCr / vbLf
                    If numCharsInSection = 0 Then
                        startPos += 1
                    End If
                Case 5 ' vbNullChar / EOL
                    Ended = True
                    If numCharsInSection = 0 And Len(BufferedOutput) = 0 Then
                        Exit While
                    End If
                Case 6 ' "&"
                    If UseMnemonic = False Then
                        mneumonicOffset += numCharsInSection + 1
                        Continue While
                    End If
                    
                    If Mid(Str, nextSplitPointPos + 1, 1) = "&" Then
                        ' A double && means to output just a single &, and not treat as a mnuemonic
                        Str = Left$(Str, nextSplitPointPos - 1) & ChrW$(&HE026&) & Right$(Str, (Len(Str) - nextSplitPointPos) - 1)
                        mneumonicOffset += numCharsInSection + 1
                        Continue While
                    End If
                    MnemonicPositionInThisPart = Len(BufferedOutput) + numCharsInSection - countOfMeuemonicsInThisPart
                    countOfMeuemonicsInThisPart += 1
                    mneumonicOffset += numCharsInSection + 1
                    Continue While
            End Select
            
            Dim size As WinNativeFormsBASE.SIZE
            size.cx = 0
            size.cy = 0

            Dim BufferedOutputLenBefore As Long = Len(BufferedOutput)
            Dim ThisPart As String = Mid$(Str, startPos, numCharsInSection)
            If MnemonicPositionInThisPart <> -1 Then
                ThisPart = Replace(ThisPart, "&", "")
                ThisPart = Replace(ThisPart, ChrW$(&HE026&), "&")
            End If
            BufferedOutput += ThisPart
            Dim success As Long = WinNativeFormsBASE.GetTextExtentPointW(hdc, BufferedOutput, Len(BufferedOutput), size)
            If success = False Then Exit While

            'Debug.Print "GetTextExtentPointW -> x=" & size.cx & ", y=" & size.cy & " ('" & BufferedOutput & "', ThisPart: " & ThisPart & ")"
            If (size.cx > 0) And newLine Then
                topOffset += LineSpacing
                newLine = False
            End If
            
            ' Does the current text fit into one line?
            If (size.cx > _width) Or (numCharsInSection = 0) Then

                If BufferedOutputLenBefore = 0 Then
                    ' whole line of text is too long to fit
                    BufferedOutput = ThisPart
                    startPos += numCharsInSection
                    BufferedOutputLenBefore = numCharsInSection
                    lastWidth = size.cx
                End If
                
                If size.cy = 0 Then
                    WinNativeFormsBASE.GetTextExtentPointW(hdc, " ", 1, size)   ' handle linefeed on first line
                End If
                
                Dim _left As Long = 0
                If Alignment = vbCenter Then
                    _left += CLng((_width - lastWidth) / 2)
                ElseIf Alignment = vbRightJustify Then
                    _left += _width - lastWidth
                End If
                
                If ((ElementsCount + 1) = ElementsBufferCount) Then
                    ElementsBufferCount *= 2
                    ReDim Preserve Elements(ElementsBufferCount)
                End If
                With Elements(ElementsCount)
                	.Left = _left
                    .Top = topOffset
                    .Text = Left$(BufferedOutput, BufferedOutputLenBefore)
                End With
                ElementsCount += 1
                If lastWidth > Me.TotalWidth Then Me.TotalWidth = lastWidth
                
                If MnemonicPositionOnThisLine <> -1 Then
                    Dim sizeTemp As WinNativeFormsBASE.SIZE
                    
                    ' Work out the X position of the underlined character
                    WinNativeFormsBASE.GetTextExtentPointW(hdc, BufferedOutput, MnemonicPositionOnThisLine, sizeTemp)
                    Dim lineX As Long = _left + sizeTemp.cx
                    
                    ' Get width of the underlined character
                    WinNativeFormsBASE.GetTextExtentPointW(hdc, Mid$(BufferedOutput, MnemonicPositionOnThisLine + 1, 1), 1, sizeTemp)
                    
                    If ((ElementsCount + 1) = ElementsBufferCount) Then
                        ElementsBufferCount *= 2
                        ReDim Preserve Elements(ElementsBufferCount)
                    End If
                    With Elements(ElementsCount)
                        .Left = lineX
                        .Top = topOffset ' + underlineOffset
                        .MenomicWidth = sizeTemp.cx
                    End With
                    ElementsCount += 1
                    HasMnemomnics = True
                End If
                
                countLines += 1
                BufferedOutput = vbNullString
                topOffset += size.cy
                newLine = True
                nextSplitPointPos = -1
                Ended = False
                MnemonicPositionOnThisLine = -1
                countOfMeuemonicsInThisPart = 0
            Else
                If MnemonicPositionInThisPart <> -1 Then
                    MnemonicPositionOnThisLine = MnemonicPositionInThisPart
                    MnemonicPositionInThisPart = -1
                End If
                startPos += numCharsInSection
                countOfMeuemonicsInThisPart = 0
            End If
            
            lastWidth = size.cx
        Wend
        
        If Len(BufferedOutput) > 0 Then
            _left = 0
            If Alignment = vbCenter Then
                _left += CLng((_width - lastWidth) / 2)
            ElseIf Alignment = vbRightJustify Then
                _left += _width - lastWidth
            End If

            If ((ElementsCount + 1) = ElementsBufferCount) Then
                ElementsBufferCount *= 2
                ReDim Preserve Elements(ElementsBufferCount)
            End If
            With Elements(ElementsCount)
                .Left = _left
                .Top = topOffset
                .Text = BufferedOutput
            End With
            ElementsCount += 1
            If lastWidth > Me.TotalWidth Then Me.TotalWidth = lastWidth
            
            If MnemonicPositionOnThisLine <> -1 Then
                
                ' Work out the X position of the underlined character
                WinNativeFormsBASE.GetTextExtentPointW(hdc, BufferedOutput, MnemonicPositionOnThisLine, sizeTemp)
                lineX = _left + sizeTemp.cx
                
                ' Get width of the underlined character
                WinNativeFormsBASE.GetTextExtentPointW(hdc, Mid$(BufferedOutput, MnemonicPositionOnThisLine + 1, 1), 1, sizeTemp)
                
                If ((ElementsCount + 1) = ElementsBufferCount) Then
                    ElementsBufferCount *= 2
                    ReDim Preserve Elements(ElementsBufferCount)
                End If
                With Elements(ElementsCount)
                    .Left = lineX
                    .Top = topOffset ' + underlineOffset
                    .MenomicWidth = sizeTemp.cx
                End With
                ElementsCount += 1
                HasMnemomnics = True
            End If

            topOffset += size.cy
        End If
        
        TotalHeight = topOffset
    End Sub
    
End Class

[InterfaceId("B4195B9A-EF91-430F-BB00-B2C5E6857AB6")]
Private Class GraphicsBase
    
    Implements IVBPrint
    
    Private Type size
        cx As Long
        cy As Long
    End Type

    Type BaseGraphicsInfo
        ScaleLeft As Double
        ScaleTop As Double
        ScaleWidth As Double
        ScaleHeight As Double
        
        WindowHDC As LongPtr
        WindowHandle As LongPtr
        CachedFontCharHeight As Long
        CachedFontAvgCharWidth As Long
        BufferDC As LongPtr
        BufferBitmap As LongPtr
        OrigBitmap As LongPtr
        CurrentClientRect As WinNativeFormsBASE.RECT
        BufferBitmapWidth As Long
        BufferBitmapHeight As Long
        Owner As Object
        IsForm As Boolean
        IsReport As Boolean
        IsUserControl As Boolean
        IsPropertyPage As Boolean
        InternalIgnoreFontChange As Boolean
        CurrentGraphicsFontHandle As LongPtr
        CurrentGraphicsFontDC As LongPtr
        CurrentGraphicsFontHandleOLD As LongPtr
        InternalScaleFactorX As Double
        InternalScaleFactorX_OriginalPixelsWidth As Long
        InternalScaleFactorY As Double
        InternalScaleFactorY_OriginalPixelsHeight As Long
        InternalDrawStyle As Long
        InternalCachedScaleTop As Double
        InternalCachedScaleLeft As Double
        MuteResizeEvent As Boolean
        PendingResizeEvent As Boolean
    End Type
    Private BaseGraphicsInfo As BaseGraphicsInfo

    [Serialize(True, "ScaleLeft")]
        Private ScaleLeftINIT As Double
    [Serialize(True, "ScaleTop")]
        Private ScaleTopINIT As Double
    [Serialize(True, "ScaleWidth")]
        Private ScaleWidthINIT As Double
    [Serialize(True, "ScaleHeight")]
        Private ScaleHeightINIT As Double
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetDC Lib "user32" (ByVal hWnd As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetTextMetricsW Lib "gdi32" (ByVal hDc As LongPtr, lptm As TEXTMETRICW) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetTextExtentPointW Lib "gdi32" (ByVal hDc As LongPtr, ByVal lpString As String, ByVal c As Long, ByRef lpsz As size) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function TabbedTextOutW Lib "user32" (ByVal HDC As LongPtr, ByVal X As Long, ByVal Y As Long, ByVal lpString As String, ByVal StringLen As Long, ByVal nTabPositions As Long, ByRef arrayOfPositions As Long, ByVal nTabOrigin As Long) As Long  ' we only pass 1 value to arrayOfPositions, so this definition is OK for our needs
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetTabbedTextExtentW Lib "user32" (ByVal HDC As LongPtr, ByVal lpString As LongPtr, ByVal StringLen As Long, ByVal nTabPositions As Long, ByRef arrayOfPositions As Long) As Long  ' we only pass 1 value to arrayOfPositions, so this definition is OK for our needs    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateCompatibleDC Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateCompatibleBitmap Lib "gdi32" (ByVal hdc As LongPtr, ByVal nWidth As Long, ByVal nHeight As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SelectObject Lib "gdi32" (ByVal hdc As LongPtr, ByVal hObject As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetCurrentPositionEx Lib "gdi32" (ByVal hdc As LongPtr, ByRef lppt As POINTL) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function Arc Lib "gdi32" (ByVal hdc As LongPtr, ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long, ByVal x3 As Long, ByVal y3 As Long, ByVal x4 As Long, ByVal y4 As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function Pie Lib "gdi32" (ByVal hdc As LongPtr, ByVal x1 As Long, ByVal y1 As Long, ByVal x2 As Long, ByVal y2 As Long, ByVal x3 As Long, ByVal y3 As Long, ByVal x4 As Long, ByVal y4 As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteObject Lib "gdi32" (ByVal handle As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateSolidBrush Lib "gdi32" (ByVal Color As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function Rectangle Lib "gdi32" (ByVal hdc As LongPtr, ByVal left As Long, ByVal top As Long, ByVal right As Long, ByVal bottom As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetClientRect Lib "user32" (ByVal hWnd As LongPtr, ByRef outRect As WinNativeFormsBASE.RECT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetWindowRect Lib "user32" (ByVal hWnd As LongPtr, ByRef outRect As WinNativeFormsBASE.RECT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function BitBlt Lib "gdi32" (ByVal hDC As LongPtr, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal hdcSrc As LongPtr, ByVal x1 As Long, ByVal y1 As Long, ByVal ROP As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InvalidateRect Lib "user32" (ByVal hWnd As LongPtr, ByVal lpRect As LongPtr, ByVal bErase As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function UpdateWindow Lib "user32" (ByVal hWnd As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateFontIndirectW Lib "gdi32" (ByRef lpLogFont As WinNativeFormsBASE.LOGFONT) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetObjectW Lib "gdi32" (ByVal hObject As LongPtr, ByVal nCount As Long, ByRef lpObject As Any) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetObjectType Lib "gdi32" (ByVal hObject As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetSystemMetrics Lib "user32" (ByVal index As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function FillRect Lib "user32" (ByVal hdc As LongPtr, ByRef rect As WinNativeFormsBASE.RECT, ByVal brush As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Sub RtlMoveMemory Lib "kernel32" (ByVal lpDest As LongPtr, ByVal lpSource As LongPtr, ByVal Size As LongPtr)
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GetDIBits Lib "gdi32" (ByVal hdc As LongPtr, ByVal hbm As LongPtr, ByVal start As Long, ByVal cLines As Long, ByVal lpvBits As LongPtr, ByRef lpbmi As BITMAPINFO_RGBA, ByVal usage As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function StretchDIBits Lib "gdi32" (ByVal hdc As LongPtr, ByVal xDest As Long, ByVal yDest As Long, ByVal DestWidth As Long, ByVal DestHeight As Long, ByVal xSrc As Long, ByVal ySrc As Long, ByVal SrcWidth As Long, ByVal SrcHeight As Long, ByVal lpBits As LongPtr, ByRef lpbmi As BITMAPINFO_RGBA, ByVal iUsage As Long, ByVal rop As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function StretchBlt Lib "gdi32" (ByVal hdcDest As LongPtr, ByVal xDest As Long, ByVal yDest As Long, ByVal wDest As Long, ByVal hDest As Long, ByVal hdcSrc As LongPtr, ByVal xSrc As Long, ByVal ySrc As Long, ByVal wSrc As Long, ByVal hSrc As Long, ByVal rop As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetStretchBltMode Lib "gdi32" (ByVal hdc As LongPtr, ByVal mode As Long) As Long
    
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteDC Lib "gdi32" (ByVal hDC As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function GdiFlush Lib "gdi32" () As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetWindowOrgEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetWindowExtEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetViewportOrgEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetViewportExtEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function ClientToScreen Lib "user32" (ByVal hWnd As LongPtr, ByRef point As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateMetaFileW Lib "gdi32" (ByVal pszFile As String) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CloseMetaFile Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function PlayMetaFile Lib "gdi32" (ByVal hdc As LongPtr, ByVal hmf As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetMapMode Lib "gdi32" (ByVal hdc As LongPtr, ByVal iMode As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function OffsetWindowOrgEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef point As POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function ScaleViewportExtEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal xn As Long, ByVal dx As Long, ByVal yn As Long, ByVal yd As Long, ByVal lpSize As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function MapWindowPoints Lib "user32" (ByVal hWndFrom As LongPtr, ByVal hWndTo As LongPtr, ByRef lpPoints As POINT, ByVal cPoints As Long) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CreateEnhMetaFileW Lib "gdi32" (ByVal hdc As LongPtr, ByVal lpFilename As String, ByRef lprc As WinNativeFormsBASE.RECT, ByVal lpDesc As String) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function CloseEnhMetaFile Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function PlayEnhMetaFile Lib "gdi32" (ByVal hdc As LongPtr, ByVal hmf As LongPtr, ByRef lprect As WinNativeFormsBASE.RECT) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteEnhMetaFile Lib "gdi32" (ByVal hmf As LongPtr) As Long
            
    Private Enum VBPaintFlags
    	StepOnFirstCoords = 1
        ColorSpecified = 2
        FirstCoordsSpecified = 4
        StepOnSecondCoords = 8
        Box = 16
        BoxFilled = 32
        StartSpecified = 64
        EndSpecified = 128
        AspectSpecified = 256
    End Enum
    
    'Private Log As String
    
    

    Public FontTransparent As Boolean = True
    
    Public PictureDpiScaling As Boolean = True
    'Public RenderPictureAsIcon As Boolean = False

    [Serialize(False)]
    Public hDC As LongPtr

    Public HasDC As Boolean = True
    Public ClipControls As Boolean = True
    
    [Serialize(False)]
    Friend InternalCurrentX As Double               ' These reflect DPI, not unscaled values
    [Serialize(False)]
    Friend InternalCurrentY As Double               ' These reflect DPI, not unscaled values

    [CustomDesigner("designer_SpectrumWindows")]
    Public FillColor As OLE_COLOR = 0
    Public FillStyle As FillStyleConstants = FillStyleConstants.vbFSTransparent
    [CustomDesigner("designer_SpectrumWindows")]
    Public BackColor As OLE_COLOR = VBRUN.SystemColorConstants.vb3DFace
    [CustomDesigner("designer_SpectrumWindows")]
    Public ForeColor As OLE_COLOR = SystemColorConstants.vbButtonText
    Public DrawWidth As Long = 1
    Public DrawMode As DrawModeConstants = DrawModeConstants.vbCopyPen
    Public DrawStyle As DrawStyleConstants = DrawStyleConstants.vbSolid
    Public AutoRedraw As Boolean = False

    [Description("")]
    Public ScaleMode As VBRUN.ScaleModeConstants = VBRUN.ScaleModeConstants.vbTwips
        
    [Serialize(False)]
    Friend InternalIsFirstResizeEventAfterLoad As Boolean = False
    
    [Serialize(False)]
    Friend InternalCurrentBrush As LongPtr
    Private WithEvents RootWindowElementBASE As WindowsControls.WindowElement

    [Serialize(False)]
    Friend IsPainting As Boolean = False

    Public Sub New(Optional RootWindowElement As WindowsControls.WindowElement)
    	Set Me.RootWindowElementBASE = RootWindowElement
    End Sub
        
    Private Sub HandleColors(ByVal hdc As LongPtr, ByRef BackBrushOut As LongPtr, ByVal ControlType As ControlTypeConstants) _
        Handles RootWindowElementBASE.GetColors
        
        ' This is used as a fallback, generally for custom windows created manually with CreateWindow API
        ' (we see it needed in tbShellBrowse)
        Dim BackColor As Any = Me.BackColor
        Dim ForeColor As Any = Me.ForeColor
        WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, WinNativeFormsBASE.GDI32_TranslateColorFromHDC(ForeColor, hdc))
        WinNativeFormsBASE.WindowsAPI.GDI32_SetBackColor(hdc, WinNativeFormsBASE.GDI32_TranslateColorFromHDC(BackColor, hdc))
        BackBrushOut = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(TranslateColor(BackColor))  ' FIXME leak?
    End Sub
    
    Private Sub HandleResize() _
            Handles RootWindowElementBASE.Resize
        
        Dim newRect As WinNativeFormsBASE.RECT
        Dim hwnd As Any = Me.BaseGraphicsInfo.WindowHandle
        GetClientRect(hwnd, newRect)
        
        ' If IsForm Then
        '     Debug.Print "RootWindowElementBASE.Resize (InternalIsFirstResizeEventAfterLoad:=" & InternalIsFirstResizeEventAfterLoad & ", MuteResizeEvent:=" & MuteResizeEvent & ")"
        ' End If
                    
        If newRect.Left = Me.BaseGraphicsInfo.CurrentClientRect.Left And _
            newRect.Top = Me.BaseGraphicsInfo.CurrentClientRect.Top And _
            newRect.Right = Me.BaseGraphicsInfo.CurrentClientRect.Right And _
            newRect.Bottom = Me.BaseGraphicsInfo.CurrentClientRect.Bottom Then
            ' No change
            
            ' If IsForm Then
            '     Debug.Print "RootWindowElementBASE.Resize --> No Change"
            ' End If
            
            If InternalIsFirstResizeEventAfterLoad = False Then
                If BaseGraphicsInfo.PendingResizeEvent = True Then
                    If Not BaseGraphicsInfo.MuteResizeEvent Then
                    BaseGraphicsInfo.PendingResizeEvent = False
                        CommonRaiseResize(Me.BaseGraphicsInfo.Owner)
                    End If
                End If
            Else
                InternalIsFirstResizeEventAfterLoad = False
            End If
            Exit Sub
        End If
        
        InternalIsFirstResizeEventAfterLoad = False
        
        If Me.BaseGraphicsInfo.IsUserControl Then
            'Debug.Print "InvalidateBEFORE: ", Me.CurrentClientRect.Left, Me.CurrentClientRect.Top, Me.CurrentClientRect.Right, Me.CurrentClientRect.Bottom
        	'InvalidateRect(WinNativeFormsBASE.GetParent(Me.WindowHandle), VarPtr(Me.CurrentClientRect), 1)    ' Invalidate the old area
            'Debug.Print "InvalidateBEFORE: ", newRect.Left, newRect.Top, newRect.Right, newRect.Bottom
        	'InvalidateRect(WinNativeFormsBASE.GetParent(Me.WindowHandle), VarPtr(newRect), 1)    ' Invalidate the new area
        End If
        
        Me.BaseGraphicsInfo.CurrentClientRect = newRect
        
        If Me.AutoRedraw Then
        	AutoRedrawChanged
        End If
        
        If Me.BaseGraphicsInfo.Owner IsNot Nothing Then
            If Me.ScaleMode = ScaleModeConstants.vbUser Then
            
                Dim PixelsWidth As Long
                Dim PixelsHeight As Long
                Dim UnitPixelScale As Any = Me.RootWindowElementBASE.UnitPixelScale
                
                ' When user scaling is set, resync the scalewidth/scaleheight now
                If Me.BaseGraphicsInfo.IsForm = True Then
                    PixelsWidth = CLng((BaseGraphicsInfo.CurrentClientRect.Right - BaseGraphicsInfo.CurrentClientRect.Left) / UnitPixelScale)
                    PixelsHeight = CLng((BaseGraphicsInfo.CurrentClientRect.Bottom - BaseGraphicsInfo.CurrentClientRect.Top) / UnitPixelScale)
                Else
                    ' include border etc on child controls
                    Dim windowRect As WinNativeFormsBASE.RECT
                    GetWindowRect(hwnd, windowRect)
                    PixelsWidth = CLng((windowRect.Right - windowRect.Left) / UnitPixelScale)
                    PixelsHeight = CLng((windowRect.Bottom - windowRect.Top) / UnitPixelScale)
                End If
                Dim InternalScaleFactorX_OriginalPixelsWidth As Any = Me.BaseGraphicsInfo.InternalScaleFactorX_OriginalPixelsWidth
                If (InternalScaleFactorX_OriginalPixelsWidth <> 0) And (InternalScaleFactorX_OriginalPixelsWidth <> PixelsWidth) Then
                    'Debug.Print "Me.InternalScaleFactorX_OriginalPixelsWidth: ", Me.InternalScaleFactorX_OriginalPixelsWidth, " [PixelsWidth: " & PixelsWidth & "]"
                    BaseGraphicsInfo.ScaleWidth = PixelsWidth * Me.BaseGraphicsInfo.InternalScaleFactorX
                End If
                Dim InternalScaleFactorY_OriginalPixelsHeight As Any = Me.BaseGraphicsInfo.InternalScaleFactorY_OriginalPixelsHeight
                If (InternalScaleFactorY_OriginalPixelsHeight <> 0) And (InternalScaleFactorY_OriginalPixelsHeight <> PixelsHeight) Then
                    BaseGraphicsInfo.ScaleHeight = PixelsHeight * Me.BaseGraphicsInfo.InternalScaleFactorY
                End If
            End If
        End If
                
        SyncScaleMode()
        
        If Me.BaseGraphicsInfo.IsUserControl Then
            ' UserControls do not raise the Resize event in response to WM_SIZE.   See https://jeffpar.github.io/kbarchive/kb/187/Q187740/
        ElseIf Me.BaseGraphicsInfo.IsPropertyPage Then
        Else
            BaseGraphicsInfo.PendingResizeEvent = False
            If Me.BaseGraphicsInfo.Owner IsNot Nothing Then
                If Not BaseGraphicsInfo.MuteResizeEvent Then
                    CommonRaiseResize(Me.BaseGraphicsInfo.Owner)
                Else
                    BaseGraphicsInfo.PendingResizeEvent = True
                End If
            Else
                BaseGraphicsInfo.PendingResizeEvent = True
            End If
        End If
        
        ' Seems to work best (in ucShellBrowse) doing these steps seperately.
        If Me.BaseGraphicsInfo.IsUserControl Then
            If Me.BaseGraphicsInfo.Owner.ClipControls = True Then
                ' this is needed for PictureBox inside a UC to properly redraw
                WinNativeFormsBASE.RedrawWindow(hwnd, 0, 0, WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_ALLCHILDREN)
            End If
        ElseIf Me.BaseGraphicsInfo.IsPropertyPage Then
        	
        ElseIf Me.BaseGraphicsInfo.IsForm = False And Me.BaseGraphicsInfo.IsUserControl = False Then
            ' just for picture boxes? 
            'WinNativeFormsBASE.RedrawWindow(hwnd, 0, 0, WinNativeFormsBASE.RDW_INVALIDATE)
            'WinNativeFormsBASE.RedrawWindow(hwnd, 0, 0, WinNativeFormsBASE.RDW_NOCHILDREN Or WinNativeFormsBASE.RDW_UPDATENOW)
            'WinNativeFormsBASE.RedrawWindow(hwnd, 0, 0, WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_UPDATENOW)
            WinNativeFormsBASE.RedrawWindow(hwnd, 0, 0, WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_UPDATENOW)
            'Debug.Print "Redrawing Picture Box " & Hex(hwnd)
            'Sleep 3000
        End If
            
    End Sub
    
    Private Sub AdjustRemoveBorderPixels(ByVal Owner As Object, ByRef Value As Double)
        If BaseGraphicsInfo.IsForm = False Then      ' FIXME
            If TypeOf Owner Is UserControl Then
                Dim uc As UserControl = CType(Of UserControl)(Owner)
                If uc.BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
                    Value -= 1 ' 1 pixel either side   
                    If Owner.Appearance = VBRUN.AppearanceConstants.vbAppear3d Then
                        Value -= 1 ' a further 1 pixel either side     
                    End If
                End If
            ElseIf TypeOf Owner Is PropertyPage Then
            	' FIXME
            ElseIf TypeOf Owner Is MDIForm Then
                ' FIXME
            ElseIf TypeOf Owner Is PictureBox Then
                Dim pbox As PictureBox = CType(Of PictureBox)(Owner)
                If pbox.BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
                    Value -= 1 ' 1 pixel either side   
                    If pbox.Appearance = VBRUN.AppearanceConstants.vbAppear3d Then
                        Value -= 1 ' a further 1 pixel either side     
                    End If
                End If
            Else
                Dim frm As WinNativeFormsBASE.BaseForm = CType(Of WinNativeFormsBASE.BaseForm)(Owner)
                If frm.BorderStyle = ControlBorderStyleConstants.vbFixedSingleBorder Then
                    Value -= 1 ' 1 pixel either side   
                    If frm.Appearance = VBRUN.AppearanceConstants.vbAppear3d Then
                        Value -= 1 ' a further 1 pixel either side     
                    End If
                End If
            End If
        End If
    End Sub

    Private Sub DrawStyleChanged() _
            Handles DrawStyle.OnPropertyLet
    	
        Dim drawStyleOut As Long
        Select Case Me.DrawStyle
            Case DrawStyleConstants.vbInvisible: drawStyleOut = PS_NULL
            Case DrawStyleConstants.vbSolid: drawStyleOut = PS_SOLID
            Case DrawStyleConstants.vbDot: drawStyleOut = PS_DOT
            Case DrawStyleConstants.vbDash: drawStyleOut = PS_DASH
            Case DrawStyleConstants.vbDashDot: drawStyleOut = PS_DASHDOT
            Case DrawStyleConstants.vbDashDotDot: drawStyleOut = PS_DASHDOTDOT
            Case DrawStyleConstants.vbInsideSolid: drawStyleOut = PS_INSIDEFRAME
            Case Else
                Exit Sub
        End Select
        
        BaseGraphicsInfo.InternalDrawStyle = drawStyleOut
    End Sub
    
    Private Sub FillStyleChanged() _
            Handles FillStyle.OnPropertyLet, _
                    FillColor.OnPropertyLet
        
        Dim fillBrush As Any = CommonFillStyleToBrush(Me.FillStyle, True, 0, FillColor)
        Dim oldBrush As Any = InternalCurrentBrush
        If oldBrush <> 0 Then DeleteObject(oldBrush)
        InternalCurrentBrush = fillBrush
    End Sub
    
    Private Sub SignificantChange() _
            Handles BackColor.OnPropertyLet

        ' FIXME check if actually changed
        
        If Me.AutoRedraw = True Then
            Cls
        Else
            Dim hwnd As LongPtr = Me.BaseGraphicsInfo.WindowHandle
            If hwnd <> 0 Then InvalidateRect(hwnd, 0, 1)
        End If
         
        If Me.BaseGraphicsInfo.IsUserControl Then
            CommonRaiseViewChanged(Me.BaseGraphicsInfo.Owner)
        End If
        
        If Me.BaseGraphicsInfo.IsUserControl Or Me.BaseGraphicsInfo.IsForm Then
            NotifyActiveXAmbientPropertyChanges(DISPID_AMBIENT_BACKCOLOR)
        End If
    End Sub
    
    Private Sub ForeColorChanged() _
            Handles ForeColor.OnPropertyLet
            
        ' FIXME check if actually changed
        
        WinNativeFormsBASE.GDI32_SetTextForeColor(Me.hDC, TranslateColor(Me.ForeColor))
        
    	If Me.BaseGraphicsInfo.IsUserControl Or Me.BaseGraphicsInfo.IsForm Then
            NotifyActiveXAmbientPropertyChanges(DISPID_AMBIENT_FORECOLOR)
        End If
    End Sub
    
    Private Sub NotifyActiveXAmbientPropertyChanges(ByVal dispID As Long)
        On Error GoTo Error
        Dim allControls As Object = Me.BaseGraphicsInfo.Owner.Parent.Controls
        ' FIXME could do with a HasActiveXControl flag for the controls group to avoid the loop in most instances
        Dim ctl As Control
        For Each ctl In allControls
            If ctl.Container Is Me.BaseGraphicsInfo.Owner Then
                If TypeOf ctl Is ActiveXControlExtenderBase Then
                    With CType(Of ActiveXControlExtenderBase)(ctl)
                        .InternalAmbientPropertyChanged(dispID)
                    End With
                End If
            End If
        Next
    Error:
        Exit Sub
    End Sub
    
    [Serialize(False)]
    Friend InternalPicture As StdPicture
    
    [Serialize(False)]
    Public Property Get Picture() As StdPicture
        Return InternalPicture
    End Property

    [Serialize(False)]
    Public Property Set Picture(Value As StdPicture)
        Set InternalPicture = Value
        PictureChanged()
    End Property

    [Serialize(False)]
    Public Property Let Picture(Value As StdPicture)    ' Weirdly, VBx also implements the Let for this
        Set InternalPicture = Value
        PictureChanged()
    End Property
    
    Private Sub PictureChanged()
        SignificantChange()
                
        If (Me.BaseGraphicsInfo.Owner IsNot Nothing) And (Me.BaseGraphicsInfo.IsForm = False) And _
                (Me.BaseGraphicsInfo.IsUserControl = False) And (Me.BaseGraphicsInfo.IsPropertyPage = False) Then
            CommonRaiseChange(Me.BaseGraphicsInfo.Owner)
        End If
                
        On Error GoTo NoAutoSize
        If Me.BaseGraphicsInfo.Owner.AutoSize Then
            Me.BaseGraphicsInfo.Owner.AutoSizeNow(Me.Picture)
            SignificantChange()     ' needed to ensure CurrentClientRect gets updated
        End If
        NoAutoSize:
    End Sub
    
    Private Sub AutoRedrawChanged() _
            Handles AutoRedraw.OnPropertyLet

        If AutoRedraw = True Then
            Dim BitmapWidth As Long
            Dim BitmapHeight As Long

            BitmapWidth = BaseGraphicsInfo.CurrentClientRect.Right - BaseGraphicsInfo.CurrentClientRect.Left
            BitmapHeight = BaseGraphicsInfo.CurrentClientRect.Bottom - BaseGraphicsInfo.CurrentClientRect.Top

            If BaseGraphicsInfo.IsForm Then
                ' VB6 uses the current (main) screen resolution to create a persistent buffered bitmap
                '  which allows resizes of forms to retain their content, even when expanded
                Const SM_CXSCREEN As Long = 0
                Const SM_CYSCREEN As Long = 1
                Dim screenWidth As Long = GetSystemMetrics(SM_CXSCREEN)
                Dim screenHeight As Long = GetSystemMetrics(SM_CYSCREEN)
                If screenWidth > BitmapWidth Then BitmapWidth = screenWidth
                If screenHeight > BitmapHeight Then BitmapHeight = screenHeight
            End If
            
            ' Only create a new HDC if the new area is bigger than the cached bitmap area (in either direction)
            
            Dim BufferBitmapWidth As Any = Me.BaseGraphicsInfo.BufferBitmapWidth
            Dim BufferBitmapHeight As Any = Me.BaseGraphicsInfo.BufferBitmapHeight
            If (BitmapWidth > BufferBitmapWidth) Or (BitmapHeight > BufferBitmapHeight) Then
                
                Dim newWidth As Long = If(BitmapWidth > BufferBitmapWidth, BitmapWidth, BufferBitmapWidth)
                Dim newHeight As Long = If(BitmapHeight > BufferBitmapHeight, BitmapHeight, BufferBitmapHeight)
                
                ClearCachedFont()
                
                'Debug.Print "Expanding cached bitmap!...."
                Dim windowHDC As Any = Me.BaseGraphicsInfo.WindowHDC
                Dim oldHDC As Any = Me.BaseGraphicsInfo.BufferDC
                Dim newHDC As Any = CreateCompatibleDC(windowHDC)
                Me.BaseGraphicsInfo.BufferDC = newHDC
                Me.BaseGraphicsInfo.BufferBitmap = CreateCompatibleBitmap(windowHDC, newWidth, BitmapHeight)
                Me.BaseGraphicsInfo.OrigBitmap = SelectObject(newHDC, Me.BaseGraphicsInfo.BufferBitmap)
                Me.hDC = newHDC
                
                If oldHDC <> 0 Then
                    ' Copy the old buffer into the new one.
                    Me.PaintBackground(newWidth, newHeight)
                    
                    ' this will then copy over any of the old buffer into the new one
                    BitBlt(newHDC, 0, 0, BufferBitmapWidth, BufferBitmapHeight, oldHDC, 0, 0, vbSrcCopy)
                    DeleteObject(oldHDC)
                Else
                    ' otherwise try to copy over from the real HDC into our bitmap
                    BitBlt(newHDC, 0, 0, newWidth, newHeight, windowHDC, 0, 0, vbSrcCopy)
                End If

                Me.BaseGraphicsInfo.BufferBitmapWidth = newWidth
                Me.BaseGraphicsInfo.BufferBitmapHeight = newHeight
            End If
        Else
            RemoveBuffer()
        End If
        
        InternalSyncFontProperties(False)
    End Sub
    
    Private Sub RemoveBuffer()
    	Dim OrigBitmap As Any = Me.BaseGraphicsInfo.OrigBitmap
    	If OrigBitmap <> 0 Then
            SelectObject(Me.BaseGraphicsInfo.BufferDC, OrigBitmap)
            Me.BaseGraphicsInfo.OrigBitmap = 0
        End If
        Dim BufferBitmap As Any = Me.BaseGraphicsInfo.BufferBitmap
        If BufferBitmap <> 0 Then
            DeleteObject(BufferBitmap)
            Me.BaseGraphicsInfo.BufferBitmap = 0
        End If
        Dim BufferDC As Any = Me.BaseGraphicsInfo.BufferDC
        If BufferDC <> 0 Then
            DeleteObject(BufferDC)
            Me.BaseGraphicsInfo.BufferDC = 0
        End If
        Me.hDC = Me.BaseGraphicsInfo.WindowHDC
        Me.BaseGraphicsInfo.BufferBitmapWidth = 0
        Me.BaseGraphicsInfo.BufferBitmapHeight = 0
    End Sub
            
    Friend Sub OnPaint(hdc As LongPtr, Optional Windowless As Boolean)
        Dim BackColor As Any = Me.BackColor
        Dim RootWindowElementBASE As Any = Me.RootWindowElementBASE
        If Me.BaseGraphicsInfo.IsReport Then
        Else
            If Windowless Or Me.AutoRedraw = False Then
                If (Windowless = False) OrElse (Me.BaseGraphicsInfo.Owner.BackStyle = vbBFOpaque) Then     ' only UserControls have this facility
                    Dim backBrush As LongPtr = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(TranslateColor(BackColor))
                    WinNativeFormsBASE.USER32_FillWithBrush(RootWindowElementBASE, hdc, backBrush)       ' FIXME this is wrong for Windowless, as it uses RootWindowElement.Handle to get the rect
                    WinNativeFormsBASE.WindowsAPI.GDI32_DeleteObject(backBrush)
                End If
                Me.InternalPaintPicture(hdc)
            Else
                Me.CopyBufferToDC(hdc)
            End If
        End If
        RootWindowElementBASE.PaintContainedWindowlessElements(hdc)
                
        If Windowless Or ((Me.AutoRedraw = False) And (Me.IsPainting = False)) Then
            
            Dim actualForeColor As Long = TranslateColor(If(Me.BaseGraphicsInfo.IsPropertyPage OrElse (Me.BaseGraphicsInfo.Owner Is Nothing) OrElse Me.BaseGraphicsInfo.Owner.Enabled, ForeColor, vbGrayText))
            Dim oldTextColor As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, actualForeColor)
            Dim oldBackColor As Long = WinNativeFormsBASE.WindowsAPI.SetBkColor(hdc, TranslateColor(BackColor))
            Dim oldBkMode As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, If(Me.FontTransparent, WinNativeFormsBASE.BackgroundModes.TRANSPARENT, WinNativeFormsBASE.BackgroundModes.OPAQUE))

            Dim hFontOld As LongPtr
            Dim Font As Any = CType(Of IFont)(Me.Font)
            If Not Font Is Nothing Then hFontOld = WinNativeFormsBASE.SelectObject(hdc, Font.hFont)
            
            Dim oldDc As LongPtr = Me.hDC
            Me.hDC = hdc
            
            Dim savedDCInfoIdx As Long
            If Windowless AndAlso (Me.BaseGraphicsInfo.Owner.ClipBehavior = VbClipBehavior.vbClipUseRegion) Then
                ' When ClipBehavior is vbClipUseRegion, painting occuring in Paint event is clipped 
            	savedDCInfoIdx = SaveDC(hdc)    ' preserve clip region
                With CType(Of TbUserControlPrivate)(Me.BaseGraphicsInfo.Owner)
                    IntersectClipRect(hdc, CLng(.WindowlessRectLeft), CLng(.WindowlessRectTop), CLng(.WindowlessRectRight), CLng(.WindowlessRectBottom))
                End With
            End If
            
            Me.IsPainting = True
            CommonRaisePaint(Me.BaseGraphicsInfo.Owner)
            Me.IsPainting = False
            Me.hDC = oldDc
            
            If Windowless AndAlso (Me.BaseGraphicsInfo.Owner.ClipBehavior = VbClipBehavior.vbClipUseRegion) Then
                RestoreDC(hdc, savedDCInfoIdx)
            End If
    
            If hFontOld <> 0 Then WinNativeFormsBASE.SelectObject(hdc, hFontOld)
            Set Font = Nothing
                
            WinNativeFormsBASE.WindowsAPI.GDI32_SetBackMode(hdc, oldBkMode)
            WinNativeFormsBASE.WindowsAPI.SetBkColor(hdc, oldBackColor)
            WinNativeFormsBASE.WindowsAPI.GDI32_SetTextForeColor(hdc, oldTextColor)
            'WinNativeFormsBASE.SelectObject(ps.hdc, oldFont)

        End If
    End Sub

    Friend Sub InternalPaintPicture(hdc As LongPtr)
        ' FIXME very similar code in HandlePaintMDIClient
        If (Me.InternalPicture IsNot Nothing) And (hdc <> 0) Then
            
            Dim Picture As OlePicture = Me.InternalPicture
            
            ' If RenderPictureAsIcon = True Then
            '     Dim picWidth As Long
            '     Dim picHeight As Long
            '     VB.ScaleOLEPictureDimensionsToPixels(vbPicTypeNone, Picture.Width, picWidth, Picture.Height, picHeight)
            '     Set Picture = RuntimeCreateScaledPicture(Picture, picWidth, picHeight, True, True)
            ' End If
            
            Const STRETCH_HALFTONE = 4
            Const PICTYPE_METAFILE As Long = 2
            Const PICTYPE_ENHMETAFILE As Long = 4
                        
            Dim OldStretchMode As Long = WinNativeFormsBASE.WindowsAPI.GDI32_SetBitmapStretchMode(hdc, STRETCH_HALFTONE)
            WinNativeFormsBASE.WindowsAPI.GDI32_SetBrushOrigin(hdc, 0, 0, 0)
            
            Dim DrawWidth As Long
            Dim DrawHeight As Long
            
            Dim pictureType As Any = CType(Of PictureTypeConstants)(Picture.Type)
            Dim pictureWidth As Any = Picture.Width
            Dim pictureHeight As Any = Picture.Height
            If (pictureType = PICTYPE_METAFILE) Or (pictureType = PICTYPE_ENHMETAFILE) Then
                ' Size the metafile to fill the area                
                If AutoRedraw Then
                	DrawWidth = BaseGraphicsInfo.BufferBitmapWidth
                	DrawHeight = BaseGraphicsInfo.BufferBitmapHeight
                Else
                    DrawWidth = BaseGraphicsInfo.CurrentClientRect.Right - BaseGraphicsInfo.CurrentClientRect.Left
                    DrawHeight = BaseGraphicsInfo.CurrentClientRect.Bottom - BaseGraphicsInfo.CurrentClientRect.Top
                End If
            Else
                ScaleOLEPictureDimensionsToPixels(pictureType, pictureWidth, DrawWidth, pictureHeight, DrawHeight)
                If PictureDpiScaling = True Then
                	Dim UnitPixelScale As Any = Me.RootWindowElementBASE.UnitPixelScale
                    DrawWidth = CLng(DrawWidth * UnitPixelScale)
                    DrawHeight = CLng(DrawHeight * UnitPixelScale)
                End If
            End If
            If (DrawWidth > 0) And (DrawHeight > 0) Then
                PictureRender(Picture, hdc, 0, 0, DrawWidth, DrawHeight)
            End If
            WinNativeFormsBASE.WindowsAPI.GDI32_SetBitmapStretchMode(hdc, OldStretchMode)

        End If
    End Sub
        
    Private Sub PaintBackground(ByVal Width As Long, ByVal Height As Long)
        Dim backBrush As LongPtr = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(TranslateColor(BackColor))
        
        If AutoRedraw Then
            Dim rect As WinNativeFormsBASE.RECT
            rect.Right = Width
            rect.Bottom = Height
            FillRect(hDC, rect, backBrush)
        Else
            WinNativeFormsBASE.USER32_FillWithBrush(Me.RootWindowElementBASE, Me.hDC, backBrush)
        End If
        
        WinNativeFormsBASE.WindowsAPI.GDI32_DeleteObject(backBrush)
    End Sub
    
    Public Sub Cls()
    	Dim hdc As Any = Me.hDC
    	If Me.AutoRedraw = True Then
            Me.PaintBackground(Me.BaseGraphicsInfo.BufferBitmapWidth, Me.BaseGraphicsInfo.BufferBitmapHeight)
            Me.InternalPaintPicture(hdc)
            'RootWindowElementBASE.PaintContainedWindowlessElements(Me.hDC)
            Me.CopyBufferToDC(Me.BaseGraphicsInfo.WindowHDC)
            UpdateWindow(Me.BaseGraphicsInfo.WindowHandle)   ' important otherwise children might not get redrawn properly (tbShellBrowse)
        Else
            Me.OnPaint(hdc)
            'If IsPainting = False Then
                'If IsPainting = False Then
                '    InvalidateRect(Me.WindowHandle, 0, 1)
                '    UpdateWindow(Me.WindowHandle)
                'End If
            'End If
    	End If
        InternalCurrentX = 0
        InternalCurrentY = 0
    End Sub
    
    Friend Sub CopyBufferToDC(hdc As LongPtr)
    	BitBlt(hdc, 0, 0, BaseGraphicsInfo.CurrentClientRect.Right - BaseGraphicsInfo.CurrentClientRect.Left, BaseGraphicsInfo.CurrentClientRect.Bottom - BaseGraphicsInfo.CurrentClientRect.Top, Me.BaseGraphicsInfo.BufferDC, 0, 0, vbSrcCopy)
    End Sub

    'Public Function GetLastLog() As String
    '	Return Log
    'End Function
    
    'Public Sub ClearLog()
    '	Log = vbNullString
    'End Sub
    
    ' Private Function ScaleXHimetricToPixels(ByVal X As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbPixels)
    '     Else
    '         'Dim twips As Long = RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbTwips)
    '         ' printer
    '         Const LOGPIXELSX As Long = &H58
    '         Dim scaleX As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX)
    '         ' FIXME need to account for ScaleMode here
    '         Const twipScale As Double = (1.0 / (1440.0 / 96.0))
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return X * himetricScale
    '     End If
    ' End Function
    
    ' Private Function ScaleYHimetricToPixels(ByVal Y As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbPixels)
    '     Else
    '         'Dim twips As Long = RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbTwips)
    '         ' printer
    '         Const LOGPIXELSY As Long = &H5A
    '         Dim scaleY As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY)
    '         ' FIXME need to account for ScaleMode here
    '         'Return Y * ScaleY
            
    '         Const twipScale As Double = (1.0 / (1440.0 / 96.0))
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return Y * himetricScale
    '     End If
    ' End Function

    ' Private Function ScaleXPixelsToHimetric(ByVal X As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbPixels, ScaleModeConstants.vbHimetric)
    '     Else
    '         'Dim twips As Long = RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbTwips)
    '         ' printer
    '         'Const LOGPIXELSX As Long = &H58
    '         'Dim scaleX As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX) / 1440
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return X / himetricScale
    '     End If
    ' End Function
    
    ' Private Function ScaleYPixelsToHimetric(ByVal Y As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbPixels, ScaleModeConstants.vbHimetric)
    '     Else
    '        ' Dim twips As Long = RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbHimetric, ScaleModeConstants.vbTwips)
    '         ' printer
    '         'Const LOGPIXELSY As Long = &H5A
    '         'Dim scaleY As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY) / 1440
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return Y / himetricScale
    '     End If
    ' End Function
    
    ' Private Function ScaleXToHimetric(ByVal X As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleX(X, Me.ScaleMode, ScaleModeConstants.vbHimetric)
    '     Else
    '         ' printer
    '         'Const LOGPIXELSX As Long = &H58
    '         'Dim scaleX As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Const twipScale As Double = (1.0 / (1440.0 / 96.0))
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return (X * twipScale) / himetricScale
    '     End If
    ' End Function
    
    ' Private Function ScaleYToHimetric(ByVal Y As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleY(Y, Me.ScaleMode, ScaleModeConstants.vbHimetric)
    '     Else
    '         ' printer
    '         'Const LOGPIXELSY As Long = &H5A
    '         'Dim scaleY As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Const twipScale As Double = (1.0 / (1440.0 / 96.0))
    '         Const himetricScale As Double = (1.0 * 96.0) / 2540.0
    '         Return (Y * twipScale) / himetricScale
    '     End If
    ' End Function
            
    ' Private Function ScaleXToPixels(ByVal X As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleX(X, Me.ScaleMode, ScaleModeConstants.vbPixels)
    '     Else
    '         ' printer
    '         Const LOGPIXELSX As Long = &H58
    '         Dim scaleX As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Return X * scaleX
    '     End If
    ' End Function
    
    ' Private Function ScaleYToPixels(ByVal Y As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleY(Y, Me.ScaleMode, ScaleModeConstants.vbPixels)
    '     Else
    '         ' printer
    '         Const LOGPIXELSY As Long = &H5A
    '         Dim scaleY As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Return Y * scaleY
    '     End If
    ' End Function
    
    ' Private Function ScaleXToPixels2(ByVal X As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleX(X, Me.ScaleMode, ScaleModeConstants.vbPixels)
    '     Else
    '         ' printer
    '         'Const LOGPIXELSX As Long = &H58
    '         'Dim scaleX As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Return X \ 15
    '     End If
    ' End Function
    
    ' Private Function ScaleYToPixels2(ByVal Y As Double) As Double
    '     If RootWindowElementBASE IsNot Nothing Then
    '         Return RootWindowElementBASE.ScaleY(Y, Me.ScaleMode, ScaleModeConstants.vbPixels)
    '     Else
    '         ' printer
    '         'Const LOGPIXELSY As Long = &H5A
    '         'Dim scaleY As Double = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY) / 1440
    '         ' FIXME need to account for ScaleMode here
    '         Return Y \ 15 ' * scaleY
    '     End If
    ' End Function

    Private Function ScaleXFromPixels(ByVal X As Double) As Double
        Return RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbPixels, Me.ScaleMode)
    End Function
    
    Private Function ScaleYFromPixels(ByVal Y As Double) As Double
        Return RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbPixels, Me.ScaleMode)
    End Function
        
    Private Function ScaleXToScaledPixels(ByVal X As Double) As Double
        If RootWindowElementBASE IsNot Nothing Then
            Return RootWindowElementBASE.ScaleX(X, Me.ScaleMode, ScaleModeConstants.vbScaledPixels)
        Else
            ' printer
            Dim scaleX As Double
            Dim scaleY As Double
            Dim resX As Double
            Dim resY As Double
            InternalGetXYScales(scaleX, scaleY, resX, resY)
            Return X * resX / scaleX
        End If
    End Function
    
    Private Function ScaleYToScaledPixels(ByVal Y As Double) As Double
        If RootWindowElementBASE IsNot Nothing Then
            Return RootWindowElementBASE.ScaleY(Y, Me.ScaleMode, ScaleModeConstants.vbScaledPixels)
        Else
            ' printer
            Dim scaleX As Double
            Dim scaleY As Double
            Dim resX As Double
            Dim resY As Double
            InternalGetXYScales(scaleX, scaleY, resX, resY)
            Return Y * resY / scaleY
        End If
    End Function
    
    Private Function ScaleXFromScaledPixels(ByVal X As Double) As Double
        If RootWindowElementBASE IsNot Nothing Then
            Return RootWindowElementBASE.ScaleX(X, ScaleModeConstants.vbScaledPixels, Me.ScaleMode)
        Else
            Dim scaleX As Double
            Dim scaleY As Double
            Dim resX As Double
            Dim resY As Double
            InternalGetXYScales(scaleX, scaleY, resX, resY)
            Return X * scaleX / resX
        End If
    End Function
    
    Private Function ScaleYFromScaledPixels(ByVal Y As Double) As Double
        If RootWindowElementBASE IsNot Nothing Then
            Return RootWindowElementBASE.ScaleY(Y, ScaleModeConstants.vbScaledPixels, Me.ScaleMode)
        Else
            ' printer
            Dim scaleX As Double
            Dim scaleY As Double
            Dim resX As Double
            Dim resY As Double
            InternalGetXYScales(scaleX, scaleY, resX, resY)
            Return Y * scaleY / resY
        End If
    End Function
    
    Private Sub SetDrawingMixMode()
        GDI32_SetROP2(Me.hDC, Me.DrawMode)
    End Sub
    
    Private Sub HandleAutoRedrawInvalidation()
        If AutoRedraw = True Then
            InvalidateRect(Me.BaseGraphicsInfo.WindowHandle, 0, 1)
            
            If Me.BaseGraphicsInfo.IsUserControl Then
                CommonRaiseViewChanged(Me.BaseGraphicsInfo.Owner)
            End If
        End If
    End Sub
        
    Private Function CreateOurPen(ByRef Color As Long) As LongPtr
        Color = TranslateColor(Color)   ' in-out
        Return CreatePen(BaseGraphicsInfo.InternalDrawStyle, DrawWidth, If(RootWindowElementBASE IsNot Nothing, RootWindowElementBASE.UnitPixelScale, 1#), Color)
    End Function
            
    Private DeclareWide PtrSafe Function DefWindowProcW Lib "user32" (ByVal hwnd As LongPtr, ByVal msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As Long
    
    Private Sub PaintChildrenToDC(ByVal containerWnd As LongPtr, ByVal hwnd As LongPtr, hdc As LongPtr)
        Dim childRect As WinNativeFormsBASE.RECT
        Dim childClientRect As WinNativeFormsBASE.RECT
        Dim savedDc As Long
        Const PRF_NONCLIENT As Long = 2
                
        Dim childWindow As LongPtr = WinNativeFormsBASE.GetWindow(hwnd, WinNativeFormsBASE.GW_CHILD)
        If childWindow <> vbNullPtr Then
            childWindow = WinNativeFormsBASE.GetWindow(childWindow, WinNativeFormsBASE.GW_HWNDLAST)
            While childWindow <> vbNullPtr
                GetWindowRect(childWindow, childRect)
                MapWindowPoints(vbNullPtr, containerWnd, VarPtr(childRect), 2)
                GetClientRect(childWindow, childClientRect)     ' to determine any frame non-client area
                MapWindowPoints(childWindow, containerWnd, VarPtr(childClientRect), 2)
                                                        
                savedDc = SaveDC(hdc)
                    IntersectClipRect(hdc, childClientRect.Left, childClientRect.Top, childClientRect.Right, childClientRect.Bottom)
                    SetWindowOrgEx(hdc, -childClientRect.Left, -childClientRect.Top, vbNullPtr)
                    'SetViewportOrgEx(hdc, childRect.Left, childRect.Top, vbNullPtr) 
                    WinNativeFormsBASE.SendMessageW(childWindow, WinNativeFormsBASE.WM_ERASEBKGND, hdc, 0)
                    WinNativeFormsBASE.SendMessageW(childWindow, WinNativeFormsBASE.WM_PAINT, hdc, 0)
                RestoreDC(hdc, savedDc)
                                
                savedDc = SaveDC(hdc)
                    IntersectClipRect(hdc, childRect.Left, childRect.Top, childRect.Right, childRect.Bottom)
                    SetWindowOrgEx(hdc, -childRect.Left, -childRect.Top, vbNullPtr)
                    'SetViewportOrgEx(hdc, childRect.Left, childRect.Top, vbNullPtr)
                    WinNativeFormsBASE.SendMessageW(childWindow, WinNativeFormsBASE.WM_PRINT, hdc, PRF_NONCLIENT)
                RestoreDC(hdc, savedDc)
                
                ' If the window has the WS_EX_CLIENTEDGE flag set, we have to draw that manually, as WM_PRINT doesn't handle it
                ' Usually we'd use PrintWindow(), which does handle it, but that function doesn't appear to work for meta DCs
                If WinNativeFormsBASE.GetWindowLongW(childWindow, WinNativeFormsBASE.GWL_EXSTYLE) And WinNativeFormsBASE.WS_EX_CLIENTEDGE Then
                    Dim bfStyle As Long = BorderStyles.BDR_SUNKENOUTER Or BorderStyles.BDR_SUNKENINNER
                    Dim bfFlags As Long = BorderFlags.BF_RECT
                    WinNativeFormsBASE.DrawEdge(hdc, childRect, bfStyle, bfFlags)
                End If
                
                ' Same for WS_BORDER
                If WinNativeFormsBASE.GetWindowLongW(childWindow, WinNativeFormsBASE.GWL_STYLE) And WinNativeFormsBASE.WS_BORDER Then
                    bfStyle = BorderStyles.BDR_SUNKENOUTER
                    bfFlags = BorderFlags.BF_RECT Or BorderFlags.BF_MONO Or BorderFlags.BF_FLAT
                    WinNativeFormsBASE.DrawEdge(hdc, childRect, bfStyle, bfFlags)
                End If
                
                savedDc = SaveDC(hdc)
                    IntersectClipRect(hdc, childClientRect.Left, childClientRect.Top, childClientRect.Right, childClientRect.Bottom)
                    PaintChildrenToDC(containerWnd, childWindow, hdc)
                RestoreDC(hdc, savedDc)
                
                childWindow = WinNativeFormsBASE.GetWindow(childWindow, WinNativeFormsBASE.GW_HWNDPREV)
            Wend
        End If
    End Sub
    
    Friend Sub InternalPrintForm(ByVal Printer As Printer, ByVal ImplicitEndDoc As Boolean, ByVal OutputAtCurrentPosition As Boolean)
        
        ' In order to draw nice GDI curves etc in prints, we have to use the GDI recording/playback features
        ' This allows much better GDI drawing due to higher resolution of printers

        ' VB6 uses the older CreateMetaFile method, and blit-copying standard controls, but this gives very pixelated results for 
        ' everything except the standard GDI drawing of lines and shapes and text.
        ' CreateEnhMetaFile appears to work better, supporting drawing of standard controls, without us having to resort to pixel rescaling
        ' The VB6 method is roughly:
        '  CreateMetaFile(mode MM_ANISOTROPIC)
        '    WM_ERASEBKGRD+WM_PAINT to each standard control using a compatible bitmap, then StretchBlt to the metaDC
        '    IOleObject::Draw for AX controls
        '  CloseMetaFile
        '  SetWindowOrgEx+SetWindowExtEx+SetViewportOrgEx+SetViewportExtEx
        '  ScaleViewportExtEx
        '  SetMapMode(MM_ANISOTROPIC)
        '  PlayMetaFile
                
        Dim tbPrinter As ITwinBasicPrinter = CType(Of ITwinBasicPrinter)(Printer)
        Dim tbPrinter_GraphicsBase As Any = tbPrinter.PreparePrintForm()
                
        Dim sourceRect As WinNativeFormsBASE.RECT
        Dim sourceWND As LongPtr = RootWindowElementBASE.Handle
        GetClientRect(sourceWND, sourceRect)
                
        Dim metaDC As LongPtr = CreateEnhMetaFileW(vbNullPtr, vbNullString, vbNullPtr, vbNullString)
                                
        ' WM_ERASEBKGND + WM_PAINT works for drawing the background of the form (inc lighweight controls, and custom painting in OnPaint etc)
        ' but we have to paint any children seperately
        
        WinNativeFormsBASE.SendMessageW(sourceWND, WinNativeFormsBASE.WM_ERASEBKGND, metaDC, 0)
        WinNativeFormsBASE.SendMessageW(sourceWND, WinNativeFormsBASE.WM_PAINT, metaDC, 0)
        PaintChildrenToDC(sourceWND, sourceWND, metaDC)
                
        Dim sourceTwipsX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSX)
        Dim sourceTwipsY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSY)
                           
        Dim destTwipsX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSX)
        Dim destTwipsY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSY)
                
        If (destTwipsX = 0) Or (destTwipsY = 0) Then
            Err.Raise 5     ' invalid
        End If
        
        Dim metaFile As LongPtr = CloseEnhMetaFile(metaDC)
                                
        If (metaFile = 0) Then
            Err.Raise 5     ' invalid
        End If
        
        sourceRect.Right = CLng(sourceRect.Right * sourceTwipsX / destTwipsX)
        sourceRect.Bottom = CLng(sourceRect.Bottom * sourceTwipsY / destTwipsX)
                
        If OutputAtCurrentPosition = True Then
            sourceRect.Left += CLng(tbPrinter_GraphicsBase.InternalCurrentX)
            sourceRect.Right += sourceRect.Left
            sourceRect.Top += CLng(tbPrinter_GraphicsBase.InternalCurrentY)
            sourceRect.Bottom += sourceRect.Top
            
            If tbPrinter_GraphicsBase.ScaleMode = ScaleModeConstants.vbUser Then
                sourceRect.Left += CLng(-tbPrinter_GraphicsBase.ScaleLeft / destTwipsX)
                sourceRect.Top += CLng(-tbPrinter_GraphicsBase.ScaleTop / destTwipsX)
            End If
        End If
        PlayEnhMetaFile(CLngPtr(Printer.hDC), metaFile, sourceRect)
        DeleteEnhMetaFile(metaFile)
                
        If ImplicitEndDoc Then
            Printer.EndDoc()
        Else
            tbPrinter_GraphicsBase.InternalCurrentY += sourceRect.Bottom - sourceRect.Top
        End If
    End Sub
        
    Public Sub Circle(ByVal Flags As VBPaintFlags, _
                        ByVal X As Single, ByVal Y As Single, _
                        ByVal Radius As Single, _	
                        ByVal Color As Long, _
                        ByVal Start As Single, _
                        ByVal _End As Single, _
                        ByVal Aspect As Single)
        'Log = CurrentProcedureName & "(" & Flags & "," & X & "," & Y & "," & Radius & "," & Color & "," & Start & "," & _End & "," & Aspect & ")"
                       
        Dim hdc As Any = Me.hDC
        Dim UnitPixelScale As Double
        Dim IsPrinter As Boolean
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
            IsPrinter = True
        End If

        X = CSng(ScaleXToScaledPixels(X * UnitPixelScale))
        Y = CSng(ScaleYToScaledPixels(Y * UnitPixelScale))
        Radius = CSng(ScaleXToScaledPixels(Radius * UnitPixelScale))
                                               
        If Flags And VBPaintFlags.StepOnFirstCoords Then
            X += CSng(Me.InternalCurrentX)
            Y += CSng(Me.InternalCurrentY)
        End If
                
        Me.InternalCurrentX = X
        Me.InternalCurrentY = Y
                
        If Me.ScaleMode = ScaleModeConstants.vbUser Then
            X += CSng(ScaleXToScaledPixels(-BaseGraphicsInfo.ScaleLeft * UnitPixelScale))
            Y += CSng(ScaleYToScaledPixels(-BaseGraphicsInfo.ScaleTop * UnitPixelScale))
        End If
  
        Dim IncludeLineToStart As Boolean
        Dim IncludeLineToEnd As Boolean
        
        If Start < 0 Then
            Start = CSng(Abs(Start))
            If Start > 6.28318619728 Then Err.Raise 5       ' invalid procedure call or argument
            IncludeLineToStart = True
        End If
        
        If _End < 0 Then
            _End = CSng(Abs(_End))
            If _End > 6.28318619728 Then Err.Raise 5       ' invalid procedure call or argument
            IncludeLineToEnd = True
        End If
                  
        Dim topLeftRectX As Double = -Radius
        Dim topLeftRectY As Double = -Radius
        Dim bottomRightRectX As Double = Radius
        Dim bottomRightRectY As Double = Radius
        Dim startX As Double = CDbl(Radius) * Cos(Start)
        Dim startY As Double = -(CDbl(Radius) * Sin(Start))
        Dim endX As Double = CDbl(Radius) * Cos(_End)
        Dim endY As Double = -(CDbl(Radius) * Sin(_End))
        
        Dim SwitchAspect As Boolean
        If Aspect < -1 Then
            SwitchAspect = True
        End If
        Aspect = CSng(Abs(Aspect))
        
        If (Flags And VBPaintFlags.AspectSpecified) = 0 Then
        
        ElseIf SwitchAspect Or Aspect < 1 Then
            ' Stretch the Y axis
            topLeftRectY *= Aspect
            bottomRightRectY *= Aspect
            startY *= Aspect
            endY *= Aspect
        ElseIf Aspect > 1 Then
            ' Stretch the X axis
            topLeftRectX /= Aspect
            bottomRightRectX /= Aspect
            startX /= Aspect
            endX /= Aspect
        End If
        
        ' Now add in the center position offset...
        topLeftRectX += X
        topLeftRectY += Y
        bottomRightRectX += X
        bottomRightRectY += Y
        startX += X
        startY += Y
        endX += X
        endY += Y
        
        bottomRightRectX += 1
        bottomRightRectY += 1
        
        If (Flags And VBPaintFlags.ColorSpecified) = 0 Then
            Color = Me.ForeColor
        End If
        
        Dim pen As LongPtr = CreateOurPen(Color)
        Dim origPen As LongPtr = SelectObject(hdc, pen)
                      
        SetDrawingMixMode()
         
        Dim oldBrush As LongPtr
        Dim oldBackMode As Long
        
        Dim IsEllipse As Boolean
        Dim IsPie As Boolean
        
        If ((Flags And VBPaintFlags.StartSpecified) = 0) And _
            ((Flags And VBPaintFlags.EndSpecified) = 0) Then
            IsEllipse = True
        ElseIf IncludeLineToStart And IncludeLineToEnd Then
            IsPie = True
        End If
        
        If IsEllipse Or IsPie Then
            ' requires Fill
            oldBrush = SelectObject(hdc, Me.InternalCurrentBrush)
            oldBackMode = WinNativeFormsBASE.GDI32_SetBackMode(hdc, If(IsPrinter, WinNativeFormsBASE.BackgroundModes.TRANSPARENT, WinNativeFormsBASE.BackgroundModes.OPAQUE))
        End If
        
        If IsEllipse Then
            ' this is simple and can be drawn with just Ellipse, which includes fill
            GDI32_Ellipse(hdc, CLng(topLeftRectX), CLng(topLeftRectY), CLng(bottomRightRectX), CLng(bottomRightRectY))
        ElseIf IsPie Then
            ' this can be drawn with Pie, which includes fill
            Pie(hdc, CLng(topLeftRectX), CLng(topLeftRectY), CLng(bottomRightRectX), CLng(bottomRightRectY), CLng(startX), CLng(startY), CLng(endX), CLng(endY))
        Else
            If IncludeLineToStart Then
            	GDI32_MoveToEx(hdc, CLng(X), CLng(Y), 0)
                GDI32_LineTo(hdc, CLng(startX), CLng(startY))
            End If
                        
            Arc(hdc, CLng(topLeftRectX), CLng(topLeftRectY), CLng(bottomRightRectX), CLng(bottomRightRectY), CLng(startX), CLng(startY), CLng(endX), CLng(endY))
        
            If IncludeLineToEnd Then
            	GDI32_MoveToEx(hdc, CLng(endX), CLng(endY), 0)
                GDI32_LineTo(hdc, CLng(X), CLng(Y))
            End If
        End If
        
        If IsEllipse Or IsPie Then
            WinNativeFormsBASE.GDI32_SetBackMode(hdc, oldBackMode)
            SelectObject(hdc, oldBrush)
        End If
        
        SelectObject(hdc, origPen)
        DeleteObject(pen)
        
        HandleAutoRedrawInvalidation()
    End Sub
    
    Public Sub Line(ByVal Flags As VBPaintFlags, _
                        ByVal X1 As Single, _
                        ByVal Y1 As Single, _
                        ByVal X2 As Single, _
                        ByVal Y2 As Single, _
                        ByVal Color As Long)
        'Log = CurrentProcedureName & "(" & Flags & "," & X1 & "," & Y1 & "," & X2 & "," & Y2 & "," & Color & ")"

        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        
        X1 = CSng(ScaleXToScaledPixels(X1 * UnitPixelScale))
        Y1 = CSng(ScaleYToScaledPixels(Y1 * UnitPixelScale))
        X2 = CSng(ScaleXToScaledPixels(X2 * UnitPixelScale))
        Y2 = CSng(ScaleYToScaledPixels(Y2 * UnitPixelScale))
        
        Dim point1X As Long
        Dim point1Y As Long
        Dim point2X As Long
        Dim point2Y As Long
        
        Dim CurrentX As Double = Me.InternalCurrentX
        Dim CurrentY As Double = Me.InternalCurrentY
        Dim hdc As Any = Me.hDC
        
        If Flags And VBPaintFlags.FirstCoordsSpecified Then
        	If Flags And VBPaintFlags.StepOnFirstCoords Then
                point1X = CLng(CurrentX + X1)
                point1Y = CLng(CurrentY + Y1)
            Else
                point1X = CLng(X1)
                point1Y = CLng(Y1)
            End If
        Else
            point1X = CLng(CurrentX)
            point1Y = CLng(CurrentY)
        End If
        
        If Flags And VBPaintFlags.StepOnSecondCoords Then
            If Flags And VBPaintFlags.FirstCoordsSpecified Then
                point2X = CLng(point1X + X2)
                point2Y = CLng(point1Y + Y2)
            Else
                point2X = CLng(CurrentX + X2)
                point2Y = CLng(CurrentY + Y2)
            End If
        Else
            point2X = CLng(X2)
            point2Y = CLng(Y2)
        End If
        
        Me.InternalCurrentX = point2X
        Me.InternalCurrentY = point2Y
        
        If Me.ScaleMode = ScaleModeConstants.vbUser Then
            Dim scaleLeft As Any = BaseGraphicsInfo.ScaleLeft
            Dim scaleTop As Any = BaseGraphicsInfo.ScaleTop
            point1X += CLng(ScaleXToScaledPixels(-scaleLeft * UnitPixelScale))
            point1Y += CLng(ScaleYToScaledPixels(-scaleTop * UnitPixelScale))
            point2X += CLng(ScaleXToScaledPixels(-scaleLeft * UnitPixelScale))
            point2Y += CLng(ScaleYToScaledPixels(-scaleTop * UnitPixelScale))
        End If

        'If Flags And VBPaintFlags.FirstCoordsSpecified Then
            GDI32_MoveToEx(hdc, point1X, point1Y, 0)
        'End If
        
        If (Flags And VBPaintFlags.ColorSpecified) = 0 Then
            Color = Me.ForeColor
        End If
        
        Dim pen As LongPtr = CreateOurPen(Color)
        Dim origPen As LongPtr = SelectObject(hdc, pen)
    
        SetDrawingMixMode()
    
        Dim oldBrush As LongPtr
        Dim oldBackMode As Long
        
        If (Flags And VBPaintFlags.BoxFilled) Then
            Dim fillBrush As LongPtr = CreateSolidBrush(Color)
            oldBrush = SelectObject(hdc, fillBrush)
            Rectangle(hdc, point1X, point1Y, point2X, point2Y)
            SelectObject(hdc, oldBrush)
            DeleteObject(fillBrush)
        ElseIf (Flags And VBPaintFlags.Box) Then
            ' This uses the fill as described by our class
            oldBrush = SelectObject(hdc, Me.InternalCurrentBrush)
            oldBackMode = WinNativeFormsBASE.GDI32_SetBackMode(hdc, WinNativeFormsBASE.BackgroundModes.OPAQUE)
            Rectangle(hdc, point1X, point1Y, point2X, point2Y)
            WinNativeFormsBASE.GDI32_SetBackMode(hdc, oldBackMode)
            SelectObject(hdc, oldBrush)
        Else
            GDI32_LineTo(hdc, point2X, point2Y)
        End If

        SelectObject(hdc, origPen)
        DeleteObject(pen)
            
        HandleAutoRedrawInvalidation()
    End Sub
    
    Public Sub PSet(ByVal Flags As VBPaintFlags, _
                        ByVal X As Single, _
                        ByVal Y As Single, _
                        ByVal Color As Long)
                        
        'Log = CurrentProcedureName & "(" & Flags & "," & X & "," & Y & "," & Color & ")"
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        
        Dim hdc As Any = Me.hDC
        
        X = CSng(ScaleXToScaledPixels(X * UnitPixelScale))
        Y = CSng(ScaleYToScaledPixels(Y * UnitPixelScale))
                                
        If Flags And VBPaintFlags.StepOnFirstCoords Then
            X += CSng(Me.InternalCurrentX)
            Y += CSng(Me.InternalCurrentY)
        End If
        
        Me.InternalCurrentX = X
        Me.InternalCurrentY = Y

        If Me.ScaleMode = ScaleModeConstants.vbUser Then
            X += CSng(ScaleXToScaledPixels(-BaseGraphicsInfo.ScaleLeft * UnitPixelScale))
            Y += CSng(ScaleYToScaledPixels(-BaseGraphicsInfo.ScaleTop * UnitPixelScale))
        End If
        
        GDI32_MoveToEx(hdc, CLng(X), CLng(Y), 0)
        
        If (Flags And VBPaintFlags.ColorSpecified) = 0 Then
            Color = Me.ForeColor
        End If
        
        Dim pen As LongPtr = CreateOurPen(Color)
        Dim origPen As LongPtr = SelectObject(hdc, pen)

        SetDrawingMixMode()
        GDI32_LineTo(hdc, CLng(X), CLng(Y + 1))

        SelectObject(hdc, origPen)
        DeleteObject(pen)
        
        HandleAutoRedrawInvalidation()
    End Sub
    
    Public Sub Scale(ByVal Flags As VBPaintFlags, _
                        ByVal X1 As Single, _
                        ByVal Y1 As Single, _
                        ByVal X2 As Single, _
                        ByVal Y2 As Single)
        If Flags = 0 Then
        	Me.ScaleMode = ScaleModeConstants.vbTwips
        Else
            Me.ScaleLeft = X1
            Me.ScaleTop = Y1
            Me.ScaleWidth = X2 - X1
            Me.ScaleHeight = Y2 - Y1
            ScaleMode = ScaleModeConstants.vbUser
        End If
        SyncScaleMode()
    End Sub
    
    Friend Function InitBaseGraphicsInfo() As LongPtr
        BaseGraphicsInfo.ScaleLeft = ScaleLeftINIT
        BaseGraphicsInfo.ScaleTop = ScaleTopINIT
        BaseGraphicsInfo.ScaleWidth = ScaleWidthINIT
        BaseGraphicsInfo.ScaleHeight = ScaleHeightINIT
        Return VarPtr(BaseGraphicsInfo)
    End Function
    
    Friend Sub InitGraphics(RootWindowElement As WindowsControls.WindowElement)
        Set Me.RootWindowElementBASE = RootWindowElement
    End Sub
    
    Friend Sub InternalStateResetGraphics()
        Set BaseGraphicsInfo.Owner = Nothing
        [_HiddenModule].MemZero(VarPtr(BaseGraphicsInfo), Len(Of BaseGraphicsInfo))
    End Sub
        
    Friend Sub ChangeHDC(hdc As LongPtr, hwnd As LongPtr, RootWindowElement As WindowsControls.WindowElement, Picture As StdPicture, Owner As Object, ByVal IsForm As Boolean)
        If RootWindowElement Is Nothing Then
            FontNameINIT = "Arial"      ' default printer font
            ForeColor = vbBlack
            FontTransparent = True
        End If
        If hdc = 0 Then hdc = GetDC(hwnd)
        Me.BaseGraphicsInfo.WindowHDC = hdc
        Me.hDC = hdc
        Set Me.RootWindowElementBASE = RootWindowElement
        Me.BaseGraphicsInfo.WindowHandle = hwnd
        Set Me.BaseGraphicsInfo.Owner = Owner
        Set Me.InternalPicture = Picture
        Me.BaseGraphicsInfo.IsForm = IsForm
        Me.BaseGraphicsInfo.IsReport = TypeOf Owner Is Report
        Me.BaseGraphicsInfo.IsUserControl = TypeOf Owner Is UserControl
        Me.BaseGraphicsInfo.IsPropertyPage = TypeOf Owner Is PropertyPage
        
        Me.DrawStyleChanged
        Me.BaseGraphicsInfo.MuteResizeEvent = True
            Me.HandleResize
        Me.BaseGraphicsInfo.MuteResizeEvent = False
       	Me.FillStyleChanged
        If Me.AutoRedraw = True Then
            Cls()
        Else
        	InternalSyncFontProperties(True)
        End If
    End Sub
    
    Private Sub IVBPrint_WriteText(ByVal Value As String) Implements IVBPrint.WriteText
        Dim tabSize As Long = 8 * BaseGraphicsInfo.CachedFontAvgCharWidth    ' tabs are expanded to eight times the average character width
                
        ' If Me.FontTransparent = True Then
        ' 	WinNativeFormsBASE.GDI32_SetBackMode(Me.hDC, WinNativeFormsBASE.BackgroundModes.TRANSPARENT)
        ' Else
        '     WinNativeFormsBASE.GDI32_SetBackColor(Me.hDC, TranslateColor(Me.BackColor))
        ' 	WinNativeFormsBASE.GDI32_SetBackMode(Me.hDC, WinNativeFormsBASE.BackgroundModes.OPAQUE)
        ' End If
                
        'WinNativeFormsBASE.GDI32_SetTextForeColor(Me.hDC, TranslateColor(Me.ForeColor))
                
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        Dim hdc As Any = Me.hDC
        
        Dim xOffset As Long = CLng(ScaleXToScaledPixels(-Me.ScaleLeft * UnitPixelScale))
        Dim yOffset As Long = CLng(ScaleYToScaledPixels(-Me.ScaleTop * UnitPixelScale))
                
        ' Split into lines, and pass to TabbedTextOut        
        Dim startPos As Long = 1
        Dim currentLine As String
        Do
            Dim nextLineFeed As Long = InStr$(startPos, Value, vbCrLf, VbCompareMethod.vbBinaryCompare)  ' FIXME need to support vbCr and vbLf here too
            If nextLineFeed <> 0 Then
                currentLine = Mid$(Value, startPos, nextLineFeed - startPos)
                startPos = nextLineFeed + 2
            Else
                currentLine = Mid$(Value, startPos)
            End If
            ' FIXME could change this like TabbedTextExtent now...
            Dim outSize As Long = TabbedTextOutW(hdc, xOffset + CLng(Me.InternalCurrentX), yOffset + CLng(Me.InternalCurrentY), currentLine, Len(currentLine), 1, tabSize, 0)
            Me.InternalCurrentX += outSize And &HFFFF&
            If nextLineFeed <> 0 Then
                Me.InternalCurrentY += BaseGraphicsInfo.CachedFontCharHeight
                Me.InternalCurrentX = 0
            End If
        Loop Until nextLineFeed = 0
    
        'Value = Replace(Value, vbCrLf, "\r\n")
        'Value = Replace(Value, vbCr, "\r")
        'Value = Replace(Value, vbLf, "\r")
        'Log += CurrentProcedureName & "(""" & Value & """) "
        
        HandleAutoRedrawInvalidation()
    End Sub
    
    Private Property Let IVBPrint_Column(ByVal Value As Long) Implements IVBPrint.Column
        ' Column takes into account of the AVERAGE font character width
        'Log += CurrentProcedureName & "(""" & Value & """) "
        Me.InternalCurrentX = Value * BaseGraphicsInfo.CachedFontAvgCharWidth
    End Property
    
    Private Property Get IVBPrint_Column() As Long Implements IVBPrint.Column
        'Log += CurrentProcedureName & "() "
        Dim retVal As Long = Me.InternalCurrentX \ Me.BaseGraphicsInfo.CachedFontAvgCharWidth
        If (retVal * Me.BaseGraphicsInfo.CachedFontAvgCharWidth) <> Me.InternalCurrentX Then retVal += 1  ' round up
        Return retVal
    End Property
    
    ' ------------------------------------------------------------------------------------------------------
    
    [Serialize(False)]
    Public WithEvents Font As StdFont
    
    [Serialize(True, "FontBold")]
    Private FontBoldINIT As Boolean = False
    [Serialize(True, "FontItalic")]
    Private FontItalicINIT As Boolean = False
    [Serialize(True, "FontName")]
    Private FontNameINIT As String = "Segoe UI"
    [Serialize(True, "FontSize")]
    Private FontSizeINIT As Single = 8
    [Serialize(True, "FontStrikethru")]
    Private FontStrikethruINIT As Boolean = False
    [Serialize(True, "FontUnderline")]
    Private FontUnderlineINIT As Boolean = False
    
    [Serialize(False)]
    Public Property Get FontBold() As Boolean
        Return Me.Font.Bold
    End Property
    [Serialize(False)]
    Public Property Let FontBold(ByVal Value As Boolean)
        Me.Font.Bold = Value
    End Property
    
    [Serialize(False)]
    Public Property Get FontItalic() As Boolean
        Return Me.Font.Italic
    End Property
    [Serialize(False)]
    Public Property Let FontItalic(ByVal Value As Boolean)
        Me.Font.Italic = Value
    End Property
    
    [Serialize(False)]
    Public Property Get FontName() As String
        Return Me.Font.Name
    End Property
    [Serialize(False)]
    Public Property Let FontName(ByVal Value As String)
        Me.Font.Name = Value
    End Property
    
    [Serialize(False)]
    Public Property Get FontSize() As Single
        Return CSng(Me.Font.Size)
    End Property
    [Serialize(False)]
    Public Property Let FontSize(ByVal Value As Single)
        Me.Font.Size = Value
    End Property
    
    [Serialize(False)]
    Public Property Get FontStrikethru() As Boolean
        Return Me.Font.Strikethrough
    End Property
    [Serialize(False)]
    Public Property Let FontStrikethru(ByVal Value As Boolean)
        Me.Font.Strikethrough = Value
    End Property
    
    [Serialize(False)]
    Public Property Get FontUnderline() As Boolean
        Return Me.Font.Underline
    End Property
    [Serialize(False)]
    Public Property Let FontUnderline(ByVal Value As Boolean)
        Me.Font.Underline = Value
    End Property
        
    Private Sub HandleDPIChange() _
            Handles RootWindowElementBASE.DPIChange
        
        InternalSyncFontProperties(False)
    End Sub
    
    Friend Property Get RealHDC() As LongPtr
    	Return Me.BaseGraphicsInfo.WindowHDC
    End Property
    
    [Serialize(False)]
    Public Property Get CurrentX() As Double
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
    	Return ScaleXFromScaledPixels(InternalCurrentX / UnitPixelScale)
    End Property
    
    [Serialize(False)]
    Public Property Let CurrentX(Value As Double)
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        InternalCurrentX = ScaleXToScaledPixels(Value * UnitPixelScale)
    End Property

    [Serialize(False)]
    Public Property Get CurrentY() As Double
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        Return ScaleYFromScaledPixels(InternalCurrentY / UnitPixelScale)
    End Property
    
    [Serialize(False)]
    Public Property Let CurrentY(Value As Double)
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
    	InternalCurrentY = ScaleYToScaledPixels(Value * UnitPixelScale)
    End Property
     
    Friend Sub InternalSyncFont(ByVal MuteFontEvents As Boolean)
        
        'Dim oldFontHandle As LongPtr = Me.CurrentFontHandle
        
        Dim font As Any = CType(Of IFont)(Me.Font)
        If font Is Nothing Then Exit Sub
        
        Dim hdc As Any = Me.hDC
        
        ' InternalIgnoreFontChange = True
        '     Me.FontName = font.Name
        '     Me.FontBold = font.Bold
        '     Me.FontItalic = font.Italic
        '     Me.FontSize = font.Size
        '     Me.FontStrikethru = font.Strikethrough
        '     Me.FontUnderline = font.Underline
        ' InternalIgnoreFontChange = False
        
        ' First make sure the font scaling matches the window DPI
        Dim RootWindowElementBASE As Any = Me.RootWindowElementBASE
        If RootWindowElementBASE Is Nothing Then
            ' Printer 
            Const LOGPIXELSX As Long = &H58
            Dim dpiX As Long = WinNativeFormsBASE.GetDeviceCaps(hdc, LOGPIXELSX)
            font.SetRatio(dpiX, 2540)
        Else
            font.SetRatio(RootWindowElementBASE.DPI, 2540)
        End If
        
        Dim LF As WinNativeFormsBASE.LOGFONT
        GetObjectW(font.hFont, LenB(LF), LF)
        LF.LFQuality = CByte(WinNativeFormsBASE.CLEARTYPE_QUALITY)
        Dim newFont As LongPtr = CreateFontIndirectW(LF)            ' FIXME leak
        
        'Debug.Print "InternalSyncFont"
        
        If BaseGraphicsInfo.CurrentGraphicsFontHandle <> 0 Then
            SelectObject(BaseGraphicsInfo.CurrentGraphicsFontDC, BaseGraphicsInfo.CurrentGraphicsFontHandleOLD)
            WinNativeFormsBASE.WindowsAPI.GDI32_DeleteObject(BaseGraphicsInfo.CurrentGraphicsFontHandle)
        End If
        BaseGraphicsInfo.CurrentGraphicsFontHandle = newFont
        BaseGraphicsInfo.CurrentGraphicsFontDC = hdc
        BaseGraphicsInfo.CurrentGraphicsFontHandleOLD = SelectObject(hdc, newFont)
        
        
        'Me.CurrentFontHandle = WindowsAPI.USER32_SetFont(Me.RootWindowElement, Me.Font)
        'If oldFont <> 0 Then WinNativeFormsBASE.WindowsAPI.GDI32_DeleteObject oldFont

        ' Also sync colors here so that things like DrawText API work as expected
        ' FIXME not sure if this is needed now, as we do this as part of Paint()
        If Me.FontTransparent = True Then
        	WinNativeFormsBASE.GDI32_SetBackMode(hdc, WinNativeFormsBASE.BackgroundModes.TRANSPARENT)
        Else
            WinNativeFormsBASE.GDI32_SetBackColor(hdc, TranslateColor(Me.BackColor))
        	WinNativeFormsBASE.GDI32_SetBackMode(hdc, WinNativeFormsBASE.BackgroundModes.OPAQUE)
        End If
                
        WinNativeFormsBASE.GDI32_SetTextForeColor(hdc, TranslateColor(Me.ForeColor))
        
        If (MuteFontEvents = False) And (Me.BaseGraphicsInfo.IsUserControl Or Me.BaseGraphicsInfo.IsForm) Then
            NotifyActiveXAmbientPropertyChanges(DISPID_AMBIENT_FONT)
        End If
        
        UpdateCachedFontMetrics()
    End Sub
    
    Private Sub SyncFont() _
           Handles Font.OnPropertySet
           
        InternalSyncFont(False)
    End Sub

    Private Sub InitializeOLEFont()
'        Debug.Print "InitializeOLEFont"
        Dim NewFont As Any = New StdFont
        With NewFont
            .Bold = Me.FontBoldINIT
            .Italic = Me.FontItalicINIT
            .Name = Me.FontNameINIT
            .Size = Me.FontSizeINIT
            .Strikethrough = Me.FontStrikethruINIT
            .Underline = Me.FontUnderlineINIT
        End With
        CommonInitFontRatio(NewFont, Me.RootWindowElementBASE)
        Set Me.Font = NewFont
    End Sub
    
    Friend Function GetFontMetrics() As TEXTMETRICW
        If Me.Font Is Nothing Then
            InitializeOLEFont
        End If
        
        CommonGetFontMetrics(CType(Of IFont)(Me.Font), Me.RootWindowElementBASE, GetFontMetrics)
    End Function
    
    Friend Sub InternalSyncFontProperties(ByVal MuteFontEvents As Boolean)
            
        If BaseGraphicsInfo.InternalIgnoreFontChange Then Exit Sub
        
        If Me.Font Is Nothing Then
            InitializeOLEFont
        End If
        InternalSyncFont(MuteFontEvents)
        UpdateCachedFontMetrics()

        'Refresh()
    End Sub
    
    Private Sub UpdateCachedFontMetrics()
    	 Dim metrics As TEXTMETRICW
         Dim hdc As LongPtr = Me.hDC
        GetTextMetricsW(hdc, metrics)
        Me.BaseGraphicsInfo.CachedFontAvgCharWidth = metrics.tmAveCharWidth
        Me.BaseGraphicsInfo.CachedFontCharHeight = metrics.tmHeight
    End Sub
    
    Friend Sub SyncFontProperties()
        InternalSyncFontProperties(False)
    End Sub
    
    Public Function TextWidth(str As String) As Double

        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        Dim hdc As LongPtr = Me.hDC
        
        Dim tabSize As Long = 8 * BaseGraphicsInfo.CachedFontAvgCharWidth    ' tabs are expanded to eight times the average character width
        Dim maxWidth As Long = 0
        
        ' quick fix for supporting vbCr/vbLf/vbCrLf
        Dim strCopy As String = Replace(str, vbCrLf, vbCr)
        strCopy = Replace(strCopy, vbLf, vbCr)
                
        Dim startPos As Long = 1
        Dim currentLine As String
        Do
            'Dim nextLineFeed As Long = InStr$(startPos, str, vbCrLf, VbCompareMethod.vbBinaryCompare)  ' a better fix would be to use custom InStr here, supporting vbCrLf/vbCr/vbLf 
            Dim nextLineFeed As Long = InStr$(startPos, strCopy, vbCr, VbCompareMethod.vbBinaryCompare)
                        
            Dim numCharsOnThisLine As Long
            If nextLineFeed = 0 Then
                numCharsOnThisLine = Len(strCopy) - (startPos - 1)
            Else
                numCharsOnThisLine = nextLineFeed - startPos
            End If

            Dim outSize As Long = GetTabbedTextExtentW(hdc, StrPtr(strCopy) + ((startPos - 1) * 2), numCharsOnThisLine, 1, tabSize)
            startPos = nextLineFeed + 1
            Dim lineWidth As Long = outSize And &HFFFF&
            If lineWidth > maxWidth Then maxWidth = lineWidth
        Loop Until nextLineFeed = 0
         
        Return ScaleXFromScaledPixels(maxWidth / UnitPixelScale)
    End Function
    
    Public Function TextHeight(str As String) As Double
        
        Dim UnitPixelScale As Double
        If RootWindowElementBASE IsNot Nothing Then
            UnitPixelScale = RootWindowElementBASE.UnitPixelScale
        Else
            UnitPixelScale = 1
        End If
        
        ' quick fix for supporting vbCr/vbLf/vbCrLf
        Dim strCopy As String = Replace(str, vbCrLf, vbCr)
        strCopy = Replace(strCopy, vbLf, vbCr)
        
        Dim startPos As Long = 1
        Dim numLineFeeds As Long
        Do
            'Dim nextLineFeed As Long = InStr$(startPos, strCopy, vbCrLf, VbCompareMethod.vbBinaryCompare)  ' a better fix would be to use custom InStr here, supporting vbCrLf/vbCr/vbLf 
            Dim nextLineFeed As Long = InStr$(startPos, strCopy, vbCr, VbCompareMethod.vbBinaryCompare)
                        
            If nextLineFeed = 0 Then
            Else
                startPos = nextLineFeed + 1
            End If
            numLineFeeds += 1
        Loop Until nextLineFeed = 0
         
        Return ScaleYFromScaledPixels((numLineFeeds * BaseGraphicsInfo.CachedFontCharHeight) / UnitPixelScale)
    End Function
    
    Private Sub ScaleModeChanged() _   
            Handles ScaleMode.OnPropertyLet
        
        ' FIXME check if actually changed
        If RootWindowElementBASE Is Nothing Then Exit Sub
        
        SyncScaleMode()
        
        NotifyActiveXAmbientPropertyChanges(DISPID_AMBIENT_SCALEUNITS)
    End Sub
    
    Friend Sub SyncScaleMode(Optional ByVal Owner As Object, Optional ByVal RootWindowElement As WindowsControls.WindowElement)
           
        If Me.RootWindowElementBASE Is Nothing Then Exit Sub
        
        Dim scaleMode As Any = Me.ScaleMode
        If (scaleMode < ScaleModeConstants.vbUser) Or (scaleMode > ScaleModeConstants.vbHimetric) Then
            scaleMode = ScaleModeConstants.vbScaledPixels
            Me.ScaleMode = ScaleModeConstants.vbScaledPixels
        End If
        
        If Owner Is Nothing Then Set Owner = Me.BaseGraphicsInfo.Owner
        If RootWindowElement Is Nothing Then Set RootWindowElement = Me.RootWindowElementBASE

        'If Owner Is Nothing Then Stop
        'If RootWindowElement Is Nothing Then Stop

        'Debug.Print "SyncScaleMode Owner.PixelsWidth: ", Owner.PixelsWidth

        With CType(Of WinNativeFormsBASE.BaseControlRect)(Owner)
            Dim OwnerPixelsWidth As Any = .PixelsWidth
            Dim OwnerPixelsHeight As Any = .PixelsHeight
        End With
        
        If scaleMode <> ScaleModeConstants.vbUser Then
            ' ' We have to sync the ScaleWidth/Height, using the PixelsWidth/Height as authoratitive
            Dim tempX As Double = RootWindowElement.ScaleX(CDbl(OwnerPixelsWidth), ScaleModeConstants.vbScaledPixels, ScaleModeConstants.vbPixels)
            Dim tempY As Double = RootWindowElement.ScaleY(CDbl(OwnerPixelsHeight), ScaleModeConstants.vbScaledPixels, ScaleModeConstants.vbPixels)
            AdjustRemoveBorderPixels(Owner, tempX)
            AdjustRemoveBorderPixels(Owner, tempY)
            Dim newWidth As Double = ScaleXFromPixels(tempX)
            'If Me.ScaleWidth <> newWidth Then
            '	Debug.Print "SyncScaleMode **** CHANGE PixelsWidth: ", Owner.PixelsWidth, ", ScaleWidth: ", newWidth
            'End If
            BaseGraphicsInfo.ScaleWidth = newWidth
            BaseGraphicsInfo.ScaleHeight = ScaleYFromPixels(tempY)
            BaseGraphicsInfo.ScaleLeft = 0
            BaseGraphicsInfo.ScaleTop = 0
            
            'Stop
            ' Dim newRect As WinNativeFormsBASE.RECT
            ' Dim hwnd As Any = Me.RootWindowElementBASE.Handle 'Me.BaseGraphicsInfo.WindowHandle
            ' GetClientRect(hwnd, newRect)
            ' BaseGraphicsInfo.ScaleWidth = ScaleXFromPixels(newRect.Right - newRect.Left)
            ' BaseGraphicsInfo.ScaleHeight = ScaleYFromPixels(newRect.Bottom - newRect.Top)
            ' BaseGraphicsInfo.ScaleLeft = 0
            ' BaseGraphicsInfo.ScaleTop = 0
            'Debug.Print Owner.Name, "ScaleWidth: " & BaseGraphicsInfo.ScaleWidth, "ScaleHeight: " & BaseGraphicsInfo.ScaleHeight
            
            ScaleWidthINIT = BaseGraphicsInfo.ScaleWidth
            ScaleHeightINIT = BaseGraphicsInfo.ScaleHeight
            ScaleLeftINIT = 0
            ScaleTopINIT = 0
        End If
        
        If Me.BaseGraphicsInfo.InternalScaleFactorX = 0 Then
        	If OwnerPixelsWidth <> 0 Then
                Me.BaseGraphicsInfo.InternalScaleFactorX = CDbl(BaseGraphicsInfo.ScaleWidth) / CDbl(OwnerPixelsWidth)
                Me.BaseGraphicsInfo.InternalScaleFactorX_OriginalPixelsWidth = CLng(OwnerPixelsWidth)
            Else
                Me.BaseGraphicsInfo.InternalScaleFactorX = BaseGraphicsInfo.ScaleWidth
                Me.BaseGraphicsInfo.InternalScaleFactorX_OriginalPixelsWidth = 1
            End If
        End If
        
        If Me.BaseGraphicsInfo.InternalScaleFactorY = 0 Then
            If OwnerPixelsHeight <> 0 Then
                Me.BaseGraphicsInfo.InternalScaleFactorY = CDbl(BaseGraphicsInfo.ScaleHeight) / CDbl(OwnerPixelsHeight)
                Me.BaseGraphicsInfo.InternalScaleFactorY_OriginalPixelsHeight = CLng(OwnerPixelsHeight)
            Else
                Me.BaseGraphicsInfo.InternalScaleFactorY = BaseGraphicsInfo.ScaleHeight
                Me.BaseGraphicsInfo.InternalScaleFactorY_OriginalPixelsHeight = 1
            End If
        End If

'        Debug.Print "ChangeChildScaleMode", Owner.PixelsWidth / Me.ScaleWidth, Owner.PixelsHeight / Me.ScaleHeight
        RootWindowElement.ChangeChildScaleMode(scaleMode, Me.BaseGraphicsInfo.InternalScaleFactorX, Me.BaseGraphicsInfo.InternalScaleFactorY, Me.ScaleLeft, Me.ScaleTop)
    End Sub
    
    [Serialize(False)]
    Public Property Get ScaleTop() As Double
        Return BaseGraphicsInfo.ScaleTop
    End Property
    [Serialize(False)]
    Public Property Let ScaleTop(ByVal Value As Double)
        BaseGraphicsInfo.ScaleTop = Value
        If RootWindowElementBASE Is Nothing Then Exit Property
                
        Dim changeAmount As Long = CLng(BaseGraphicsInfo.InternalCachedScaleTop - ScaleTop)
        InternalCurrentY -= ScaleYToScaledPixels(changeAmount * RootWindowElementBASE.UnitPixelScale)
        BaseGraphicsInfo.InternalCachedScaleTop = ScaleTop
        ScaleMode = ScaleModeConstants.vbUser
        SyncScaleMode()
    End Property
    
    [Serialize(False)]
    Public Property Get ScaleLeft() As Double
        Return BaseGraphicsInfo.ScaleLeft
    End Property
    [Serialize(False)]
    Public Property Let ScaleLeft(ByVal Value As Double)
        BaseGraphicsInfo.ScaleLeft = Value
        If RootWindowElementBASE Is Nothing Then Exit Property
            
        Dim changeAmount As Long = CLng(BaseGraphicsInfo.InternalCachedScaleLeft - ScaleLeft)
        InternalCurrentX -= ScaleXToScaledPixels(changeAmount * RootWindowElementBASE.UnitPixelScale)
        BaseGraphicsInfo.InternalCachedScaleLeft = ScaleLeft
        ScaleMode = ScaleModeConstants.vbUser
        SyncScaleMode()
    End Property
    
    [Serialize(False)]
    Public Property Get ScaleWidth() As Double
        Return BaseGraphicsInfo.ScaleWidth
    End Property
    [Serialize(False)]
    Public Property Let ScaleWidth(ByVal Value As Double)
        BaseGraphicsInfo.ScaleWidth = Value
        
        ScaleMode = ScaleModeConstants.vbUser
        Me.BaseGraphicsInfo.InternalScaleFactorX = 0     ' This will be recalculated
        SyncScaleMode()
    End Property
    
    [Serialize(False)]
    Public Property Get ScaleHeight() As Double
        Return BaseGraphicsInfo.ScaleHeight
    End Property
    [Serialize(False)]
    Public Property Let ScaleHeight(ByVal Value As Double)
        BaseGraphicsInfo.ScaleHeight = Value
        
        ScaleMode = ScaleModeConstants.vbUser
        Me.BaseGraphicsInfo.InternalScaleFactorY = 0     ' This will be recalculated
        SyncScaleMode()
    End Property
    
    Public Function ScaleX(ByVal Width As Single, [TypeHint(ScaleModeConstants)] Optional ByVal FromScale As Variant, [TypeHint(ScaleModeConstants)] Optional ByVal ToScale As Variant) As Single
        If IsMissing(FromScale) Then FromScale = ScaleModeConstants.vbHimetric
        If IsMissing(ToScale) Then ToScale = Me.ScaleMode

        Dim RootWindowElementBASE As Any = Me.RootWindowElementBASE
        If IsUserControl Then
        	Dim fromContainerCoords As Boolean = (FromScale = ScaleModeConstants.vbContainerSize) Or (FromScale = ScaleModeConstants.vbContainerPosition)
        	Dim toContainerCoords As Boolean = (ToScale = ScaleModeConstants.vbContainerSize) Or (ToScale = ScaleModeConstants.vbContainerPosition)
            If fromContainerCoords And toContainerCoords Then
            	Return Width
            ElseIf fromContainerCoords Then
                Width = CSng(CType(Of TbUserControlPrivate)(Me.BaseGraphicsInfo.Owner).TranslateContainerXToHimetric(Width))
                FromScale = ScaleModeConstants.vbHimetric
            ElseIf toContainerCoords Then
                Width = CSng(RootWindowElementBASE.ScaleX(Width, CLng(FromScale), ScaleModeConstants.vbHimetric))
                Return CSng(CType(Of TbUserControlPrivate)(Me.BaseGraphicsInfo.Owner).TranslateHimetricToContainerX(CLng(Width)))
            End If
        End If
        
        Return CSng(RootWindowElementBASE.ScaleX(Width, CLng(FromScale), CLng(ToScale)))
    End Function

    Public Function ScaleY(ByVal Height As Single, [TypeHint(ScaleModeConstants)] Optional ByVal FromScale As Variant, [TypeHint(ScaleModeConstants)] Optional ByVal ToScale As Variant) As Single
        If IsMissing(FromScale) Then FromScale = ScaleModeConstants.vbHimetric
        If IsMissing(ToScale) Then ToScale = Me.ScaleMode
        
        Dim RootWindowElementBASE As Any = Me.RootWindowElementBASE
        If IsUserControl Then
        	Dim fromContainerCoords As Boolean = (FromScale = ScaleModeConstants.vbContainerSize) Or (FromScale = ScaleModeConstants.vbContainerPosition)
        	Dim toContainerCoords As Boolean = (ToScale = ScaleModeConstants.vbContainerSize) Or (ToScale = ScaleModeConstants.vbContainerPosition)
            If fromContainerCoords And toContainerCoords Then
            	Return Height
            ElseIf fromContainerCoords Then
                Height = CSng(CType(Of TbUserControlPrivate)(Me.BaseGraphicsInfo.Owner).TranslateContainerYToHimetric(Height))
                FromScale = ScaleModeConstants.vbHimetric
            ElseIf toContainerCoords Then
                Height = CSng(RootWindowElementBASE.ScaleX(Height, CLng(FromScale), ScaleModeConstants.vbHimetric))
                Return CSng(CType(Of TbUserControlPrivate)(Me.BaseGraphicsInfo.Owner).TranslateHimetricToContainerY(CLng(Height)))
            End If
        End If
        
        Return CSng(RootWindowElementBASE.ScaleY(Height, CLng(FromScale), CLng(ToScale)))
    End Function
    
    Private Sub ClearCachedFont()
    	Dim CurrentGraphicsFontHandle As Any = Me.BaseGraphicsInfo.CurrentGraphicsFontHandle
        If CurrentGraphicsFontHandle <> 0 Then
            SelectObject(BaseGraphicsInfo.CurrentGraphicsFontDC, BaseGraphicsInfo.CurrentGraphicsFontHandleOLD)
            WinNativeFormsBASE.WindowsAPI.GDI32_DeleteObject(CurrentGraphicsFontHandle)
            Me.BaseGraphicsInfo.CurrentGraphicsFontHandle = 0
        End If
    End Sub
    
    Private Sub Class_Terminate()
    	Dim InternalCurrentBrush As Any = Me.InternalCurrentBrush
        If InternalCurrentBrush <> 0 Then DeleteObject(InternalCurrentBrush)
        ClearCachedFont()
        RemoveBuffer()
        
        'WinNativeFormsBASE.ReleaseDC(WindowHandle, hDC)
        'Debug.Print "Graphics.Class_Terminate"
    End Sub
    
    Private Sub Font_FontChanged(ByVal PropertyName As String) _
            Handles Font.FontChanged
            
        InternalSyncFont(False)
    End Sub
        
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalCreateBitmap Lib "gdi32" Alias "CreateBitmap" (ByVal nWidth As Long, ByVal nHeight As Long, ByVal nPlanes As Long, ByVal nBitCount As Long, ByVal lpBits As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalSetViewportOrgEx Lib "gdi32" Alias "SetViewportOrgEx" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As WinNativeFormsBASE.POINT) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function SetBrushOrgEx Lib "gdi32" (ByVal hDC As LongPtr, ByVal nXOrg As Long, ByVal nYOrg As Long, ByVal lppt As LongPtr) As Long
    
    Enum vbStretchQuality
        vbQualityNormal = 0
        vbQualityHalftone = 1
    End Enum
    
    [Serialize(False)]
    Friend InternalPrinterUserScaleWidthX As Double = 1
    [Serialize(False)]
    Friend InternalPrinterUserScaleWidthY As Double = 1
    
    Friend Sub InternalGetPrinterScalesFromScaleMode(ByVal ScaleMode As ScaleModeConstants, ByRef inputUnitsScaleX As Double, ByRef inputUnitsScaleY As Double, ByVal outputResolutionScaleX As Double, ByVal outputResolutionScaleY As Double)
        Select Case ScaleMode
            Case vbTwips
                inputUnitsScaleX = 1
                inputUnitsScaleY = 1
            Case vbPoints
                inputUnitsScaleX = 72 / 1440
                inputUnitsScaleY = 72 / 1440
            Case vbPixels
                inputUnitsScaleX = outputResolutionScaleX
                inputUnitsScaleY = outputResolutionScaleY
            Case vbCharacters
                inputUnitsScaleX = 1 / 120
                inputUnitsScaleY = 1 / 240
            Case vbInches
                inputUnitsScaleX = 1 / 1440
                inputUnitsScaleY = 1 / 1440
            Case vbMillimeters
                inputUnitsScaleX = 25.40 / 1440
                inputUnitsScaleY = 25.40 / 1440
            Case vbCentimeters
                inputUnitsScaleX = 2.54 / 1440
                inputUnitsScaleY = 2.54 / 1440
            Case vbHimetric
                ' VB6 doesn't allow this for printers
                inputUnitsScaleX = 2540 / 1440
                inputUnitsScaleY = 2540 / 1440
            Case vbUser
                inputUnitsScaleX = InternalPrinterUserScaleWidthX
                inputUnitsScaleY = InternalPrinterUserScaleWidthY
            Case Else
                Err.Raise 5
        End Select
    End Sub
    
    Friend Sub InternalGetXYScales(ByRef inputUnitsScaleX As Double, ByRef inputUnitsScaleY As Double, ByRef outputResolutionScaleX As Double, ByRef outputResolutionScaleY As Double)
        Const LOGPIXELSX As Long = &H58
        outputResolutionScaleX = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSX) / 1440
        Const LOGPIXELSY As Long = &H5A
        outputResolutionScaleY = WinNativeFormsBASE.GetDeviceCaps(hDC, LOGPIXELSY) / 1440
            
        If RootWindowElementBASE IsNot Nothing Then
            ' get scales from the window element
            inputUnitsScaleX = RootWindowElementBASE.ScaleX(1, ScaleModeConstants.vbTwips, Me.ScaleMode)
            inputUnitsScaleY = RootWindowElementBASE.ScaleY(1, ScaleModeConstants.vbTwips, Me.ScaleMode)
        Else
            ' use printer scales
            InternalGetPrinterScalesFromScaleMode(ScaleMode, inputUnitsScaleX, inputUnitsScaleY, outputResolutionScaleX, outputResolutionScaleY)
        End If
    End Sub
    
    Public Sub PaintPicture(ByVal Picture As IPictureDisp, ByVal X1 As Single, ByVal Y1 As Single, Optional ByVal Width1 As Variant, Optional ByVal Height1 As Variant, Optional ByVal X2 As Variant, Optional ByVal Y2 As Variant, Optional ByVal Width2 As Variant, Optional ByVal Height2 As Variant, Optional ByVal Opcode As Variant, Optional ByVal StretchQuality As vbStretchQuality = vbQualityNormal)
        If Picture Is Nothing Then
            Err.Raise 91
        End If
        
        Dim FlipX As Boolean
        Dim FlipY As Boolean
        Dim xDest As Long
        Dim yDest As Long
        Dim wDest As Long
        Dim hDest As Long
        Dim srcHDC As LongPtr
        Dim xSrc As Long
        Dim ySrc As Long
        Dim wSrc As Long
        Dim hSrc As Long
        
        Dim IsMissing_OpCode As Boolean = IsMissing(Opcode)
        Dim IsMissing_Width1 As Boolean = IsMissing(Width1)
        Dim IsMissing_Height1 As Boolean = IsMissing(Height1)
        Dim IsMissing_Width2  As Boolean = IsMissing(Width2)
        Dim IsMissing_Height2 As Boolean = IsMissing(Height2)
        
        Const generalTwipsScale As Double = 15
        Const DIB_RGB_COLORS As Long = 0
        
        Dim inputUnitsScaleX As Double
        Dim inputUnitsScaleY As Double
        Dim outputResolutionScaleX As Double
        Dim outputResolutionScaleY As Double
        
        InternalGetXYScales(inputUnitsScaleX, inputUnitsScaleY, outputResolutionScaleX, outputResolutionScaleY)
                    
        If IsMissing(X2) Then
            xSrc = 0
        Else
            xSrc = CLng(X2 / inputUnitsScaleX) \ generalTwipsScale
        End If
        If IsMissing(Y2) Then
            ySrc = 0
        Else
            ySrc = CLng(Y2 / inputUnitsScaleY) \ generalTwipsScale
        End If
                    
        xDest = CLng(X1 / inputUnitsScaleX * outputResolutionScaleX)
        yDest = CLng(Y1 / inputUnitsScaleY * outputResolutionScaleY)
        
        If IsMissing_Width1 = False Then
            wDest = CLng(Width1 / inputUnitsScaleX * outputResolutionScaleX)
        End If
        If IsMissing_Height1 = False Then
            hDest = CLng(Height1 / inputUnitsScaleY * outputResolutionScaleY)
        End If
        
        Dim pictureType As Any = Picture.Type
        Dim pictureWidth As Any = Picture.Width
        Dim pictureHeight As Any = Picture.Height
        
        Dim picWidthPixels As Long
        Dim picHeightPixels As Long
        VB.ScaleOLEPictureDimensionsToPixels(vbPicTypeNone, CLng(pictureWidth), picWidthPixels, CLng(pictureHeight), picHeightPixels)
        
        If pictureType = PictureTypeConstants.vbPicTypeBitmap Then
    
            If IsMissing_OpCode Then
                Opcode = RasterOpConstants.vbSrcCopy
            End If
                            
            Dim tempDC As LongPtr = WinNativeFormsBASE.GetDC(0)
            srcHDC = WinNativeFormsBASE.CreateCompatibleDC(tempDC)
            
            Dim oldBitmap As LongPtr = WinNativeFormsBASE.SelectObject(srcHDC, Picture.Handle)
            If IsMissing_Width1 Then
                wDest = picWidthPixels
                
                wDest = CLng(wDest * generalTwipsScale)
                wDest = CLng(wDest * outputResolutionScaleX)
            End If
            If IsMissing_Height1 Then
                hDest = picHeightPixels
                
                hDest = CLng(hDest * generalTwipsScale)
                hDest = CLng(hDest * outputResolutionScaleY)
            End If
            If IsMissing_Width2 Then
                wSrc = picWidthPixels - xSrc
                
                If IsMissing_Width1 Then
                    wDest = CLng(wDest * wSrc / picWidthPixels)
                End If
            Else
                wSrc = CLng(Width2 / inputUnitsScaleX \ generalTwipsScale)
                If IsMissing_Width1 Then
                    wDest = CLng(wDest * wSrc / picWidthPixels)
                End If
                If wDest < 0 Then
                    ' If Abs(wSrc) > picWidthPixels Then
                    '     xDest += CLng(Abs(wDest) - wSrc)
                    ' End If
                    If wSrc <> 0 Then xDest += CLng(-wDest - ((((picWidthPixels - xSrc) * (-wDest / wSrc)))))
                End If
            End If
            If IsMissing_Height2 Then
                hSrc = picHeightPixels - ySrc
                
                If IsMissing_Height1 Then
                    hDest = CLng(hDest * hSrc / picHeightPixels)
                End If
            Else
                hSrc = CLng(Height2 / inputUnitsScaleY \ generalTwipsScale)
                If IsMissing_Height1 Then
                    hDest = CLng(hDest * hSrc / picHeightPixels)
                End If
                If hDest < 0 Then
                    ' If Abs(hSrc) > picHeightPixels Then
                    ' 	yDest += CLng(Abs(hDest) - hSrc)
                    ' Else                           
                        If hSrc <> 0 Then yDest += CLng(-hDest - ((((picHeightPixels - ySrc) * (-hDest / hSrc)))))
                    ' End If
                End If
            End If
            
            If ySrc < 0 And hDest < 0 Then ySrc = 0
            If xSrc < 0 And wDest < 0 Then xSrc = 0

            If Me.ScaleMode = ScaleModeConstants.vbUser Then
                xDest -= CLng(ScaleLeft * outputResolutionScaleX / inputUnitsScaleX)
                yDest -= CLng(ScaleTop * outputResolutionScaleY / inputUnitsScaleY)
            End If
            
            Const COLORONCOLOR As Long = 3
            Const HALFTONE As Long = 4
            Const BLACKONWHITE As Long = 1
            Const WHITEONBLACK As Long = 2
            
            Dim stretchMode As Long
            Select Case StretchQuality
                Case vbQualityNormal
                    stretchMode = COLORONCOLOR      ' default for VB6 back compat
                Case vbQualityHalftone
                    stretchMode = HALFTONE
                Case Else
                    Err.Raise 5
            End Select
            
            Dim hdc As Any = Me.hDC
            Dim oldStretchMode As Long = SetStretchBltMode(hdc, stretchMode)
            
            'GDI32_SetROP2(hdc, DrawModeConstants.vbCopyPen)
            SetBrushOrgEx(hdc, 0, 0, vbNullPtr)
            'WinNativeFormsBASE.SetBkMode(hdc, 1)       ' transparent
            
            
            ' StretchBlt (and StretchDIBits) can produce edge/border artifacts in some instances.
            ' teh following translations are designed to avoid these edge artifacts
            
            If xSrc < 0 Then
                xDest += CLng(Abs(xSrc * generalTwipsScale) * outputResolutionScaleX) '/ (1440 / 600))
                wDest = CLng((picWidthPixels * generalTwipsScale) * outputResolutionScaleX) '/ (1440 / 600))
                wSrc += xSrc
                xSrc = 0
            End If
            
            If ySrc < 0 Then
                yDest += CLng(Abs(ySrc * generalTwipsScale) * outputResolutionScaleY) ' / (1440 / 600))
                hDest = CLng((picHeightPixels * generalTwipsScale) * outputResolutionScaleY) ' / (1440 / 600))
                hSrc += ySrc
                ySrc = 0
            End If
            
            If (xSrc + wSrc) > picWidthPixels Then
                ' clamp at maximum width to avoid an edge border
                Dim clampPercentX As Double = (picWidthPixels - xSrc) / wSrc
                wSrc = (picWidthPixels - xSrc)
                
                ' now adjust the destination to account for the clamped size input
                wDest = CLng(wDest * clampPercentX)
            End If
            
            If (ySrc + hSrc) > picHeightPixels Then
                ' clamp at maximum width to avoid an edge border
                Dim clampPercentY As Double = (picHeightPixels - ySrc) / hSrc
                hSrc = (picHeightPixels - ySrc)
                
                ' now adjust the destination to account for the clamped size input
                If hDest < 0 Then
                    yDest += CLng(hDest * (1 - clampPercentY))
                End If
                hDest = CLng(hDest * clampPercentY)
            End If
            
            Const RASTERCAPS As Long = 38
            Const RC_STRETCHBLT As Long = &H800&
            If (WinNativeFormsBASE.GetDeviceCaps(hdc, RASTERCAPS) And RC_STRETCHBLT) = RC_STRETCHBLT Then
                StretchBlt(hdc, xDest, yDest, wDest, hDest, srcHDC, xSrc, ySrc, wSrc, hSrc, CLng(Opcode))
                'PictureRender(CType(Of IPicture)(Picture), hdc, xDest, yDest, wDest, hDest, xSrc, ySrc, wSrc, hSrc)
            Else
                ' Fallback to using StretchDIBits        
                Dim bmp As BITMAP
                Dim bmpInfo As BITMAPINFO_RGBA_LARGE
                bmpInfo.bmiHeader.biSize = Len(Of BITMAPINFOHEADER)
                
                GetObjectW(Picture.Handle, Len(Of BITMAP), bmp)
                GetDIBits(tempDC, Picture.Handle, 0, 0, 0, bmpInfo, DIB_RGB_COLORS)
                
                Dim bmpSize As Long = bmpInfo.bmiHeader.biSizeImage
                Dim bmpBits As LongPtr = AllocMem(bmpSize)
                GetDIBits(tempDC, Picture.Handle, 0, bmpInfo.bmiHeader.biHeight, bmpBits, bmpInfo, DIB_RGB_COLORS)
                StretchDIBits(hdc, xDest, yDest, wDest, hDest, xSrc, ySrc, wSrc, hSrc, bmpBits, bmpInfo, DIB_RGB_COLORS, CLng(Opcode))
                FreeMem(bmpBits)
            End If
            
            SetStretchBltMode(hdc, oldStretchMode)
            WinNativeFormsBASE.SelectObject(srcHDC, oldBitmap)
            WinNativeFormsBASE.DeleteDC(srcHDC)
            WinNativeFormsBASE.ReleaseDC(0, tempDC)
        Else
            If IsMissing_OpCode = False Then
                Err.Raise 5     ' Opcode[rop] must be omitted for non-bitmap pictures
            End If
            
            xSrc = CLng(xSrc * OLEPictureScaleX)
            ySrc = CLng(ySrc * OLEPictureScaleY)
            
            If IsMissing_Width1 Then
                wDest = picWidthPixels
                
                If RootWindowElementBASE Is Nothing Then        ' FIXME what about non-printer rendering
                    wDest = CLng(wDest * generalTwipsScale)     ' printer
                    wDest = CLng(wDest * outputResolutionScaleX)
                Else
                    wDest = CLng(wDest * generalTwipsScale)
                    wDest = CLng(wDest * outputResolutionScaleX)
                End If
            Else
                If wDest < 0 Then
                    'wDest = -wDest
                    'FlipX = True
                    'xDest -= wDest
                End If
            End If
            If IsMissing_Height1 Then
                hDest = picHeightPixels
                
                hDest = CLng(hDest * generalTwipsScale)
                hDest = CLng(hDest * outputResolutionScaleY)
            Else
                If hDest < 0 Then
                    'hDest = -hDest
                    'FlipY = True
                    'yDest -= hDest
                End If
            End If
            If IsMissing_Width2 Then
                wSrc = pictureWidth - xSrc
                
                If IsMissing_Width1 Then
                    wDest = CLng(wDest * wSrc / pictureWidth)
                End If
            Else
                wSrc = CLng(Width2 / inputUnitsScaleX / generalTwipsScale * OLEPictureScaleX)
                
                If IsMissing_Width1 Then
                    'wDest = CLng(wDest * wSrc / pictureWidth)
                    wDest = CLng(wDest * (wSrc - xSrc) / pictureWidth)
                End If
            End If
            If IsMissing_Height2 Then
                hSrc = pictureHeight - ySrc
                
                If IsMissing_Height1 Then
                    hDest = CLng(hDest * hSrc / pictureHeight)
                End If
            Else
                hSrc = CLng(Height2 / inputUnitsScaleY / generalTwipsScale * OLEPictureScaleY)
                
                If IsMissing_Height1 Then
                    hDest = CLng(hDest * (hSrc - ySrc) / pictureHeight)
                End If
            End If
                                            
            If (wDest <> 0) And (hDest <> 0) Then
                Dim _Picture As Any = CType(Of IPicture)(Picture)
                
                Dim _srcYHeight As Long = hSrc
                Dim _srcXWidth As Long = wSrc
                
                If Me.ScaleMode = ScaleModeConstants.vbUser Then
                    xDest -= CLng(BaseGraphicsInfo.ScaleLeft * outputResolutionScaleX / inputUnitsScaleX)
                    yDest -= CLng(BaseGraphicsInfo.ScaleTop * outputResolutionScaleY / inputUnitsScaleY)
                End If
                
                Dim xSrcPixels As Long = CLng(xSrc / OLEPictureScaleX)
                If xSrc < 0 Then
                    xDest += CLng(Abs(xSrcPixels * generalTwipsScale) * outputResolutionScaleX)
                    wDest = CLng((picWidthPixels * generalTwipsScale) * outputResolutionScaleX)
                    _srcXWidth += xSrc
                    xSrc = 0
                End If
            
                Dim ySrcPixels As Long = CLng(ySrc / OLEPictureScaleY)
                If ySrc < 0 Then
                    yDest += CLng(Abs(ySrcPixels * generalTwipsScale) * outputResolutionScaleY)
                    hDest = CLng((picHeightPixels * generalTwipsScale) * outputResolutionScaleY)
                    _srcYHeight = pictureHeight
                    ySrc = 0
                End If
                
                If (xSrc + _srcXWidth) > pictureWidth Then
                    ' clamp at maximum width to avoid an edge border
                    clampPercentX = (pictureWidth - xSrc) / _srcXWidth
                    _srcXWidth = (pictureWidth - xSrc)
                
                    ' now adjust the destination to account for the clamped size input
                    wDest = CLng(wDest * clampPercentX)
                End If
            
                If (ySrc + _srcYHeight) > pictureHeight Then
                    ' clamp at maximum width to avoid an edge border
                    clampPercentY = (pictureHeight - ySrc) / _srcYHeight
                    _srcYHeight = (pictureHeight - ySrc)
                
                    ' now adjust the destination to account for the clamped size input
                    ' If hDest < 0 Then
                    '     Stop
                    '     yDest += CLng(hDest * (1 - clampPercentY))
                    ' End If
                    hDest = CLng(hDest * clampPercentY)
                End If
                
                
                
                If FlipX Then
                    _srcXWidth = -_srcXWidth
                    xSrc = CLng(Abs(_srcXWidth))
                End If
                
                If FlipY Then
                    _srcYHeight = -_srcYHeight
                Else
                    ySrc = pictureHeight - ySrc
                End If
                
                _srcYHeight = -_srcYHeight
                
                'If RootWindowElementBASE IsNot Nothing Then
                '    PictureRender(_Picture, Me.hDC, xDest, yDest, wDest, hDest, xSrc, ySrc, _srcXWidth, _srcYHeight)
                'Else
                    ' Cant use DrawIconEx with a printer device context, so we have to resort back to StdPicture.Render
                    _Picture.Render(CLng(Me.hDC), xDest, yDest, wDest, hDest, xSrc, ySrc, _srcXWidth, _srcYHeight, vbNullPtr)
                'End If
            Else
                Err.Raise 380
            End If
        End If
        
        HandleAutoRedrawInvalidation()
    End Sub
    
End Class