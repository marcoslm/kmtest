[InterfaceId("E274535E-AA5B-49C5-83B1-2243A98D82F3")]
Interface ITbRecordset
    Property Get EOF() As Boolean
    Sub MoveNext()
    Function GetFieldBinder(ByRef FieldName As String) As Object        ' implementor can return a general IDispatch object, or something that implements ITbExpression
End Interface

[COMCreatable(False)]
Class ObjectFieldBinderByName
    Implements ITbExpression
    
    Public Object As Object
    Public FieldName As String
    
    Sub New(Object As Object, FieldName As String)
        Set Me.Object = Object
        Me.FieldName = FieldName
    End Sub
    
    Function GetValue() As Variant _
            Implements ITbExpression.Evaluate
        
        Return CallByName(Object, FieldName, vbGet)
    End Function
End Class

[COMCreatable(False)]
Class ExpressionGenericFieldBinder
    Implements ITbExpression
 
    Private Field As Object
    
    Sub New(Field As Object)
        Set Me.Field = Field
    End Sub
    
    Private Function ITbExpression_Evaluate() As Variant
        Return Field.Value
    End Function
End Class

[COMCreatable(False)]
Class ExpressionGenericRecordsetWrapper
    Implements ITbRecordset
    
    Dim Recordset As Object
    
    Sub New(Recordset As Object)
        Set Me.Recordset = Recordset
        
        On Error Resume Next
        Recordset.MoveFirst
    End Sub
    
    Private Property Get ITbRecordset_EOF() As Boolean
        Return Recordset.EOF
    End Property
    
    Private Sub ITbRecordset_MoveNext()
        Recordset.MoveNext
    End Sub
    
    Private Function ITbRecordset_GetFieldBinder(ByRef FieldName As String) As Object
        On Error Resume Next
        Dim Field As Object = Recordset.Fields(FieldName)
        If Field IsNot Nothing Then
            Return New ExpressionGenericFieldBinder(Field)
        End If
        ' It's generally more optimal to bind to the recordset field directly (as above), but we could have just returned the Recordset.Fields object
        ' and let the expression engine look the field up for each iteration
        ' Return Recordset.Fields
    End Function
    
End Class

[ClassId("5FC86B4D-5CB0-442F-97FA-9A25DCB21A0A")]
[InterfaceId("60A45893-2E98-4A68-914E-C3B7F4802D5A")]
[COMCreatable(False)]
[ComImport(True)]
Class ReportPage
    Public PageNumber As Long
    Public MetaFile As LongPtr
    Public MetaFileTwipsPerPixelX As Double
    Public MetaFileTwipsPerPixelY As Double
    Public IsLastPage As Boolean
        
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function DeleteEnhMetaFile Lib "gdi32" (ByVal hmf As LongPtr) As Long
    
    Public Sub New(ByVal PageNumber As Long, ByVal MetaFile As LongPtr, ByVal IsLastPage As Boolean, ByVal twipsPerPixelX As Double, ByVal twipsPerPixelY As Double)
        Me.PageNumber = PageNumber
        Me.MetaFile = MetaFile
        Me.IsLastPage = IsLastPage
        Me.MetaFileTwipsPerPixelX = twipsPerPixelX
        Me.MetaFileTwipsPerPixelY = twipsPerPixelY
    End Sub
    
    Sub Class_Terminate()
        If Me.MetaFile <> vbNullPtr Then
            DeleteEnhMetaFile(Me.MetaFile)
        End If
    End Sub
End Class

[WindowsControl("/miscellaneous/ICONS??/Frame??.png")]
[ClassId("09040293-ECF8-4DEB-B7DE-DB264DC6ABF5")]
[InterfaceId("E8890622-E14E-4A04-92F2-2F846863CC24")]
' WARNING: above InterfaceId is referred to as IID_ITBReport in tB Sources
[COMCreatable(False)]
[COMExtensible(True)]
[EventsUseDispInterface]
[ComImport(True)]
Class Report
     
     #Region "INHERITANCE"
     
        [WithDispatchForwarding] Implements Control
        Implements WindowsControls.IWindowsControl
        Implements WinNativeFormsBASE.BaseForm Via _BaseForm = New WinNativeFormsBASE.BaseForm
        Implements ITbCustomBinder
        'Implements GraphicsBase Via _BaseGraphics = New GraphicsBase
        Private _BaseGraphics As GraphicsBase = New GraphicsBase
        
    # End Region
        
    #Region "STATE"
    
        Enum ZoomAutoFitConstants
            vbZoomAutoFit       ' updates ZoomPercent to maximize the fit of the page in the window
            vbZoomAutoFitOnce   ' updates ZoomPercent to maximize the fit of the page in the window, only once on opening the report
            vbZoomAutoFitNever  ' allows manual control of ZoomPercent
        End Enum

        [CustomDesigner("designer_SpectrumWindows")]
        [Description("Note: affects PREVIEW only.  Does not get printed")]
             Public PaperColor As OLE_COLOR = VBRUN.vbWhite
            
            Private WithEvents RootWindowElement As WindowsControls.WindowElement
            Private IsInitialized As Boolean
            Private IsDesignMode As Boolean
            
        [NonBrowsable]
            Public InternalControlSections() As ControlsSection
            
            Private ExpressionService As TbExpressionService
            
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function GetClassLongA Lib "user32" (ByVal hwnd As LongPtr, ByVal nIndex As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function SetClassLongA Lib "user32" (ByVal hwnd As LongPtr, ByVal nIndex As Long, ByVal dwNewLong As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function ShowWindow Lib "user32" (ByVal hWnd As LongPtr, ByVal nCmdShow As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function SetScrollInfo Lib "user32" (ByVal hWnd As LongPtr, ByVal nBar As WinNativeFormsBASE.SCROLLTYPE, ByRef lpsi As WinNativeFormsBASE.SCROLLINFO, ByVal redraw As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function CreateWindowExW Lib "user32" (ByVal dwExStyle As Long, ByVal lpClassName As String, ByVal lpWindowName As String, ByVal dwStyle As Long, ByVal X As Long, ByVal Y As Long, ByVal nWidth As Long, ByVal nHeight As Long, ByVal hWndParent As LongPtr, ByVal hMenu As LongPtr, ByVal hInstance As LongPtr, ByVal lpParam As LongPtr) As LongPtr
        
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function SetWindowOrgEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function CreateEnhMetaFileW Lib "gdi32" (ByVal hdc As LongPtr, ByVal lpFilename As String, ByRef lprc As WinNativeFormsBASE.RECT, ByVal lpDesc As String) As LongPtr
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function CloseEnhMetaFile Lib "gdi32" (ByVal hdc As LongPtr) As LongPtr
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function PlayEnhMetaFile Lib "gdi32" (ByVal hdc As LongPtr, ByVal hmf As LongPtr, ByRef lprect As WinNativeFormsBASE.RECT) As LongPtr
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function GetClientRect Lib "user32" (ByVal hWnd As LongPtr, ByRef outRect As WinNativeFormsBASE.RECT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function SetWindowExtEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function SetViewportExtEx Lib "gdi32" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As POINT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function IntersectClipRect Lib "gdi32" (ByVal hdc As LongPtr, ByVal left As Long, ByVal top As Long, ByVal right As Long, ByVal bottom As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function ExcludeClipRect Lib "gdi32" (ByVal hdc As LongPtr, ByVal left As Long, ByVal top As Long, ByVal right As Long, ByVal bottom As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function GetEnhMetaFileHeader Lib "gdi32" (ByVal hmf As LongPtr, ByVal nSize As Long, ByRef lpEnhMetaHeader As ENHMETAHEADER) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function DeleteEnhMetaFile Lib "gdi32" (ByVal hmf As LongPtr) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function MessageBoxW Lib "user32" (ByVal hWnd As LongPtr, ByVal lpText As String, ByVal lpCaption As String, ByVal uType As Long) As Long
                      
        
        [Serialize(True, "Icon")]
        [CustomDesigner("designer_IconBytes")]
            Private ReadOnly IconINIT() As Byte

        Public ReadOnly TopMost As Boolean = False                      ' FIXME could make this not ReadOnly
        
        [Description("Opacity, given as a percentage, 0 - 100")]
        Public Opacity As Double = 100
        
        [CustomDesigner("designer_SpectrumWindowsOrClear")]
        [Description("A color, when set, that will appear fully transparent in the window")]
        Public TransparencyKey As OLE_COLOR = -1

            Public HelpContextID As Long
        [Unimplemented]
            Public RightToLeft As Boolean

        [Serialize(True, "MinWidth")]
        [Description("The minimum width of the CLIENT area, in twips")]
            Private MinWidthINIT As Double
        [Serialize(True, "MinHeight")]
        [Description("The minimum height of the CLIENT area, in twips")]
            Private MinHeightINIT As Double
        [Serialize(True, "MaxWidth")]
        [Description("The maximum width of the CLIENT area, in twips")]
            Private MaxWidthINIT As Double
        [Serialize(True, "MaxHeight")]
        [Description("The maximum height of the CLIENT area, in twips")]
            Private MaxHeightINIT As Double
                                                    
    #End Region

    #Region "EVENTS"
    
        Event Activate()
        Event Deactivate()
        Event Initialize()
        [DefaultDesignerEvent] Event Load()
        [DispId(&HEAEA0004)]
            Event Click()
        [DispId(&HEAEA0005)]
            Event DblClick()
        [DispId(&HEAEA0006)]
            Event GotFocus()
        [DispId(&HEAEA0008)]
            Event KeyDown(KeyCode As Integer, Shift As Integer)
        [DispId(&HEAEA0009)]
            Event KeyPress(KeyAscii As Integer)
        [DispId(&HEAEA000A)]
            Event KeyUp(KeyCode As Integer, Shift As Integer)
        [DispId(&HEAEA0007)]
            Event LostFocus()
        [DispId(&HEAEA0001)]
            Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [DispId(&HEAEA0002)]
            Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [DispId(&HEAEA0003)]
            Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)
        Event BeforePaintSection(ByVal Section As ControlsSection)
        Event Resize()
        Event Terminate()
        Event Unload(Cancel As Integer)
        Event QueryUnload(Cancel As Integer, UnloadMode As Integer)
        
    #End Region
               
    #Region "MEMBERS"

        Private Sub Class_Terminate()
            DeleteCachedBufferBitmap()
            ReleaseGdiStuff()
            RaiseEvent Terminate()
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
        End Sub
        
        Private Sub HandleInitialize(ByVal ControlContext As WindowsControls.WindowsControlContext) _
                Implements IWindowsControl.Initialize

            Me.InternalStateReset()     ' resets all the base class state
            Dim blankRECT As WinNativeFormsBASE.RECT
            Me.FirstPaint = True
            Me.AlreadyPainting = False
            Set Me.CachedPages = New Collection
            Me.CachedBufferBitmapWidth = 0
            Me.CachedBufferBitmapHeight = 0
            Me.CachedBufferHDC = vbNullPtr
            Me.CachedBufferBitmap = vbNullPtr
            Me.CachedBufferOrigBitmap = vbNullPtr
            Me.BehindPageBackBrush = vbNullPtr
            Me.ScrollbarsBackBrush = vbNullPtr
            Me.PaperBackBrush = vbNullPtr
            Me.WhiteBackBrush = vbNullPtr
            Me.ToolbarBackBrush = vbNullPtr
            Me.PageOutlinePen = vbNullPtr
            Me.GdiStuffPrepared = False
            Me.CurrentPageIsLast = False
            Me.hwnd_ScrollH = vbNullPtr
            Me.hwnd_ScrollV = vbNullPtr
            Me.ScrollBarsVisible = False
            Erase Me.Expressions
            Me.ExpressionsCount = 0
            Erase Me.AggregateControls
            Me.AggregateControlsCount = 0
            Me.moveFirstButtonRect = blankRECT
            Me.movePrevButtonRect = blankRECT
            Me.moveNextButtonRect = blankRECT
            Me.moveLastButtonRect = blankRECT
            Me.zoomOutButtonRect = blankRECT
            Me.zoomInButtonRect = blankRECT
            Me.zoomTextRect = blankRECT
            Me.printButtonRect = blankRECT
            Me.activebutton = 0
            Me.hoverbutton = 0
            Me.Page = 1
            Me.Pages = 999
            Me.RecordNum = 1
            Set Me.InternalIcon = Nothing
            Set Me.InternalRecordset = Nothing
            
            
            With ControlContext.GetSerializer
                If Not .Deserialize(Me) Then
                    'Caption_INIT = "Report"
                End If
                ' This allows dispatch calls to pass on to the outer form controller, allowing for extensibility  
                CType(Of ITwinBasicInternalClassSupport)(Me).OverrideDispatchHandler .GetRootClassDispatch  ' this causes a circular reference that needs to be manually broken in IOleObject_Close
                Me.IsDesignMode = .IsDesignMode
            End With
            
            CommonLoadPictureInit(Me.InternalIcon, Me.IconINIT)
            
            With CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX)
                .BaseGraphicsInfoPtr = _BaseGraphics.InitBaseGraphicsInfo()
                .MinWidth = MinWidthINIT
                .MinHeight = MinHeightINIT
                .MaxWidth = MaxWidthINIT
                .MaxHeight = MaxHeightINIT
            End With
            
            Dim Opacity As Any = Me.Opacity
            If Opacity > 100 Then Me.Opacity = 100
            If Opacity < 0 Then Me.Opacity = 0
                   
            Dim InitData As WinNativeFormsBASE.WindowCreationData
            InitData.ClassName = "ThunderForm"
            InitData.Caption = ""
            InitData.WindowStyles = WinNativeFormsBASE.WS_CLIPCHILDREN
            InitData.ExtendedStyles = If(TopMost = True, WinNativeFormsBASE.WS_EX_TOPMOST, 0&)
            InitData.Flags = ForwardGotFocus Or _
                                ForwardLostFocus Or _
                                ForwardKeyDown Or _
                                ForwardKeyUp Or _
                                ForwardKeyPress Or _
                                ForwardDoubleClick Or _
                                ForwardMouseDown Or _
                                ForwardMouseUp Or _
                                ForwardMouseMove Or _
                                ManualMouseCapture Or _
                                ForwardButtonClick Or _
                                ScaleAdjustMouseEvents Or _
                                IsReportMode
            If Me.MDIChild Then InitData.Flags += IsMDIChild
            Set Me.RootWindowElement = CreateRootWindowElement(ControlContext, InitData)
            
            _BaseGraphics.InitGraphics(RootWindowElement)
'            Me.[_BaseGraphics].SyncScaleMode(Me, Me.RootWindowElement)
        End Sub
        
        Private Sub HandleDestroy() _
                Implements IWindowsControl.Destroy
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            
            Dim Section As ControlsSection
            For Each Section In InternalControlSections
                Section.InternalCleanup()
            Next
            
            ' disconnect anything that causes a circular reference here
            'Debug.Print "Form::HandleDestroy"            
            Set Me.[_BaseGraphics] = Nothing
            Set Me.SetRootWindowElementScrollH = Nothing
            Set Me.SetRootWindowElementScrollV = Nothing
            Set Me.CachedPages = Nothing
            
'            Debug.Print "Form.HandleDestroy"
        End Sub
        
        Type Expression
            Expr As String
            Eval As ITbExpression
            Control As Control
            CurrentValue As Variant
        End Type
        
        Private Expressions() As Expression
        Private ExpressionsCount As Long

        Private AggregateControls() As Control
        Private AggregateControlsCount As Long
        
        Private Function ConvertVBxReportPlaceholdersToExpression(ByVal Caption As String) As String
            Dim expression As String = "='"
            Dim startPos As Long = 1
            Caption = Replace(Caption, "'", "''")
            Dim captionLen As Long = Len(Caption)
            Dim CountOfPlaceholders As Long = 0
            Do
                Dim placeholderPos As Long = InStr$(startPos, Caption, "%")
                If placeholderPos = 0 Then Exit Do
                If placeholderPos = captionLen Then Exit Do
                
                expression &= Mid$(Caption, startPos, placeholderPos - startPos)
                
                Dim placeholderChar As Long = Asc(Mid$(Caption, placeholderPos + 1, 1))
                CountOfPlaceholders += 1
                Select Case placeholderChar
                    Case Asc("p"):      ' Current Page Number
                        expression &= "' & Report.Page & '"
                    Case Asc("P"):      ' Total number of pages
                        expression &= "' & Report.Pages & '"
                    Case Asc("d"):      ' Current Date (short)
                        expression &= "' & FormatDateTime(Now, vbShortDate) & '"
                    Case Asc("D"):      ' Current Date (long)
                        expression &= "' & FormatDateTime(Now, vbLongDate) & '"
                    Case Asc("t"):      ' Current Time (short)
                        expression &= "' & FormatDateTime(Now, vbShortTime) & '"
                    Case Asc("T"):      ' Current Time (long)
                        expression &= "' & FormatDateTime(Now, vbLongTime) & '"
                    Case Asc("i"):      ' Report title
                        expression &= "' & Report.Caption & '"
                    Case Else
                        ' It wasn't a valid placeholder, so just output the % character
                        expression &= "%"
                        placeholderPos -= 1
                        CountOfPlaceholders -= 1
                End Select
                startPos = placeholderPos + 2
            Loop
            If CountOfPlaceholders > 0 Then
                expression &= Mid$(Caption, startPos, (captionLen - startPos) + 1) & "'"
                Return expression
            End If
        End Function
        
        Private Sub BindExpressions()
            On Error Resume Next
            Dim ctl As Control
            For Each ctl In Me.Controls
                Dim dataField As String = ""
                dataField = CStr(ctl.DataField)
                If Len(dataField) = 0 Then
                    ' Check if the Label Caption uses VBx placeholders
                    If TypeOf ctl Is Label Then
                        If InStr(ctl.Caption, "%") > 0 Then
                            dataField = ConvertVBxReportPlaceholdersToExpression(CStr(ctl.Caption))
                        End If
                    End If
                End If
                If Left(dataField, 1) = "=" Then
                    'Debug.Print "*** EXPRESSION: ", ctl.Name, dataField
                    If Len(ctl.DataSource) = 0 Then
                        If (ExpressionsCount Mod 128) = 0 Then
                            ReDim Preserve Expressions(ExpressionsCount + 128)
                        End If
                        With Expressions(ExpressionsCount)
                            .Expr = dataField
                            
                            If ExpressionService Is Nothing Then
                                Set ExpressionService = New TbExpressionService
                                ExpressionService.AddStdLibraryBinder()
                                ExpressionService.AddCustomBinderObject("Report", Me, IsAppObject)
                                ExpressionService.AddCustomBinder(Me)
                            End If
                            
                            Set .Eval = ExpressionService.Compile(Right$(dataField, Len(dataField) - 1))
                            
                            Set .Control = ctl
                        End With
                        ExpressionsCount += 1
                        
                        If TypeOf ctl Is Label Then
                            Dim ControlLabel As Any = CType(Of Label)(ctl)
                            If ControlLabel.DataFieldAggregate <> vbAggregateNone Then
                                If (AggregateControlsCount Mod 128) = 0 Then
                                    ReDim Preserve AggregateControls(AggregateControlsCount + 128)
                                End If
                                Set AggregateControls(AggregateControlsCount) = ctl
                                AggregateControlsCount += 1
                            End If
                        End If
                    End If
                End If
            Next
        End Sub
        
        Private Sub EvaluateExpressions()
            On Error Resume Next
            Dim Expression As Expression
            Dim ExpressionIdx As Long
            For ExpressionIdx = 0 To ExpressionsCount - 1
                With Expressions(ExpressionIdx)
                    .CurrentValue = CVErr(5)        ' in case next line throws
                    .CurrentValue = .Eval.Evaluate()
                    
                    If TypeOf .Control Is Label Then
                        If IsError(.CurrentValue) Then
                            .Control.Caption = "#Error"
                        Else
                            .Control.Caption = .CurrentValue
                        End If
                    ElseIf TypeOf .Control Is QRCode Then
                        If IsError(.CurrentValue) Then
                            .Control.Payload = ""
                        Else
                            .Control.Payload = .CurrentValue
                        End If
                    Else
                        If IsError(.CurrentValue) Then
                            .Control.Value = 0
                        Else
                            .Control.Value = .CurrentValue
                        End If
                    End If
                End With
            Next
        End Sub
        
        Private Sub UpdateAggregates()
            On Error Resume Next
            Dim Control As Object
            Dim AggregateControlIdx As Long
            For AggregateControlIdx = 0 To AggregateControlsCount - 1
                With CType(Of Label)(AggregateControls(AggregateControlIdx))
                    .DataFieldAggregateValue += CDec(.Caption)
                    .Caption = CStr(.DataFieldAggregateValue)
                End With
            Next
        End Sub
                
        Private Sub HandleLoad() _
                Handles RootWindowElement.Load

            If Moveable = False Then SyncMoveable()
            
            Dim Opacity As Any = Me.Opacity
            If ((Opacity >= 0) And (Opacity < 100)) Or (TransparencyKey <> -1) Then
                SyncOpacity
            End If
            
            If IsInitialized = False Then InitializeMe
            RaiseEvent Load()
            
            Const GCL_STYLE As Long = -26
            Const CS_DBLCLKS As Long = 8
            Dim hWnd As Any = Me.hWnd
            Dim dwClssStyle As Long = GetClassLongA(hWnd, GCL_STYLE)
            SetClassLongA(hWnd, GCL_STYLE, dwClssStyle And Not CS_DBLCLKS)
            
            ' FIXME need to release hwnd_ScrollV / hwnd_ScrollH
            Dim scrollSizeX As Long = CLng(16 * Me.DpiScaleFactorX)
            Dim scrollSizeY As Long = CLng(16 * Me.DpiScaleFactorY)
            Dim TOOLBARPADDEDHEIGHT As Long = CLng(TOOLBARHEIGHT * DpiScaleFactorY) + CLng(TOOLBARPADDINGY * DpiScaleFactorY) * 2
            Dim actualHeight As Long = Me.RootWindowElement.CurrentHeight - TOOLBARPADDEDHEIGHT
            hwnd_ScrollV = CreateWindowExW(0, "SCROLLBAR", vbNullString, WinNativeFormsBASE.WS_CHILD Or WinNativeFormsBASE.ScrollBarStyles.SBS_VERT, Me.RootWindowElement.CurrentWidth - scrollSizeX, 0, scrollSizeX, actualHeight - scrollSizeY, hWnd, vbNullPtr, vbNullPtr, vbNullPtr)
            hwnd_ScrollH = CreateWindowExW(0, "SCROLLBAR", vbNullString, WinNativeFormsBASE.WS_CHILD Or WinNativeFormsBASE.ScrollBarStyles.SBS_HORZ, 0, actualHeight - scrollSizeY, Me.RootWindowElement.CurrentWidth - scrollSizeX, scrollSizeY, hWnd, vbNullPtr, vbNullPtr, vbNullPtr)
                        
            Set SetRootWindowElementScrollH = CType(Of WindowElement)(SubClassWindowElement(hwnd_ScrollH, 0))
            Set SetRootWindowElementScrollV = CType(Of WindowElement)(SubClassWindowElement(hwnd_ScrollV, 0))
            
            ResyncScrollBars()
            
            ' Shouldn't the bindings happen automatically, and get updated automatically?
            BindExpressions()
            
            'InternalIsFirstResizeEventAfterLoad = True
        End Sub
        
        Private Sub ResyncScrollBars()
            ' Check if we NEED scrollbars
            Dim TOOLBARPADDEDHEIGHT As Long = CLng(TOOLBARHEIGHT * DpiScaleFactorY) + CLng(TOOLBARPADDINGY * DpiScaleFactorY) * 2
            Dim availableHeight As Long = Me.RootWindowElement.CurrentHeight - TOOLBARPADDEDHEIGHT
            Dim availableWidth As Long = Me.RootWindowElement.CurrentWidth

            Dim pageWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsReportWidth), vbScaledPixels, vbPixels)
            Dim pageHeight As Double = [_BaseGraphics].ScaleY(CSng(PixelsReportHeight), vbScaledPixels, vbPixels)
            
            Dim leftMarginWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsLeftMargin), vbScaledPixels, vbPixels)
            Dim rightMarginWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsRightMargin), vbScaledPixels, vbPixels)
            Dim topMarginWidth As Double = [_BaseGraphics].ScaleY(CSng(PixelsTopMargin), vbScaledPixels, vbPixels)
            Dim bottomMarginWidth As Double = [_BaseGraphics].ScaleY(CSng(PixelsBottomMargin), vbScaledPixels, vbPixels)
            
            Dim zoomedPageWidth As Long = (((pageWidth + leftMarginWidth + rightMarginWidth) * ZoomPercent) \ 100) + (PreviewPageBorderWidth * 2)
            Dim zoomedPageHeight As Long = (((pageHeight + topMarginWidth + bottomMarginWidth) * ZoomPercent) \ 100) + (PreviewPageBorderWidth * 2)
            
            If (zoomedPageWidth > availableWidth) Or (zoomedPageHeight > availableHeight) Then
                ' Scrollbars are needed                
                ' adjust for scrollbars
                'Debug.Print "availableHeight BEFORE: ", availableHeight
                availableWidth -= CLng(16 * DpiScaleFactorX)
                availableHeight -= CLng(16 * DpiScaleFactorY)
                'Debug.Print "availableHeight AFTER: ", availableHeight
                
                Dim SCROLLINFO As WinNativeFormsBASE.SCROLLINFO
                SCROLLINFO.cbSize = LenB(Of WinNativeFormsBASE.SCROLLINFO)
                SCROLLINFO.fMask = WinNativeFormsBASE.SIF_RANGE Or WinNativeFormsBASE.SIF_PAGE Or WinNativeFormsBASE.SIF_POS
                SCROLLINFO.nMin = 0
                SCROLLINFO.nMax = zoomedPageWidth
                SCROLLINFO.nPage = availableWidth
                SCROLLINFO.nPos = 0
                SetScrollInfo(hwnd_ScrollH, WinNativeFormsBASE.SB_CTL, SCROLLINFO, 1)
                
                SCROLLINFO.cbSize = LenB(Of WinNativeFormsBASE.SCROLLINFO)
                SCROLLINFO.fMask = WinNativeFormsBASE.SIF_RANGE Or WinNativeFormsBASE.SIF_PAGE Or WinNativeFormsBASE.SIF_POS
                SCROLLINFO.nMin = 0
                SCROLLINFO.nMax = zoomedPageHeight
                SCROLLINFO.nPage = availableHeight
                SCROLLINFO.nPos = 0
                SetScrollInfo(hwnd_ScrollV, WinNativeFormsBASE.SB_CTL, SCROLLINFO, 1)
            
                'Debug.Print "Me.RootWindowElement.CurrentHeight: " & Me.RootWindowElement.CurrentHeight
                Dim scrollSizeX As Long = CLng(16 * Me.DpiScaleFactorX)
                Dim scrollSizeY As Long = CLng(16 * Me.DpiScaleFactorY)
                Dim actualHeight As Long = Me.RootWindowElement.CurrentHeight - TOOLBARPADDEDHEIGHT
                WinNativeFormsBASE.SetWindowPos(hwnd_ScrollV, vbNullPtr, Me.RootWindowElement.CurrentWidth - scrollSizeX, 0, scrollSizeX, actualHeight - scrollSizeY, WinNativeFormsBASE.SWP_NOZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE)
                WinNativeFormsBASE.SetWindowPos(hwnd_ScrollH, vbNullPtr, 0, actualHeight - scrollSizeY, Me.RootWindowElement.CurrentWidth - scrollSizeX, scrollSizeY, WinNativeFormsBASE.SWP_NOZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE)
                
                ShowWindow(hwnd_ScrollH, WinNativeFormsBASE.SW_SHOWNORMAL)
                ShowWindow(hwnd_ScrollV, WinNativeFormsBASE.SW_SHOWNORMAL)
                
                Me.ScrollBarsVisible = True
                'Debug.Print "*** SCROLLBARS VISIBLE"
            Else
                ShowWindow(hwnd_ScrollH, WinNativeFormsBASE.SW_HIDE)
                ShowWindow(hwnd_ScrollV, WinNativeFormsBASE.SW_HIDE)
                Me.ScrollBarsVisible = False
                'Debug.Print "*** SCROLLBARS INVISIBLE"
            End If
        End Sub
      
        Private hwnd_ScrollH As LongPtr
        Private hwnd_ScrollV As LongPtr
        Private ScrollBarsVisible As Boolean
        
        Private WithEvents SetRootWindowElementScrollH As WindowElement
        Private WithEvents SetRootWindowElementScrollV As WindowElement
        
        Private Sub HandlePreLoad() _
                Handles RootWindowElement.PreLoadForm

            ' At this point the HWND is available, but not correct size etc.
            If IsDesignMode = False Then
                IconChanged()
            End If
            
            Me.[_BaseGraphics].SyncScaleMode(Me, Me.RootWindowElement)
            
            ' This has to happen here, as it can be accessed via ActiveX ambient properties during creation
            'Stop
            [_BaseGraphics].InternalSyncFontProperties(True)
            
        End Sub
        
        Private Sub HandlePreLoad2() _
                Handles RootWindowElement.PreLoadForm2
            
            RaiseEvent Initialize()
            
        End Sub
                
        ' Private Sub HandleActivateMDIChild() _
        '         Handles RootWindowElement.ActivateMDIChild
        '     Dim rootMenu As LongPtr
        '     Dim windowListMenu As LongPtr
        '     CommonBuildMenus(Menus, Me.Controls, rootMenu, windowListMenu, Me, 0, False, Nothing)
        '     'Debug.Print "MDI Child windowListMenu: " & windowListMenu
        '     RootWindowElement.SetMDIMenu(rootMenu, windowListMenu)
        ' End Sub
        
        ' Private Sub HandleDeactivateMDIChild() _
        '         Handles RootWindowElement.DeactivateMDIChild
        '    RootWindowElement.SetMDIMenu(vbNullPtr, vbNullPtr)
        ' End Sub
        
        Private Sub HandleActivate() _
            Handles RootWindowElement.Activate
                
            RaiseEvent Activate()
        End Sub

        Private Sub HandleDeactivate() _
                Handles RootWindowElement.Deactivate
                
            RaiseEvent Deactivate()
        End Sub
                
        Private Sub InitializeMe()
            
            Me.[_BaseGraphics].SyncScaleMode(Me, Me.RootWindowElement)
            
            ' FIXME this is in lieu of having a working Create event here
            _BaseGraphics.ChangeHDC(0, Me.hWnd, Me.RootWindowElement, Nothing, Me, True)
            IsInitialized = True
            
        End Sub
      
        Type ENHMETAHEADER
            iType As Long
            nSize As Long
            rclBounds As WinNativeFormsBASE.RECT
            rclFrame As WinNativeFormsBASE.RECT
            dSignature As Long
            nVersion As Long
            nBytes As Long
            nRecords As Long
            nHandles As Integer
            sReserved As Integer
            nDescription As Long
            offDescription As Long
            nPalEntries As Long
            szlDevice As WinNativeFormsBASE.SIZE
            szlMillimeters As WinNativeFormsBASE.SIZE
            cbPixelFormat As Long
            offPixelFormat As Long
            bOpenGL As Long
            szlMicrometers As WinNativeFormsBASE.SIZE
        End Type
                    
        Private Sub DrawSection(ByRef Section As ControlsSection, ByVal width As Double)
                        
            With CType(Of SectionRenderState)(Section.GetRenderStatePtr())
                
                Dim topBorderHeight As Long = 0 'CLng(Section.TopBorderHeight * DpiScaleFactorY)
                Dim mainHeight As Long = CLng(Section.PixelsHeight * DpiScaleFactorY)
                Dim bottomBorderHeight As Long = CLng(Section.PixelsBorderBottomHeight * DpiScaleFactorY)
                Dim sectionHeight As Any = topBorderHeight + mainHeight + bottomBorderHeight
                
                
                Dim sourceRect As WinNativeFormsBASE.RECT
                sourceRect.Right = 10000000 ' CLng(width * 10000)       ' FIXME watch we don't overflow
                sourceRect.Bottom = 10000000 'CLng(sectionHeight * 10000)  'CLng(10000000)' * 10000)
                
                Dim sectionMetaDC As LongPtr = CreateEnhMetaFileW(vbNullPtr, vbNullString, sourceRect, vbNullString)
                
                If Section.CachedBackBrush = 0 Then Section.CacheGdiStuff()
                
                RootWindowElement.SetDrawingSectionId(Section.CachedOrdinal)
                
                Dim rect As WinNativeFormsBASE.RECT
                If Section.BackStyle = vbBFOpaque Then
                    Dim BackBrush As LongPtr
                    If .UseAlternateColor AndAlso (Section.SectionType = Detail) Then
                        BackBrush = Section.CachedAlternateBackBrush
                    Else
                        BackBrush = Section.CachedBackBrush
                    End If
                                        
                    rect.Right = CLng(width)
                    rect.Bottom = CLng(sectionHeight)
                    WinNativeFormsBASE.FillRect(sectionMetaDC, rect, BackBrush)
                End If

                If topBorderHeight > 0 Then
                    rect.Right = CLng(width)
                    rect.Bottom = CLng(topBorderHeight)
                    'WinNativeFormsBASE.FillRect(sectionMetaDC, rect, Section.CachedBorderTopBrush)
                End If
                
                If bottomBorderHeight > 0 Then
                    rect.Right = CLng(width)
                    rect.Top = CLng(topBorderHeight + mainHeight)
                    rect.Bottom = rect.Top + CLng(bottomBorderHeight)
                    WinNativeFormsBASE.FillRect(sectionMetaDC, rect, Section.CachedBorderBottomBrush)
                End If
                
                ' SetWindowOrgEx(sectionMetaDC, 0, -CLng(OffsetY + topBorderHeight), vbNullPtr)
                SetWindowOrgEx(sectionMetaDC, 0, -CLng(topBorderHeight), vbNullPtr)
            
                Dim savedDcIndex As Long = SaveDC(sectionMetaDC)
                IntersectClipRect(sectionMetaDC, 0, 0, CLng(width), mainHeight)
                                
                On Error Resume Next
                    Me.CurrentPaintingSectionDC = sectionMetaDC
                    RaiseEvent BeforePaintSection(Section)
                    Me.CurrentPaintingSectionDC = vbNullPtr
                On Error GoTo 0
                
                Me.[_BaseGraphics].OnPaint(sectionMetaDC)
                RestoreDC(sectionMetaDC, savedDcIndex)
            
                .MetaFile = CloseEnhMetaFile(sectionMetaDC)
                GetEnhMetaFileHeader(.MetaFile, LenB(Of ENHMETAHEADER), .MetaFileHeader)
                .OffsetY = 0
                .Height = sectionHeight
                .UseAlternateColor = Not .UseAlternateColor
            End With
        End Sub
         
        ' Returns True if rendering was complete
        Private Function RenderSection(ByRef Section As ControlsSection, ByVal hdc As LongPtr, ByRef OffsetY As Double, ByRef AvailableHeight As Long, ByVal IsConsideredEmptyPage As Boolean) As Boolean
                    
            With CType(Of SectionRenderState)(Section.GetRenderStatePtr())
            
                If .PendingPageBreak Then
                    DeleteEnhMetaFile(.MetaFile)
                    .MetaFile = vbNullPtr
                    .RenderComplete = True
                    .PendingPageBreak = False
                    Return True
                End If
                
                If .Height > AvailableHeight Then
                    If IsConsideredEmptyPage = False Then
                        If Section.KeepTogether = True Then
                            .RenderComplete = False
                            Return False
                        End If
                    End If
                End If
                
                If Section.ShouldForceBreakBefore() Then
                    If IsConsideredEmptyPage = False Then
                        .RenderComplete = False
                        Return False
                    End If
                End If
                
            ' Stop
                'Dim OffsetY2 As Long
                SetWindowOrgEx(hdc, 0, -CLng(OffsetY), vbNullPtr)       ' Could use OffsetY2 instead as that works
                        
                'If Section.SectionType = PageFooter Then
                '    Debug.Print "MetaRendering FOOTER at (0," & OffsetY & ")"
                'End If
                
                'Dim sourceRect As WinNativeFormsBASE.RECT
                'sourceRect.Right = CLng(zoomedPageWidthWithoutMargins * 10000)       ' FIXME watch we don't overflow * 10000)       ' FIXME watch we don't overflow
                'sourceRect.Bottom = CLng(zoomedPageHeightWithoutMargins * 10000)
                Dim scaleX As Double = (.MetaFileHeader.szlMicrometers.cx / .MetaFileHeader.szlDevice.cx) / 10
                Dim scaleY As Double = (.MetaFileHeader.szlMicrometers.cy / .MetaFileHeader.szlDevice.cy) / 10
                        
                ' SetWindowOrgEx(hdc, -PreviewPageBorderWidth, -PreviewPageBorderWidth, vbNullPtr)
                        
                Dim topBorderHeight As Long = 0 'CLng(Section.TopBorderHeight * DpiScaleFactorY)
                Dim mainHeight As Long = CLng(Section.PixelsHeight * DpiScaleFactorY)
                Dim bottomBorderHeight As Long = CLng(Section.PixelsBorderBottomHeight * DpiScaleFactorY)
                Dim sectionHeight As Any = topBorderHeight + mainHeight + bottomBorderHeight
                
                Dim sourceRect As WinNativeFormsBASE.RECT
                sourceRect.Right = CLng(10000000 / scaleX) 'CLng((Me.PixelsWidth * DpiScaleFactorX) / scaleX)
                sourceRect.Bottom = CLng(10000000 / scaleY) 'CLng((Me.PixelsHeight * DpiScaleFactorY) / scaleY)
                        
                'Debug.Print "AvailableHeight: " & AvailableHeight
                
                sourceRect.Top = -.OffsetY
                Dim savedDcIndex2 As Long = SaveDC(hdc)
                Dim remainingRenderHeight As Any = .Height - .OffsetY
                
                'sourceRect.Top += OffsetY2
                'sourceRect.Bottom += OffsetY2
                
                IntersectClipRect(hdc, 0, 0, CLng(Width), AvailableHeight)
                
                'Stop
                RuntimePatchGetClipBoxForHdc(hdc)
                PlayEnhMetaFile(hdc, .MetaFile, sourceRect)
                RuntimePatchGetClipBoxForHdc(vbNullPtr)
                
                RestoreDC(hdc, savedDcIndex2)
                
                If remainingRenderHeight > AvailableHeight Then
                    .OffsetY += AvailableHeight
                    OffsetY += AvailableHeight
                    AvailableHeight = 0
                    .RenderComplete = False
                    Return False
                Else
                    OffsetY += remainingRenderHeight
                    AvailableHeight -= remainingRenderHeight
                    
                    If Section.ShouldForceBreakAfter() Then
                        .PendingPageBreak = True
                        .RenderComplete = False
                        Return False
                    Else
                        DeleteEnhMetaFile(.MetaFile)
                        .MetaFile = vbNullPtr
                        .RenderComplete = True
                        Return True
                    End If
                                    
                End If
                
            End With
            
        End Function
        
        [Serialize(False)]
        Private InternalRecordset As ITbRecordset

        [Serialize(False)]
        Public Property Get Recordset() As Object
            Return InternalRecordset
        End Property
        
        [Serialize(False)]
        Public Property Set Recordset(Value As Object)
            If TypeOf Value Is ITbRecordset Then
                Set InternalRecordset = CType(Of ITbRecordset)(Value)
            Else
                Set InternalRecordset = New ExpressionGenericRecordsetWrapper(Value)
            End If
        End Property

        [Description("Returns/sets the amount by which the ZoomPercent is increased/decreased when the +/- buttons are pressed on the preview toolbar")]
        Public ZoomStep As Long = 10
        
        Private moveFirstButtonRect As WinNativeFormsBASE.RECT
        Private movePrevButtonRect As WinNativeFormsBASE.RECT
        Private moveNextButtonRect As WinNativeFormsBASE.RECT
        Private moveLastButtonRect As WinNativeFormsBASE.RECT
        Private zoomOutButtonRect As WinNativeFormsBASE.RECT
        Private zoomInButtonRect As WinNativeFormsBASE.RECT
        Private zoomTextRect As WinNativeFormsBASE.RECT
        Private printButtonRect As WinNativeFormsBASE.RECT
        Private activebutton As Long
        Private hoverbutton As Long
        
        Const TOOLBARPADDINGY As Long = 5
        Const TOOLBARHEIGHT As Long = 18
        Const TOOLBARPADDINGX As Long = 6
        Const RECORDSELECTORSWIDTH As Long = 140
        Const ZOOMCONTROLSWIDTH As Long = 80
        Const PRINTBUTTONWIDTH As Long = 30
        
        Private Sub HandleButtonPressed(ByVal buttonId As Long)
            Select Case buttonId
                Case 1: 
                    Page = 1
                    Me.RefreshNoErase()
                Case 2: 
                    If (Page > 1) Then Page -= 1
                    Me.RefreshNoErase()
                Case 3: 
                    If CurrentPageIsLast = False Then
                    Page += 1
                        Me.RefreshNoErase()
                    End If
                Case 4: 
                    Page = -1
                    Me.RefreshNoErase()
                Case 5:
                    ZoomPercent -= ZoomStep
                    ZoomAutoFit = vbZoomAutoFitNever
                    If ZoomPercent < 0 Then ZoomPercent = 0
                    ResyncScrollBars()
                    Me.RefreshNoErase()
                Case 6:
                    ZoomPercent += ZoomStep
                    ZoomAutoFit = vbZoomAutoFitNever
                    ResyncScrollBars()
                    Me.RefreshNoErase()
                Case 7:
                    Me.PrintReport(False)
                End Select
            Exit Sub
        End Sub
        
        Private Sub HandleMouseUp(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single) _
                Handles RootWindowElement.MouseUp
                
            WinNativeFormsBASE.ReleaseCapture()
            RaiseEvent MouseUp(CInt(Button), CInt(ShiftState), X, Y)
            UpdateHoverButton(X, Y)
            If activebutton = hoverbutton Then
                HandleButtonPressed(activebutton)
            End If
            Dim buttonReleased As Long = activebutton
            activebutton = 0
            RedrawButton(buttonReleased)
        End Sub
        
        Private Sub HandleMouseDown(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single) _
                Handles RootWindowElement.MouseDown
                
            If Button = vbLeftButton Then
                Dim xPixels As Long = CLng((X / Me.ControlContext.GetScaleModePixelsMultiplierX()) * Me.RootWindowElement.UnitPixelScale)
                Dim yPixels As Long = CLng((Y / Me.ControlContext.GetScaleModePixelsMultiplierY()) * Me.RootWindowElement.UnitPixelScale)
                ' in backwards drawing order
                If IsInSubRect(xPixels, yPixels, moveNextButtonRect) Then
                    activebutton = 3
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveNextButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, moveLastButtonRect) Then
                    activebutton = 4
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveLastButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, movePrevButtonRect) Then
                    activebutton = 2
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, movePrevButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, moveFirstButtonRect) Then
                    activebutton = 1
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveFirstButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, zoomOutButtonRect) Then
                    activebutton = 5
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, zoomOutButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, zoomInButtonRect) Then
                    activebutton = 6
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, zoomInButtonRect, 0)
                ElseIf IsInSubRect(xPixels, yPixels, printButtonRect) Then
                    activebutton = 7
                    WinNativeFormsBASE.InvalidateRect(Me.hWnd, printButtonRect, 0)
                End If
                WinNativeFormsBASE.SetCapture(Me.hWnd)
            End If
            RaiseEvent MouseDown(CInt(Button), CInt(ShiftState), X, Y)
        End Sub
        
        Private Sub UpdateHoverButton(ByVal X As Single, ByVal Y As Single)
            Dim xPixels As Long = CLng((X / Me.ControlContext.GetScaleModePixelsMultiplierX()) * Me.RootWindowElement.UnitPixelScale)
            Dim yPixels As Long = CLng((Y / Me.ControlContext.GetScaleModePixelsMultiplierY()) * Me.RootWindowElement.UnitPixelScale)
            ' in backwards drawing order
            Dim newHoverbutton As Long = 0
            If IsInSubRect(xPixels, yPixels, moveNextButtonRect) Then
                newHoverbutton = 3
            ElseIf IsInSubRect(xPixels, yPixels, moveLastButtonRect) Then
                newHoverbutton = 4
            ElseIf IsInSubRect(xPixels, yPixels, movePrevButtonRect) Then
                newHoverbutton = 2
            ElseIf IsInSubRect(xPixels, yPixels, moveFirstButtonRect) Then
                newHoverbutton = 1
            ElseIf IsInSubRect(xPixels, yPixels, zoomOutButtonRect) Then
                newHoverbutton = 5
            ElseIf IsInSubRect(xPixels, yPixels, zoomInButtonRect) Then
                newHoverbutton = 6
            ElseIf IsInSubRect(xPixels, yPixels, printButtonRect) Then
                newHoverbutton = 7
            End If
            
            If newHoverbutton <> hoverbutton Then
                RedrawButton(newHoverbutton)
                RedrawButton(hoverbutton)
                hoverbutton = newHoverbutton
            End If
        End Sub
        
        Private Sub RedrawButton(ByVal buttonId As Long)
            Select Case buttonId
                Case 1: WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveFirstButtonRect, 0)
                Case 2: WinNativeFormsBASE.InvalidateRect(Me.hWnd, movePrevButtonRect, 0)
                Case 3: WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveNextButtonRect, 0)
                Case 4: WinNativeFormsBASE.InvalidateRect(Me.hWnd, moveLastButtonRect, 0)
                Case 5: WinNativeFormsBASE.InvalidateRect(Me.hWnd, zoomOutButtonRect, 0)
                Case 6: WinNativeFormsBASE.InvalidateRect(Me.hWnd, zoomInButtonRect, 0)
                Case 7: WinNativeFormsBASE.InvalidateRect(Me.hWnd, printButtonRect, 0)
            End Select
        End Sub
        
        Private Sub HandleMouseMove(ByVal Button As VBRUN.MouseButtonConstants, _
                                        ByVal ShiftState As VBRUN.ShiftConstants, _
                                        ByVal X As Single, ByVal Y As Single) _
                Handles RootWindowElement.MouseMove
                
            UpdateHoverButton(X, Y)
            RaiseEvent MouseMove(CInt(Button), CInt(ShiftState), X, Y)
        End Sub
        
        Private Sub DrawToolbar(ByVal hdc As LongPtr, rect As WinNativeFormsBASE.RECT, ByVal IsFirst As Boolean, ByVal IsLast As Boolean)
            Dim rectCopy As WinNativeFormsBASE.RECT = rect
            WinNativeFormsBASE.FillRect(hdc, rectCopy, ToolbarBackBrush)
            
            rectCopy.Top += CLng(TOOLBARPADDINGY * DpiScaleFactorY)
            rectCopy.Bottom -= CLng(TOOLBARPADDINGY * DpiScaleFactorY)
            
            Dim recordSelectorRect As WinNativeFormsBASE.RECT = rectCopy
            recordSelectorRect.Right = CLng(RECORDSELECTORSWIDTH * DpiScaleFactorX)
            Dim xOffset As Long
            Dim areaWidth As Long = rect.Right - rect.Left
            Dim TOOLBARCONTENTWIDTH As Long = CLng(RECORDSELECTORSWIDTH * DpiScaleFactorX) + (CLng(TOOLBARPADDINGX * DpiScaleFactorX) * 2) + CLng(ZOOMCONTROLSWIDTH * DpiScaleFactorX) + (CLng(TOOLBARPADDINGX * DpiScaleFactorX) * 2) + CLng(PRINTBUTTONWIDTH * DpiScaleFactorX)
            
            If TOOLBARCONTENTWIDTH < areaWidth Then
                xOffset = (areaWidth - TOOLBARCONTENTWIDTH) \ 2
            Else
                xOffset = CLng(TOOLBARPADDINGX * Me.DpiScaleFactorX)
            End If
            recordSelectorRect.Left += xOffset
            recordSelectorRect.Right += xOffset
                                
            Dim ifont As IFont = [_BaseGraphics].Font
            Dim Text As String = CStr(Page)
            'Debug.Print "Drawing toolbar ", Text
            'WinNativeFormsBASE.USER32_FillRectangle(hdc, recordSelectorRect, backBrushWhite)
            
            DrawRecordSelectors(hdc, recordSelectorRect, WhiteBackBrush, activebutton, hoverbutton, IsFirst, IsLast, RootWindowElement.UnitPixelScale, moveFirstButtonRect, movePrevButtonRect, moveNextButtonRect, moveLastButtonRect, Text, ifont.hFont, vbBlack)
            
            recordSelectorRect.Left = recordSelectorRect.Right + (CLng(TOOLBARPADDINGX * DpiScaleFactorX) * 2)
            recordSelectorRect.Right = recordSelectorRect.Left + CLng(ZOOMCONTROLSWIDTH * DpiScaleFactorX)
            DrawZoomSelectors(hdc, recordSelectorRect, WhiteBackBrush, activebutton, hoverbutton, RootWindowElement.UnitPixelScale, zoomOutButtonRect, zoomInButtonRect, zoomTextRect, CLng(Me.ZoomPercent) & "%", ifont.hFont, vbBlack)
            'DrawRecordSelectors(hdc, recordSelectorRect, backBrushWhite, activebutton, hoverbutton, IsFirst, IsLast, RootWindowElement.UnitPixelScale, moveFirstButtonRect, movePrevButtonRect, moveNextButtonRect, moveLastButtonRect, "100%", ifont.hFont, vbBlack)            

            recordSelectorRect.Left = recordSelectorRect.Right + (CLng(TOOLBARPADDINGX * DpiScaleFactorX) * 2)
            recordSelectorRect.Right = recordSelectorRect.Left + CLng(PRINTBUTTONWIDTH * DpiScaleFactorX)
            DrawPrintButton(hdc, recordSelectorRect, WhiteBackBrush, activebutton, hoverbutton, RootWindowElement.UnitPixelScale, printButtonRect)
        End Sub
        
        Private CachedPages As Collection       ' holds ReportPage objects
        
        [Serialize(False)]
        Public Page As Long
        [Serialize(False)]
        Public Pages As Long
        
        [Serialize(False)]
        Public RecordNum As Long
        
        Private CurrentPageIsLast As Boolean
        
        Private Function CreateMetaFileForReportPage(ByVal pageNum As Long) As ReportPage
            'Debug.Print "Caching page: " & pageNum
            
            
            Dim actualHeight As Double = [_BaseGraphics].ScaleY(CSng(PixelsReportHeight), vbScaledPixels, vbPixels)
            Dim width As Double = [_BaseGraphics].ScaleX(CSng(PixelsReportWidth), vbScaledPixels, vbPixels)
            
            ' FIXME we don't want this to actually change the width of the viewer window
            ' but we currently have to do this for all the control drawing to work correctly
            'Dim oldWidth As Any = Me.Width
            'Me.Width = width
            'Sleep(1000)
            
            Dim sourceRect As WinNativeFormsBASE.RECT
            sourceRect.Right = CLng(width * 10000)       ' FIXME watch we don't overflow
            sourceRect.Bottom = CLng(actualHeight * 10000)
                    
            'Dim metaDC As LongPtr = CreateEnhMetaFileW(referenceDC, vbNullString, sourceRect, vbNullString)
            Dim metaDC As LongPtr = CreateEnhMetaFileW(vbNullPtr, vbNullString, sourceRect, vbNullString)
                    
            Dim DetailSection As ControlsSection
            Dim ReportHeaderSection As ControlsSection
            Dim ReportFooterSection As ControlsSection
            Dim PageHeaderSection As ControlsSection
            Dim PageFooterSection As ControlsSection
                    
            Dim Section As ControlsSection
            Dim SectionOrdinal As Long = 0
            For Each Section In InternalControlSections
                Select Case Section.SectionType
                    Case Detail: Set DetailSection = Section
                    Case ReportHeader: Set ReportHeaderSection = Section
                    Case ReportFooter: Set ReportFooterSection = Section
                    Case PageHeader: Set PageHeaderSection = Section
                    Case PageFooter: Set PageFooterSection = Section
                End Select
                Section.CachedOrdinal = SectionOrdinal
                SectionOrdinal += 1
            Next
                    
            Dim yOffset As Double
            
            'Debug.Print "Caching page: " & pageNum & " *** 1"
            EvaluateExpressions()
            
            Dim AvailableHeight As Long = CLng(actualHeight)
            Dim pageHeaderHeight As Long = PageHeaderSection.CalcTotalHeight(DpiScaleFactorY)
            Dim pageFooterHeight As Long = PageFooterSection.CalcTotalHeight(DpiScaleFactorY)
            
            'Debug.Print "*** AVAILABLE HEIGHT: " & AvailableHeight
            'Debug.Print "*** pageFooterHeight: " & pageFooterHeight
            
            ' At a minimum, we must be able to fit the page header and footer on a page
            If (pageHeaderHeight + pageFooterHeight) > AvailableHeight Then
                MessageBoxW(vbNullPtr, "Sections do not fit vertically on the page", "twinBASIC Report error", 0&)
                'Err.Raise 5, , "Sections do not fit vertically on the page"                'MsgBox "Sections do not fit vertically on the page"
            End If
            
            AvailableHeight -= pageFooterHeight
            Dim pageFooterOffset As Double = AvailableHeight
            
            With CType(Of SectionRenderState)(ReportHeaderSection.GetRenderStatePtr())
                If .RenderComplete = False Then
                    If .MetaFile = vbNullPtr Then
                        DrawSection(ReportHeaderSection, width)
                    End If
                    RenderSection(ReportHeaderSection, metaDC, yOffset, AvailableHeight, True)
                End If

                'Debug.Print "Caching page: " & pageNum & " *** 2"
                        
                ' Only draw the page header once the report header has been fully output
                ' If the report header is split over multiple pages, the page header only starts being output on pages AFTER the report header is completely rendered (matches MS ACCESS)
            
                If .RenderComplete = True Then
                    DrawSection(PageHeaderSection, width)
                    RenderSection(PageHeaderSection, metaDC, yOffset, AvailableHeight, True)
                End If
                
                Dim HeaderSectionRenderComplete As Any = .RenderComplete
            End With
            
            
            ' Draw the page footer
            DrawSection(PageFooterSection, width)
            RenderSection(PageFooterSection, metaDC, pageFooterOffset, CLng(pageFooterHeight), True)
                  
            
            'Debug.Print "Caching page: " & pageNum & " *** 3"
            
            If HeaderSectionRenderComplete = True Then
                Dim ItemsOnPage As Long
                
                With CType(Of SectionRenderState)(DetailSection.GetRenderStatePtr())
                    If .RenderComplete = False Then
                        If .MetaFile <> vbNullPtr Then
                            'Stop
                            If RenderSection(DetailSection, metaDC, yOffset, AvailableHeight, True) = False Then
                                ' the detail section has spanned multiple pages...
                                GoTo RenderPartialComplete
                            End If
                            ItemsOnPage += 1
                        End If
                    End If
                End With
                
                'Debug.Print "Caching page: " & pageNum & " *** 4"
                
                If InternalRecordset IsNot Nothing Then
                    While InternalRecordset.EOF = False
                        'Debug.Print "Got row: " & CurrentRowNum
                        EvaluateExpressions()
                        UpdateAggregates()
                        DrawSection(DetailSection, width)
                        InternalRecordset.MoveNext
                        RecordNum += 1
                        
                        'Stop
                        If RenderSection(DetailSection, metaDC, yOffset, AvailableHeight, ItemsOnPage = 0) = False Then
                            GoTo RenderPartialComplete
                        End If
                        ItemsOnPage += 1
                    Wend
                Else
                    If RecordNum = 1 Then
                        EvaluateExpressions()
                        DrawSection(DetailSection, width)
                        RecordNum += 1
                        
                        If RenderSection(DetailSection, metaDC, yOffset, AvailableHeight, ItemsOnPage = 0) = False Then
                            GoTo RenderPartialComplete
                        End If
                        ItemsOnPage += 1
                    End If
                End If
                
                'Debug.Print "Caching page: " & pageNum & " *** 5"
                
                With CType(Of SectionRenderState)(ReportFooterSection.GetRenderStatePtr())
                    If ((InternalRecordset Is Nothing) OrElse (InternalRecordset.EOF = True)) And (.RenderComplete = False) Then
                        If .MetaFile = vbNullPtr Then
                            DrawSection(ReportFooterSection, width)
                        End If
                        RenderSection(ReportFooterSection, metaDC, yOffset, AvailableHeight, ItemsOnPage = 0)
                    End If
                End With
            End If
            
        RenderPartialComplete:
            'Me.Width = oldWidth            
            'Debug.Print "Caching page: " & pageNum & " *** 6"
            
        DoneTest:
            Dim twipsPerPixelX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSX)
            Dim twipsPerPixelY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSY)
            
            Dim metaFile As LongPtr = CloseEnhMetaFile(metaDC)
            Return New ReportPage(pageNum, metaFile, ReportFooterSection.IsRenderComplete(), twipsPerPixelX, twipsPerPixelY)
        End Function
        
        Public ZoomPercent As Double = 100
        Public ZoomAutoFit As ZoomAutoFitConstants = vbZoomAutoFit
        Private FirstPaint As Boolean
        
        [Serialize(True, "ReportWidth")]
        Public PixelsReportWidth As Double = 300
        [Serialize(True, "ReportHeight")]
        Public PixelsReportHeight As Double = 900
                
        [Serialize(True, "LeftMargin")]
        Public PixelsLeftMargin As Double = 96 / 2.54    ' 1cm
        [Serialize(True, "RightMargin")]
        Public PixelsRightMargin As Double = 96 / 2.54    ' 1cm
        [Serialize(True, "TopMargin")]
        Public PixelsTopMargin As Double = 96 / 2.54    ' 1cm
        [Serialize(True, "BottomMargin")]
        Public PixelsBottomMargin As Double = 96 / 2.54    ' 1cm
        
        Const PreviewPageBorderWidthOuter As Long = 14
        Const PreviewPageBorderWidthInner As Long = 6
        Const PreviewPageBorderWidth As Long = PreviewPageBorderWidthOuter + PreviewPageBorderWidthInner
        
        Private CachedBufferBitmapWidth As Long
        Private CachedBufferBitmapHeight As Long
        Private CachedBufferHDC As LongPtr
        Private CachedBufferBitmap As LongPtr
        Private CachedBufferOrigBitmap As LongPtr
        
        Private Const BehindPageBackColor As Long = &H909090
        Private Const BehindPageBackColor2 As Long = &H101028
        Const ToolbarBackColor As Long = &HE0E0E0
        Private BehindPageBackBrush As LongPtr
        Private ScrollbarsBackBrush As LongPtr
        Private PaperBackBrush As LongPtr
        Private WhiteBackBrush As LongPtr
        Private ToolbarBackBrush As LongPtr
        Private PageOutlinePen As LongPtr
        Private GdiStuffPrepared As Boolean
        
        Private Sub DeleteCachedBufferBitmap()
            If CachedBufferHDC <> 0 Then
                WinNativeFormsBASE.SelectObject(CachedBufferHDC, CachedBufferOrigBitmap)
                WinNativeFormsBASE.DeleteObject(CachedBufferBitmap)
                WinNativeFormsBASE.DeleteObject(CachedBufferHDC)
                CachedBufferHDC = 0
            End If
        End Sub
        
        Private Sub RecreateCachedBufferBitmap()
            DeleteCachedBufferBitmap
            CachedBufferBitmapWidth = RootWindowElement.CurrentWidth
            CachedBufferBitmapHeight = RootWindowElement.CurrentHeight
            Dim screenDC As LongPtr = WinNativeFormsBASE.GetDC(0)
            CachedBufferHDC = WinNativeFormsBASE.CreateCompatibleDC(screenDC)
            CachedBufferBitmap = WinNativeFormsBASE.CreateCompatibleBitmap(screenDC, RootWindowElement.CurrentWidth, RootWindowElement.CurrentHeight)
            CachedBufferOrigBitmap = WinNativeFormsBASE.SelectObject(CachedBufferHDC, CachedBufferBitmap)
            WinNativeFormsBASE.ReleaseDC(0, screenDC)
        End Sub
                         
        Private Sub PrepareGdiStuff()
            BehindPageBackBrush = WinNativeFormsBASE.GDI32_CreateSolidBrushColor(BehindPageBackColor)
            ScrollbarsBackBrush = WinNativeFormsBASE.GDI32_CreateSolidBrushColor(TranslateColor(vbScrollBars))
            WhiteBackBrush = WinNativeFormsBASE.GDI32_CreateSolidBrushColor(vbWhite)
            ToolbarBackBrush = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(ToolbarBackColor)
            PageOutlinePen = GDI32_CreatePen(PS_SOLID, 1, vbBlack)
            PaperBackBrush = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(TranslateColor(PaperColor))
            GdiStuffPrepared = True
        End Sub
        
        Private Sub PreviewPaperColorChanged() _
                Handles PaperColor.OnPropertyLet

            If GdiStuffPrepared Then
                WinNativeFormsBASE.DeleteObject(PaperBackBrush)
                PaperBackBrush = WinNativeFormsBASE.WindowsAPI.GDI32_CreateSolidBrushColor(TranslateColor(PaperColor))
            End If
        End Sub
        
        Private Sub ReleaseGdiStuff()
            If GdiStuffPrepared = True Then
                WinNativeFormsBASE.DeleteObject(BehindPageBackBrush)
                WinNativeFormsBASE.DeleteObject(ScrollbarsBackBrush)
                WinNativeFormsBASE.DeleteObject(WhiteBackBrush)
                WinNativeFormsBASE.DeleteObject(ToolbarBackBrush)
                WinNativeFormsBASE.DeleteObject(PageOutlinePen)
                WinNativeFormsBASE.DeleteObject(PaperBackBrush)
            End If
            GdiStuffPrepared = False
            
            Dim Section As ControlsSection
            Dim SectionOrdinal As Long = 0
            For Each Section In InternalControlSections
                Section.ReleaseGdiStuff()
            Next
        End Sub
        
        Private AlreadyPainting As Boolean
        
        Private Function GetCachedPageByCurrentPageNum() As ReportPage
            While (CachedPages.Count < Page) Or (Page = -1)
                If (CachedPages.Count > 0) Then
                    With CType(Of ReportPage)(CachedPages.Item(CachedPages.Count))
                        If .IsLastPage Then
                            Page = .PageNumber
                            Exit While
                        End If
                    End With
                End If
                        
                Dim pageNum As Long = CachedPages.Count + 1
                CachedPages.Add(CreateMetaFileForReportPage(pageNum))
                'Debug.Print "CachedPages.Count AFTER adding: " & CachedPages.Count
            Wend
                    
            Return CType(Of ReportPage)(CachedPages.Item(Page))
        End Function
        
        Private Sub PrintSinglePageViewer(ByVal hdc As LongPtr)
            ' We're printing one specific page.
            'Debug.Print "PRINTING -- CurrentPageNum: " & Page & ", CachedPages.Count: " & CachedPages.Count
            Dim CachedReportPage As Any = GetCachedPageByCurrentPageNum()
                    
            CurrentPageIsLast = CachedReportPage.IsLastPage
                    
            If (CachedReportPage.MetaFile = 0) Then
                Err.Raise 5     ' invalid
            End If
                    
            Dim TOOLBARPADDEDHEIGHT As Long = CLng(TOOLBARHEIGHT * DpiScaleFactorY) + CLng(TOOLBARPADDINGY * DpiScaleFactorY) * 2
                    
            Dim actualHeight As Long = CLng(RootWindowElement.CurrentHeight - TOOLBARPADDEDHEIGHT)
            Dim actualWidth As Long = RootWindowElement.CurrentWidth
                    
            Dim toolbarRect As WinNativeFormsBASE.RECT
            toolbarRect.Left = 0
            toolbarRect.Right = actualWidth
            toolbarRect.Top = actualHeight
            toolbarRect.Bottom = RootWindowElement.CurrentHeight
            DrawToolbar(hdc, toolbarRect, Page = 1, CachedReportPage.IsLastPage)
                    
            Dim borderRect As WinNativeFormsBASE.RECT
                    
            Dim scrollX As Long
            Dim scrollY As Long

            Dim pixWidth As Any = [_BaseGraphics].ScaleX(CSng(PixelsReportWidth), vbScaledPixels, vbPixels)
            Dim pixHeight As Any = [_BaseGraphics].ScaleY(CSng(PixelsReportHeight), vbScaledPixels, vbPixels)
                    
            Dim leftMarginWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsLeftMargin), vbScaledPixels, vbPixels)
            Dim rightMarginWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsRightMargin), vbScaledPixels, vbPixels)
            Dim topMarginWidth As Double = [_BaseGraphics].ScaleY(CSng(PixelsTopMargin), vbScaledPixels, vbPixels)
            Dim bottomMarginWidth As Double = [_BaseGraphics].ScaleY(CSng(PixelsBottomMargin), vbScaledPixels, vbPixels)
                    
            Dim marginsWidth As Double = leftMarginWidth + rightMarginWidth
            Dim pixWidthWithoutMargins As Double = pixWidth
            pixWidth += CSng(marginsWidth)
                    
            Dim marginsHeight As Double = topMarginWidth + bottomMarginWidth
            Dim pixHeightWithoutMargins As Double = pixHeight
            pixHeight += CSng(marginsHeight)
                    
            If (ZoomAutoFit = vbZoomAutoFit) OrElse ((ZoomAutoFit = vbZoomAutoFitOnce) And FirstPaint) Then
                ' Update the ZoomPercent so that the page will be fully visible with no scrollbars
                Dim autoZoomPercentWidth As Double = (actualWidth - (PreviewPageBorderWidth * 2)) / pixWidth
                Dim autoZoomPercentHeight As Double = (actualHeight - (PreviewPageBorderWidth * 2)) / pixHeight
                If autoZoomPercentWidth < autoZoomPercentHeight Then
                    ZoomPercent = autoZoomPercentWidth * 100
                Else
                    ZoomPercent = autoZoomPercentHeight * 100
                End If
                ResyncScrollBars()
                Dim zoomPercentAdjust As Long
                While ScrollBarsVisible And (zoomPercentAdjust < 10)
                    'Debug.Print "ZoomPercent adjustment " & zoomPercentAdjust
                    ZoomPercent -= 0.1
                    ResyncScrollBars()
                    zoomPercentAdjust += 1
                Wend
                
                WinNativeFormsBASE.InvalidateRect(Me.hWnd, zoomTextRect, 1)
            End If
            FirstPaint = False

            Dim zoomedPageWidthWithoutMargins As Long = ((pixWidthWithoutMargins * ZoomPercent) \ 100)
            Dim zoomedPageHeightWithoutMargins As Long = ((pixHeightWithoutMargins * ZoomPercent) \ 100)
                    
            Dim zoomedPageWidth As Long = ((pixWidth * ZoomPercent) \ 100)
            Dim zoomedPageHeight As Long = ((pixHeight * ZoomPercent) \ 100)
            Dim zoomedPageWidthWithPadding As Long = zoomedPageWidth + (PreviewPageBorderWidth * 2)
            Dim zoomedPageHeightWithPadding As Long = zoomedPageHeight + (PreviewPageBorderWidth * 2)
                                        
            If Me.ScrollBarsVisible Then
                scrollX = WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollH, WinNativeFormsBASE.SB_CTL)
                scrollY = WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollV, WinNativeFormsBASE.SB_CTL)
                        
                Dim scrollSizeX As Long = CLng(16 * Me.DpiScaleFactorX)
                Dim scrollSizeY As Long = CLng(16 * Me.DpiScaleFactorY)
                actualWidth -= scrollSizeX
                actualHeight -= scrollSizeY
                        
                ' We must fill the bottom right corner square
                borderRect.Left = actualWidth
                borderRect.Top = actualHeight
                borderRect.Right = actualWidth + scrollSizeX
                borderRect.Bottom = actualHeight + scrollSizeY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, ScrollbarsBackBrush)
            End If
                    
            'zoomedPageWidth += CLng(leftMarginWidth * ZoomPercent / 100) + CLng(rightMarginWidth * ZoomPercent / 100)
            'zoomedPageWidthWithPadding += CLng(leftMarginWidth * ZoomPercent / 100) + CLng(rightMarginWidth * ZoomPercent / 100)
            Dim marginX As Any = -CLng(leftMarginWidth * ZoomPercent / 100)
            Dim marginY As Any = -CLng(topMarginWidth * ZoomPercent / 100)
                                        
                    
            If zoomedPageWidthWithPadding < actualWidth Then
                ' adjust scrollX to make it centered
                Dim offsetX As Long = (actualWidth - zoomedPageWidthWithPadding) \ 2
                borderRect.Left = 0
                borderRect.Top = 0
                borderRect.Right = offsetX
                borderRect.Bottom = actualHeight
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                borderRect.Left = offsetX + zoomedPageWidthWithPadding
                borderRect.Right = actualWidth
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                scrollX -= offsetX
            End If
            If zoomedPageHeightWithPadding < actualHeight Then
                ' adjust scrollY to make it centered
                Dim offsetY As Long = (actualHeight - zoomedPageHeightWithPadding) \ 2
                borderRect.Left = 0
                borderRect.Top = 0
                borderRect.Right = actualWidth
                borderRect.Bottom = offsetY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                borderRect.Top = offsetY + zoomedPageHeightWithPadding
                borderRect.Bottom = actualHeight
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                scrollY -= offsetY
            End If
                                        
                    
                                
            Dim dcSaveIndex As Long = SaveDC(hdc)
                            
            IntersectClipRect(hdc, 0, 0, actualWidth, actualHeight)
                    
            'Debug.Print "zoomedPageWidth: ", zoomedPageWidth
            If zoomedPageWidth = 0 Or zoomedPageHeight = 0 Then
                borderRect.Left = 0
                borderRect.Top = 0
                borderRect.Right = actualWidth
                borderRect.Bottom = actualHeight
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
            Else
                ' TOP SIDE BORDER
                borderRect.Left = -scrollX
                borderRect.Top = -scrollY
                borderRect.Right = zoomedPageWidthWithPadding - scrollX
                borderRect.Bottom = PreviewPageBorderWidthOuter - scrollY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                borderRect.Left = PreviewPageBorderWidthOuter - scrollX
                borderRect.Top = PreviewPageBorderWidthOuter - scrollY
                borderRect.Right = (zoomedPageWidthWithPadding - PreviewPageBorderWidthOuter) - scrollX
                borderRect.Bottom = (PreviewPageBorderWidth - scrollY)
                GradientFillRect(hdc, borderRect, BehindPageBackColor, BehindPageBackColor2, True)
                        
                ' BOTTOM SIDE BORDER
                borderRect.Top = (zoomedPageHeightWithPadding - PreviewPageBorderWidth) - scrollY
                borderRect.Bottom = (zoomedPageHeightWithPadding - PreviewPageBorderWidthOuter) - scrollY
                GradientFillRect(hdc, borderRect, BehindPageBackColor2, BehindPageBackColor, True)
                borderRect.Left = -scrollX
                borderRect.Top = (zoomedPageHeightWithPadding - PreviewPageBorderWidthOuter) - scrollY
                borderRect.Right = zoomedPageWidthWithPadding - scrollX
                borderRect.Bottom = zoomedPageHeightWithPadding - scrollY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                                            
                Dim i As Long
                While i < PreviewPageBorderWidth
                    ExcludeClipRect(hdc, i - scrollX, i - scrollY, PreviewPageBorderWidth - scrollX, (i + 1) - scrollY)
                    ExcludeClipRect(hdc, ((zoomedPageWidthWithPadding - i) - PreviewPageBorderWidth) - scrollX, i - scrollY, (zoomedPageWidthWithPadding - i) - scrollX, (i + 1) - scrollY)
                    ExcludeClipRect(hdc, i - scrollX, ((zoomedPageHeightWithPadding - i) - 1) - scrollY, PreviewPageBorderWidth - scrollX, (zoomedPageHeightWithPadding - i) - scrollY)
                    ExcludeClipRect(hdc, ((zoomedPageWidthWithPadding - i) - PreviewPageBorderWidth) - scrollX, ((zoomedPageHeightWithPadding - i) - 1) - scrollY, (zoomedPageWidthWithPadding - i) - scrollX, (zoomedPageHeightWithPadding - i) - scrollY)
                    i += 1
                Wend
                        
                ' LEFT SIDE BORDER
                borderRect.Left = -scrollX
                borderRect.Top = -scrollY
                borderRect.Right = PreviewPageBorderWidthOuter - scrollX
                borderRect.Bottom = zoomedPageHeightWithPadding - scrollY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                borderRect.Left = PreviewPageBorderWidthOuter - scrollX
                borderRect.Top = -scrollY
                borderRect.Bottom = zoomedPageHeightWithPadding - scrollY
                borderRect.Right = PreviewPageBorderWidth - scrollX
                GradientFillRect(hdc, borderRect, BehindPageBackColor, BehindPageBackColor2, False)
                        
                ' ' RIGHT SIDE BORDER
                borderRect.Left = (zoomedPageWidthWithPadding - PreviewPageBorderWidth) - scrollX
                borderRect.Right = (zoomedPageWidthWithPadding - PreviewPageBorderWidthOuter) - scrollX
                GradientFillRect(hdc, borderRect, BehindPageBackColor2, BehindPageBackColor, False)
                borderRect.Left = (zoomedPageWidthWithPadding - PreviewPageBorderWidthOuter) - scrollX
                borderRect.Top = -scrollY
                borderRect.Right = zoomedPageWidthWithPadding - scrollX
                borderRect.Bottom = zoomedPageHeightWithPadding - scrollY
                WinNativeFormsBASE.USER32_FillRectangle(hdc, borderRect, BehindPageBackBrush)
                                    
                        
                ' Soften the corners
                'SetPixelV(hdc, PreviewPageBorderWidthOuter - 3, PreviewPageBorderWidthOuter - 3, vbRed)
                ' SetPixelV(hdc, PreviewPageBorderWidthOuter + 1, PreviewPageBorderWidthOuter, color1)
                ' SetPixelV(hdc, PreviewPageBorderWidthOuter, PreviewPageBorderWidthOuter + 1, color1)
                                            
                ' Draw a black border around the page
                Dim fillBrush As LongPtr = GDI32_GetStockObject(NULL_BRUSH)
                Dim oldPen As LongPtr = WinNativeFormsBASE.SelectObject(hdc, PageOutlinePen)
                Dim oldBrush As LongPtr = WinNativeFormsBASE.SelectObject(hdc, fillBrush)
                Dim pageXStart As Long = (PreviewPageBorderWidth - 1) - scrollX
                Dim pageYStart As Long = (PreviewPageBorderWidth - 1) - scrollY
                GDI32_Rectangle(hdc, pageXStart, pageYStart, pageXStart + zoomedPageWidth + 2, pageYStart + zoomedPageHeight + 2)
                WinNativeFormsBASE.SelectObject(hdc, oldPen)
                WinNativeFormsBASE.SelectObject(hdc, oldBrush)
                        
                ' Fill the page with the back color
                        
                borderRect.Left = PreviewPageBorderWidth - scrollX
                borderRect.Top = PreviewPageBorderWidth - scrollY
                borderRect.Right = borderRect.Left + zoomedPageWidth
                borderRect.Bottom = borderRect.Top + zoomedPageHeight
                WinNativeFormsBASE.FillRect(hdc, borderRect, PaperBackBrush)
            End If
                    
            RestoreDC(hdc, dcSaveIndex)
            dcSaveIndex = SaveDC(hdc)
                    
            IntersectClipRect(hdc, (PreviewPageBorderWidth - scrollX), PreviewPageBorderWidth - scrollY, (PreviewPageBorderWidth - scrollX) + zoomedPageWidth - marginX, ((PreviewPageBorderWidth - scrollY) - marginY) + zoomedPageHeight)
            ExcludeClipRect(hdc, toolbarRect.Left, toolbarRect.Top, toolbarRect.Right, toolbarRect.Bottom)
                    
            If Me.ScrollBarsVisible Then
                ' the corner where the two scrollbars meet
                ExcludeClipRect(hdc, actualWidth, actualHeight, actualWidth + scrollSizeX, actualHeight + scrollSizeY)
            End If
                    
            ' In order to get PlayEnhMetaFile to play ball, we have to scale the RECT that we pass to it
            'Dim pageHeight As Double = Me.ScaleY(CSng(Me.PixelsReportHeight), vbScaledPixels, vbPixels) 'RootWindowElement.CurrentHeight - TOOLBARPADDEDHEIGHT
            'Dim pageWidth As Double = Me.ScaleX(CSng(Me.PixelsReportWidth), vbScaledPixels, vbPixels)
                    
            Dim info As ENHMETAHEADER
            GetEnhMetaFileHeader(CachedReportPage.MetaFile, LenB(Of ENHMETAHEADER), info)
                    
            'Debug.Print "device reference: " & info.szlDevice.cx & "x" & info.szlDevice.cy
            'Stop
            
            Dim sourceRect As WinNativeFormsBASE.RECT
            sourceRect.Right = CLng(zoomedPageWidthWithoutMargins * 10000)       ' FIXME watch we don't overflow * 10000)       ' FIXME watch we don't overflow
            sourceRect.Bottom = CLng(zoomedPageHeightWithoutMargins * 10000)
            Dim scaleX As Double = (info.szlMicrometers.cx / info.szlDevice.cx) / 10
            Dim scaleY As Double = (info.szlMicrometers.cy / info.szlDevice.cy) / 10
                    
            If ZoomPercent <> 100 Then
                Dim zoomFactor As Any = ZoomPercent / 100
                If zoomFactor = 0 Then
                    GoTo ZoomZero
                End If
            End If
                    
            SetWindowOrgEx(hdc, -PreviewPageBorderWidth + scrollX + marginX, -PreviewPageBorderWidth + scrollY + marginY, vbNullPtr)
                                        
            sourceRect.Right = CLng(sourceRect.Right / scaleX) 'CLng((Me.PixelsWidth * DpiScaleFactorX) / scaleX)
            sourceRect.Bottom = CLng(sourceRect.Bottom / scaleY) 'CLng((Me.PixelsHeight * DpiScaleFactorY) / scaleY)
                    
'                    Stop
            ' Dim resampleScale As Long = 8
            ' Dim hdcResample As LongPtr = WinNativeFormsBASE.CreateCompatibleDC(hdc)
            ' Dim hbmpResample As LongPtr = WinNativeFormsBASE.CreateCompatibleBitmap(hdc, RootWindowElement.CurrentWidth * resampleScale, RootWindowElement.CurrentHeight * resampleScale)
            ' Dim oldBitmapResample As LongPtr = WinNativeFormsBASE.SelectObject(hdcResample, hbmpResample)
            ' sourceRect.Right = CLng(sourceRect.Right * resampleScale)
            ' sourceRect.Bottom = CLng(sourceRect.Bottom * resampleScale)
            ' Const HALFTONE As Long = 4
            ' SetStretchBltMode(hdcResample, HALFTONE)
            ' SetWindowExtEx(hdcResample, RootWindowElement.CurrentWidth, RootWindowElement.CurrentHeight, vbNullPtr)
            ' SetViewportExtEx(hdcResample, RootWindowElement.CurrentWidth, RootWindowElement.CurrentHeight, vbNullPtr)
            ' PlayEnhMetaFile(hdcResample, CachedReportPage.MetaFile, sourceRect)
            ' StretchBlt(hdc, 0, 0, RootWindowElement.CurrentWidth, RootWindowElement.CurrentHeight, hdcResample, 0, 0, RootWindowElement.CurrentWidth * resampleScale, RootWindowElement.CurrentHeight * resampleScale, vbSrcCopy)
            ' WinNativeFormsBASE.SelectObject(hdcResample, oldBitmapResample)

            'sourceRect.Left = CLng(leftMarginWidth * ZoomPercent / 100)
            'sourceRect.Right += CLng(leftMarginWidth * ZoomPercent / 100)
                    
            'SetWindowOrgEx(hdc, 0, CLng(200), vbNullPtr)
            
            RuntimePatchGetClipBoxForHdc(hdc)
            PlayEnhMetaFile(hdc, CachedReportPage.MetaFile, sourceRect)
            RuntimePatchGetClipBoxForHdc(0)
            
        ZoomZero:
            RestoreDC(hdc, dcSaveIndex)
        End Sub
        
        'Private Declare PtrSafe Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long)
        Private Sub HandlePaint(ByRef Handled As Boolean) _
                Handles RootWindowElement.Paint
                
            If GdiStuffPrepared = False Then PrepareGdiStuff()
            If AlreadyPainting = True Then Exit Sub
            AlreadyPainting = True
        
            Dim RootWindowElement As Any = Me.RootWindowElement
            
            If IsInitialized = False Then InitializeMe
            Dim hdc As LongPtr
    
            Dim ps As WinNativeFormsBASE.PAINTSTRUCT
            RootWindowElement.BeginPaint(ps)    ' you MUST use this method, and NOT the BeginPaint API 
                                
                If RootWindowElement.IsIdeSnapshotting = False Then
                    
                    ' We use a buffer HDC to prevent flickering
                    If CachedBufferBitmapWidth < RootWindowElement.CurrentWidth Or _
                        CachedBufferBitmapHeight < RootWindowElement.CurrentHeight Then
                        RecreateCachedBufferBitmap
                    End If
                        
                    hdc = CachedBufferHDC
                    PrintSinglePageViewer(hdc)
                    WinNativeFormsBASE.BitBlt(ps.hdc, 0, 0, RootWindowElement.CurrentWidth, RootWindowElement.CurrentHeight, hdc, 0, 0, vbSrcCopy)
                Else
                    hdc = ps.hdc
                    Dim Section As Any = Me.InternalControlSections(RootWindowElement.GetDrawingSectionId)
                    With Section
                        
                        Section.CacheGdiStuff()
                        
                        If .BackStyle = vbBFOpaque Then
                            WinNativeFormsBASE.USER32_FillWithBrush(RootWindowElementBase, hdc, .CachedBackBrush)
                        Else
                            WinNativeFormsBASE.USER32_FillWithBrush(RootWindowElementBase, hdc, PaperBackBrush)
                        End If
                        Dim topBorderHeight As Long = 0'CLng(.TopBorderHeight * DpiScaleFactorY)
                        Dim mainHeight As Long = CLng(.PixelsHeight * DpiScaleFactorY)
                        Dim bottomBorderHeight As Long = CLng(.PixelsBorderBottomHeight * DpiScaleFactorY)
                        If topBorderHeight > 0 Then
                            Dim rect As WinNativeFormsBASE.RECT
                            rect.Right = RootWindowElement.CurrentWidth
                            rect.Bottom = topBorderHeight
                            'WinNativeFormsBASE.FillRect(hdc, rect, .CachedBorderTopBrush)
                        End If
                        If bottomBorderHeight > 0 Then
                            rect.Right = RootWindowElement.CurrentWidth
                            rect.Top = topBorderHeight + mainHeight
                            rect.Bottom = rect.Top + bottomBorderHeight
                            WinNativeFormsBASE.FillRect(hdc, rect, .CachedBorderBottomBrush)
                        End If
                        SetWindowOrgEx(hdc, 0, -topBorderHeight, vbNullPtr)
                        
                        Dim savedDcIndex As Long = SaveDC(hdc)
                        IntersectClipRect(hdc, 0, 0, CLng(RootWindowElement.CurrentWidth), mainHeight)
                        Me.[_BaseGraphics].OnPaint(hdc)
                        RestoreDC(hdc, savedDcIndex)
                        
                        SetWindowOrgEx(hdc, 0, 0, vbNullPtr)
                    End With
                End If
                
            RootWindowElement.EndPaint(ps)
            Handled = True     ' swallow up the event
            
            AlreadyPainting = False
        End Sub
                
        Private Declare PtrSafe Sub Sleep Lib "kernel32.dll" (ByVal dwMilliseconds As Long)
        
        Private Sub CanClose(ByRef Cancel As Integer) _
                Handles RootWindowElement.CanClose
            
            RaiseEvent Unload(Cancel)
            
            If Cancel = False Then
                ' FIXME this should be in HandleDestroy?
                With CType(Of ITwinBasicInternalClassSupport)(Me)
                    .OverrideDispatchHandler Nothing  ' this breaks the circular reference
                End With
                [_HiddenModule].ResetFirstMethodAccessFlag(Me)
            End If
        End Sub
        
        [Serialize(False)]
        Public Property Get DpiScaleFactorX() As Double ' exposed as X/Y for future 
            Return RootWindowElement.UnitPixelScale
        End Property
        
        [Serialize(False)]
        Public Property Get DpiScaleFactorY() As Double ' exposed as X/Y for future 
            Return RootWindowElement.UnitPixelScale
        End Property
        
        Friend Sub InternalRaiseResize()
            RaiseEvent Resize()
        End Sub

        Friend Sub InternalRaisePaint()
            'RaiseEvent Paint()
        End Sub
                
        [Serialize(False)]
        Public Property Get Count() As Long
            Return CLng(Me.Controls.Count)
        End Property
        
        Private Sub SyncOpacity() _ 
                Handles Opacity.OnPropertyLet, _
                        TransparencyKey.OnPropertyLet
            
            CommonSyncOpacity(Me.TransparencyKey, Me.Opacity, Me.hWnd)
        End Sub
        
        [Serialize(False)]
        Private InternalIcon As StdPicture
        
        [Serialize(False)]
        Public Property Get Icon() As StdPicture
            Return InternalIcon
        End Property

        Private Sub IconChanged()
            Dim InternalIcon As Any = Me.InternalIcon
            If (InternalIcon IsNot Nothing) AndAlso (InternalIcon.Type = vbPicTypeIcon) Then
                Const ICON_SMALL As Long = 0
                Const ICON_BIG As Long = 1
                Const ICON_SMALL2 As Long = 2
                WinNativeFormsBASE.SendMessageW(RootWindowElement.Handle, WinNativeFormsBASE.WM_SETICON, ICON_SMALL, InternalIcon.Handle)
            End If
        End Sub

        [Serialize(False)]
        Public Property Set Icon(Value As StdPicture)
            Set InternalIcon = Value
            IconChanged()
        End Property

        [Serialize(False)]
        Public Property Let Icon(Value As StdPicture)    ' Weirdly, VBx also implements the Let for this
            Set InternalIcon = Value
            IconChanged()
        End Property
        
        Public Sub Move(ByVal Left As Single, Optional ByVal Top As Variant, Optional ByVal Width As Variant, Optional ByVal Height As Variant)
            If InternalMove(Me, Left, Top, Width, Height) Then
                Me.ControlContext.ChangedPosition()
            End If
        End Sub
        
        Public Sub SetFocus()
            WinNativeFormsBASE.WindowsAPI.USER32_SetFocus(Me.RootWindowElement)
        End Sub
    
        [Enumerator]
        Public Function InternalEnumerator() As stdole.IUnknown     ' FIXME should not be exposed
            Return CallByDispId(Me.Controls, -4, vbGet)
        End Function
        
        Private Sub RootWindowElement_QueryUnload(Cancel As Integer, ByVal UnloadMode As Long) _
                Handles RootWindowElement.QueryUnload

            RaiseEvent QueryUnload(Cancel, CInt(UnloadMode))
        End Sub
        
        Private CurrentPaintingSectionDC As LongPtr
        
        [Serialize(False)]
        Public Property Get hDC() As LongPtr
            If CurrentPaintingSectionDC <> vbNullPtr Then
                Return CurrentPaintingSectionDC
            Else
                If Me.RootWindowElement IsNot Nothing Then
                    Return _BaseGraphics.hDC
                End If
            End If
        End Property
        
        Private Sub SetRootWindowElementScrollH_Scroll(ByVal ScrollType As Long, ByVal IsHorizontal As Boolean)
            If CommonHandleScroll(SetRootWindowElementScrollH, ScrollType, 1) Then
                'Debug.Print "ScrollH: " & WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollH, WinNativeFormsBASE.SB_CTL)
                Me.RefreshNoErase()
            End If
        End Sub
        
        Private Sub SetRootWindowElementScrollV_Scroll(ByVal ScrollType As Long, ByVal IsHorizontal As Boolean)
            If CommonHandleScroll(SetRootWindowElementScrollV, ScrollType, 1) Then
                'Debug.Print "ScrollV: " & WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollV, WinNativeFormsBASE.SB_CTL)
                Me.RefreshNoErase()
            End If
        End Sub
        
        Private Function CommonHandleScroll(WindowElement As WindowElement, ByVal ScrollType As Long, ByVal Scale As Long) As Boolean
            Dim OldValue As Long = WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(WindowElement, WinNativeFormsBASE.SB_CTL)
            Dim NewValue As Long
            Select Case ScrollType
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_TOP
                    NewValue = 0
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_BOTTOM
                    NewValue = 0
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEUP
                    NewValue = OldValue - Scale
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEDOWN
                    NewValue = OldValue + Scale
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_PAGEUP
                    NewValue = OldValue - WinNativeFormsBASE.WindowsAPI.USER32_GetScrollPageSize(WindowElement, WinNativeFormsBASE.SB_CTL)
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_PAGEDOWN
                    NewValue = OldValue + WinNativeFormsBASE.WindowsAPI.USER32_GetScrollPageSize(WindowElement, WinNativeFormsBASE.SB_CTL)
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_THUMBPOSITION
                    NewValue = OldValue
                Case WinNativeFormsBASE.SCROLLNOTIFY.SB_THUMBTRACK
                    NewValue = WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValueHot(WindowElement, WinNativeFormsBASE.SB_CTL)
                Case Else
                    Exit Function
            End Select
             
            If NewValue < 0 Then
                NewValue = 0
            End If

            ' If NewValue > RangeMax Then
            '     NewValue = RangeMax
            ' End If

            If NewValue <> OldValue Then
                WinNativeFormsBASE.WindowsAPI.USER32_SetScrollValue(WindowElement, NewValue, WinNativeFormsBASE.SB_CTL)
                Return True
            End If
            Return False
        End Function
        
        Private Sub RootWindowElement_MouseWheel(ByVal Delta As Integer, ByVal Horizontal As Boolean)
            If Me.ScrollBarsVisible = False Then Exit Sub
            Dim ScrollType As Long
            If Horizontal Then
                If Delta < 0 Then
                    ScrollType = WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEUP
                Else
                    ScrollType = WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEDOWN
                End If
                If CommonHandleScroll(SetRootWindowElementScrollH, ScrollType, 10) Then
                    'Debug.Print "ScrollH: " & WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollH, WinNativeFormsBASE.SB_CTL)
                    Me.RefreshNoErase()
                End If
            Else
                If Delta > 0 Then
                    ScrollType = WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEUP
                Else
                    ScrollType = WinNativeFormsBASE.SCROLLNOTIFY.SB_LINEDOWN
                End If
                If CommonHandleScroll(SetRootWindowElementScrollV, ScrollType, 10) Then
                    'Debug.Print "ScrollV: " & WinNativeFormsBASE.WindowsAPI.USER32_GetScrollValue(SetRootWindowElementScrollV, WinNativeFormsBASE.SB_CTL)
                    Me.RefreshNoErase()
                End If
            End If
        End Sub
        
        Private Sub RefreshNoErase()
            WinNativeFormsBASE.USER32_RedrawWindow(Me.RootWindowElementBase, 0, 0, WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_UPDATENOW)
        End Sub
        
        Private Sub RootWindowElement_Resize()
            If Me.FirstPaint = False Then
                Me.ResyncScrollBars
                Me.RefreshNoErase
            End If
        End Sub
        
        Enum ReportSizeConstants
            [ ]
            [A4 Portrait]
            [A4 Landscape]
            [A3 Portrait]
            [A3 Landscape]
            [A5 Portrait]
            [A5 Landscape]
            [Letter Portrait]
            [Letter Landscape]
            [Tabloid Portrait]
            [Tabloid Landscape]
            [Legal Portrait]
            [Legal Landscape]
            [Statement Portrait]
            [Statement Landscape]
            [Executive Portrait]
            [Executive Landscape]
        End Enum
        
        Public Property Get ChangePageSize() As ReportSizeConstants
            Return ReportSizeConstants.[ ]
        End Property
        
        Enum PageRangeConstants
            rptRangeAllPages = 0
            rptRangeFromTo = 1
        End Enum
        
        Public Sub PrintReport(Optional ShowDialog As Boolean = True, Optional Range As PageRangeConstants, Optional PageFrom As Long, Optional PageTo As Long)
            If ShowDialog = True Then
                Err.Raise 5, , "Not yet supported.  Use PrintReport(ShowDialog:=False)"
            End If
            
            ' FIXME page size is currently locked to A4, need to support the logic of selecting the most appropriate
            ' paper size as supported by the printer driver.
            
            'MsgBox "NOTE:"
            Printer.PaperSize = CInt(vbPRPSA4)
            'Printer.OutputFile = "Z:\test46.pdf"
            
            'MessageBoxW(vbNullPtr, "Printed: Microsoft Print To PDF (" & Printer.OutputFile & ")", "twinBASIC", 0&)
            MessageBoxW(vbNullPtr, "PLEASE NOTE: Printer papersize is currently locked to A4 in this beta edition of twinBASIC", "twinBASIC", 0&)
            
            Dim tbPrinter As ITwinBasicPrinter = CType(Of ITwinBasicPrinter)(Printer)
            Dim tbPrinter_GraphicsBase As Any = tbPrinter.PreparePrintForm()
            
            Page = 1
            Do
                If Page <> 1 Then
                    Printer.NewPage()
                End If
                
                Dim CachedReportPage As Any = GetCachedPageByCurrentPageNum()
                        
                CurrentPageIsLast = CachedReportPage.IsLastPage
                        
                If (CachedReportPage.MetaFile = 0) Then
                    Err.Raise 5     ' invalid
                End If
                
                Dim info As ENHMETAHEADER
                GetEnhMetaFileHeader(CachedReportPage.MetaFile, LenB(Of ENHMETAHEADER), info)
                        
                Dim actualHeight As Double = [_BaseGraphics].ScaleY(CSng(PixelsReportHeight), vbScaledPixels, vbTwips)
                Dim width As Double = [_BaseGraphics].ScaleX(CSng(PixelsReportWidth), vbScaledPixels, vbTwips)
                
                ' FIXME we don't want this to actually change the width of the viewer window
                ' but we currently have to do this for all the control drawing to work correctly
                'Dim oldWidth As Any = Me.Width
                'Me.Width = width
                'Sleep(1000)
                
                Dim sourceRect As WinNativeFormsBASE.RECT
                sourceRect.Right = CLng(width * 10000)       ' FIXME watch we don't overflow
                sourceRect.Bottom = CLng(actualHeight * 10000)
                        
                Dim destTwipsX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSX)
                Dim destTwipsY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSY)
                
                If (destTwipsX = 0) Or (destTwipsY = 0) Then
                Err.Raise 5     ' invalid
                End If
                
                ' was using CachedReportPage.MetaFileTwipsPerPixelX/Y here
                sourceRect.Right = CLng(sourceRect.Right * 10 / destTwipsX)
                sourceRect.Bottom = CLng(sourceRect.Bottom * 10 / destTwipsY)
                    
                Dim scaleX As Double = (info.szlMicrometers.cx / info.szlDevice.cx)
                Dim scaleY As Double = (info.szlMicrometers.cy / info.szlDevice.cy)
                
                'MsgBox scaleX & ":" & scaleY
                        
                Dim leftMarginWidth As Double = [_BaseGraphics].ScaleX(CSng(PixelsLeftMargin), vbScaledPixels, vbPixels)
                Dim topMarginWidth As Double = [_BaseGraphics].ScaleY(CSng(PixelsTopMargin), vbScaledPixels, vbPixels)
                
                ' adjust the left/top margin
                SetWindowOrgEx(Printer.hDC, -CLng(leftMarginWidth * CachedReportPage.MetaFileTwipsPerPixelX / destTwipsX), -CLng(topMarginWidth * CachedReportPage.MetaFileTwipsPerPixelY / destTwipsY), vbNullPtr)
                                            
                sourceRect.Right = CLng(sourceRect.Right / scaleX)
                sourceRect.Bottom = CLng(sourceRect.Bottom / scaleY)
                
                PlayEnhMetaFile(Printer.hDC, CachedReportPage.MetaFile, sourceRect)
                Page += 1
                
            Loop Until CurrentPageIsLast
            
            Printer.EndDoc()
            
            
            ' Dim sourceRect As WinNativeFormsBASE.RECT
            ' Dim sourceWND As LongPtr = RootWindowElementBase.Handle
            ' GetClientRect(sourceWND, sourceRect)
                
            ' FIXME using this to get the source LOGPIXELSX/Y
            ' Dim metaDC As LongPtr = CreateEnhMetaFileW(vbNullPtr, vbNullString, vbNullPtr, vbNullString)
            ' Dim sourceTwipsX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSX)
            ' Dim sourceTwipsY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(metaDC, LOGPIXELSY)
            
            
            ' Dim destTwipsX As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSX)
            ' Dim destTwipsY As Double = 1440 / WinNativeFormsBASE.GetDeviceCaps(CLngPtr(Printer.hDC), LOGPIXELSY)
                
            ' If (destTwipsX = 0) Or (destTwipsY = 0) Then
            '     Err.Raise 5     ' invalid
            ' End If
        
            ' Dim metaFile As LongPtr = CloseEnhMetaFile(metaDC)
                                
            ' If (metaFile = 0) Then
            '     Err.Raise 5     ' invalid
            ' End If
        
            ' Dim sourceRect As WinNativeFormsBASE.RECT
            ' sourceRect.Right = CLng(sourceRect.Right * sourceTwipsX / destTwipsX)
            ' sourceRect.Bottom = CLng(sourceRect.Bottom * sourceTwipsY / destTwipsX)
                
            ' If OutputAtCurrentPosition = True Then
            '     sourceRect.Left += CLng(tbPrinter_GraphicsBase.InternalCurrentX)
            '     sourceRect.Right += sourceRect.Left
            '     sourceRect.Top += CLng(tbPrinter_GraphicsBase.InternalCurrentY)
            '     sourceRect.Bottom += sourceRect.Top
            
            '     If tbPrinter_GraphicsBase.ScaleMode = ScaleModeConstants.vbUser Then
            '         sourceRect.Left += CLng(-tbPrinter_GraphicsBase.ScaleLeft / destTwipsX)
            '         sourceRect.Top += CLng(-tbPrinter_GraphicsBase.ScaleTop / destTwipsX)
            '     End If
            ' End If
            
            
            'PlayEnhMetaFile(CLngPtr(Printer.hDC), metaFile, sourceRect)
            
            'DeleteEnhMetaFile(metaFile)
            
            'PrintSinglePage(CLngPtr(Printer.hDC))
        End Sub
        
        Private Function ITbCustomBinder_Bind(ByVal Symbol As String, ByVal ArgCount As Long) As ITbExpression
            If ArgCount = 0 Then
                ' See if the recordset exposes a field name Symbol
                If Me.InternalRecordset IsNot Nothing Then
                    Dim retVal As Object = Me.InternalRecordset.GetFieldBinder(Symbol)
                    If retVal IsNot Nothing Then
                        If TypeOf retVal Is ITbExpression Then
                            Return CType(Of ITbExpression)(retVal)
                        Else
                            Return New ObjectFieldBinderByName(retVal, Symbol)
                        End If
                    End If
                End If
            End If
        End Function
        
        [Serialize(False)]
        [Description("The minimum width of the CLIENT area, in twips")]
        Property Get MinWidth() As Double
            Return RootWindowElement.ScaleX(CSng(CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MinWidth), vbScaledPixels, vbTwips)
        End Property
        
        [Serialize(False)]
        [Description("The minimum width of the CLIENT area, in twips")]
        Property Let MinWidth(ByVal Value As Double)
            CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MinWidth = RootWindowElement.ScaleX(CSng(Value), vbTwips, vbScaledPixels)
        End Property
        
        [Serialize(False)]
        [Description("The minimum height of the CLIENT area, in twips")]
        Property Get MinHeight() As Double
            Return RootWindowElement.ScaleY(CSng(CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MinHeight), vbScaledPixels, vbTwips)
        End Property
        
        [Serialize(False)]
        [Description("The minimum height of the CLIENT area, in twips")]
        Property Let MinHeight(ByVal Value As Double)
            CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MinHeight = RootWindowElement.ScaleY(CSng(Value), vbTwips, vbScaledPixels)
        End Property
        
        [Serialize(False)]
        [Description("The maximum width of the CLIENT area, in twips")]
        Property Get MaxWidth() As Double
            Return RootWindowElement.ScaleX(CSng(CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MaxWidth), vbScaledPixels, vbTwips)
        End Property
        
        [Serialize(False)]
        [Description("The maximum width of the CLIENT area, in twips")]
        Property Let MaxWidth(ByVal Value As Double)
            CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MaxWidth = RootWindowElement.ScaleX(CSng(Value), vbTwips, vbScaledPixels)
        End Property
        
        [Serialize(False)]
        [Description("The maximum height of the CLIENT area, in twips")]
        Property Get MaxHeight() As Double
            Return RootWindowElement.ScaleY(CSng(CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MaxHeight), vbScaledPixels, vbTwips)
        End Property
        
        [Serialize(False)]
        [Description("The maximum height of the CLIENT area, in twips")]
        Property Let MaxHeight(ByVal Value As Double)
            CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).MaxHeight = RootWindowElement.ScaleY(CSng(Value), vbTwips, vbScaledPixels)
        End Property
        
        [Serialize(False)]
        Public Property Get Width() As Double
            Return CommonGetFormWidth(Me.RootWindowElement)
        End Property
    
        [Serialize(False)]
        Public Property Let Width(ByVal ValueTwips As Double)
            CommonSetFormWidth(Me.RootWindowElement, Me.InternalBaseControlInfoPtrX, Me.ControlContext, ValueTwips)
        End Property
    
        [Serialize(False)]
        Public Property Get Height() As Double
            Return CommonGetFormHeight(Me.RootWindowElement)
        End Property
    
        [Serialize(False)]
        Public Property Let Height(ByVal ValueTwips As Double)
            CommonSetFormHeight(Me.RootWindowElement, Me.InternalBaseControlInfoPtrX, Me.ControlContext, ValueTwips)
        End Property
        
        Private Sub Class_BeforeFirstMethodAccess()
            Debug.Print CurrentComponentName & "." & CurrentProcedureName
            [_HiddenModule].EnsureContainerIsLoaded(Me)
        End Sub
        
    #End Region
    
End Class