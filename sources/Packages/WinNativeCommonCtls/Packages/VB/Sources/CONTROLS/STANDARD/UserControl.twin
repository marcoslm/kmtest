Private Module UcInternalStateMod
    Type UcInternalState
        RootCLSID As String
        PropertiesChanged As Boolean
        OleClientSite As IOleClientSite
        ContainerWindow As LongPtr
        WindowIsInPlace As Boolean
        IsInitialized As Boolean
        IsInitialized1 As Boolean
        IsDesignMode As Boolean
        IsTbDebugging As Boolean
        MutedResizeEventsCount As Long
        InitialResizeEventFired As Boolean
        QueuedShowEvent As Boolean
        ConsumerVisibilityState As Boolean      ' as per Show/Hide events, which might be delayed due to FreezeEvents
        ActualVisibilityState As Boolean
        IsHandlingPaint As Boolean
        WindowlessRect As WinNativeFormsBASE.RECT
        IsWindowlessActivated As Boolean
                
        siteFrame As IOleInPlaceFrame
        siteDoc As IOleInPlaceUIWindow
        hasFocus As Boolean
        hasFocusOnChild As Boolean
        IViewObject_adviseSink As WinNativeFormsBASE.IAdviseSink
        IsClosed As Boolean
        _containerHwnd As LongPtr
        _oldParentHwnd As LongPtr
        
        IgnorePropertyChangedNotifications As Long
        HasFinishedLoading As Boolean
        _ExtentX As Double
        _ExtentY As Double
    End Type
    
    Public Sub ResetUcInternalState(InternalState As UcInternalState)
        Set InternalState.OleClientSite = Nothing
        Set InternalState.siteFrame = Nothing
        Set InternalState.siteDoc = Nothing
        Set InternalState.IViewObject_adviseSink = Nothing
        [_HiddenModule].MemZero(VarPtr(InternalState), LenB(InternalState))
    End Sub
End Module

[ComImport(True)]
[InterfaceId("974AF59D-5EA0-4D26-8CD0-5624E0A71134")]
Interface TbUserControlPrivate Extends stdole.IUnknown
    Property Get WindowlessRectLeft() As Long
    Property Get WindowlessRectTop() As Long
    Property Get WindowlessRectRight() As Long
    Property Get WindowlessRectBottom() As Long
    Function TranslateContainerXToHimetric(ByVal containerValue As Single) As Long
    Function TranslateContainerYToHimetric(ByVal containerValue As Single) As Long
    Function TranslateHimetricToContainerX(ByVal himetricValue As Long) As Single
    Function TranslateHimetricToContainerY(ByVal himetricValue As Long) As Single
End Interface

' FIXME this is just an empty implementation for now
[COMCreatable(False)]
[InterfaceId("6A55A6D1-C840-4E80-8961-0AAC322A3AFF")]
Private Class EmptyParentControls
    Implements ParentControls
    
    Private _ParentControlsType As ParentControlsType

    [Unimplemented]
    Private Property Get ParentControls_Count() As Long
        Return 0
    End Property
    
    [Unimplemented]
    Property Get ParentControls_Item(ByVal index As Long) As Object
    	Err.Raise 5
    End Property
    
    [Unimplemented]
    [Enumerator]
    Function ParentControls__NewEnum() As IUnknown Implements ParentControls.[_NewEnum]
        Return CallByDispId(New Collection, -4, vbGet)
    End Function
    
    [Unimplemented]
    Property Get ParentControls_ParentControlsType() As ParentControlsType
    	Return Me.[_ParentControlsType]
    End Property
    
    [Unimplemented]
    Property Let ParentControls_ParentControlsType(ByVal Value As ParentControlsType)
    	Me.[_ParentControlsType] = Value
    End Property

End Class

' FIXME this is just an empty implementation for now
[InterfaceId("DB4149A3-52DC-4EB2-B584-79FD7A0CDA46")]
Class EmptyContainedControls
	Implements ContainedControls
    
    [Unimplemented]
    Property Get ContainedControls_Count() As Long
    	Return 0
    End Property

    [Unimplemented]
    Property Get ContainedControls_Item(ByVal index As Long) As Object
    	Err.Raise 5
    End Property

    [Unimplemented]
    [Enumerator]
    Function _NewEnum() As IUnknown Implements ContainedControls.[_NewEnum]
    	Return CallByDispId(New Collection, -4, vbGet)
    End Function

End Class

' Host does NOT have to support AmbientProperties interface IID, so we have to use a passthru wrapper
[COMCreatable(False)]
[InterfaceId("0CCFCC46-8780-43A7-8AAD-70660FBFDAD7")]
Private Class AmbientPropertiesPassThru
	
    Implements AmbientProperties
    
    Private HostAmbient As Object
    
    Sub New(Host As Object)
    	Set HostAmbient = Host
    End Sub
    
    Private Function GetAmbientProp(ByVal dispatchID As Long, ByRef defaultValue As Variant) As Variant
        On Error Resume Next
        Dim retVal As Variant = CallByDispId(HostAmbient, dispatchID, VbCallType.vbMethod Or VbCallType.vbGet)
        If (Err.Number <> 0) OrElse (VarType(retVal) = vbEmpty) Then
            retVal = defaultValue
        End If
        Return retVal
    End Function
    
    Private Property Get BackColor() As stdole.OLE_COLOR Implements AmbientProperties.BackColor
    	Return CLng(GetAmbientProp(-701, &H80000005))     ' Same as VBx
    End Property
    
    Private Property Get DisplayName() As String Implements AmbientProperties.DisplayName
        Return CStr(GetAmbientProp(-702, ""))     ' Same as VBx
    End Property
    
    Private Property Get Font() As stdole.IFontDisp Implements AmbientProperties.Font
        Dim retVal As Variant = GetAmbientProp(-703, Nothing)     ' Same as VBx
        If retVal Is Nothing Then Set retVal = New StdFont
        Return CType(Of IFontDisp)(retVal)
    End Property

    Private Property Get ForeColor() As stdole.OLE_COLOR Implements AmbientProperties.ForeColor
        Return CLng(GetAmbientProp(-704, &H80000008))     ' Same as VBx
    End Property

    Private Property Get LocaleID() As Long Implements AmbientProperties.LocaleID
        Return CLng(GetAmbientProp(-705, &H809))     ' Same as VBx
    End Property

    Private Property Get MessageReflect() As Boolean Implements AmbientProperties.MessageReflect
        Return GetAmbientProp(-706, False)     ' Same as VBx
    End Property

    Private Property Get ScaleUnits() As String Implements AmbientProperties.ScaleUnits
        Return CStr(GetAmbientProp(-707, ""))     ' Same as VBx
    End Property

    Private Property Get TextAlign() As Integer Implements AmbientProperties.TextAlign
        Return CInt(GetAmbientProp(-708, 0))     ' Same as VBx
    End Property

    Private Property Get UserMode() As Boolean Implements AmbientProperties.UserMode
        Return GetAmbientProp(-709, True)     ' Same as VBx
    End Property

    Private Property Get UIDead() As Boolean Implements AmbientProperties.UIDead
        Return GetAmbientProp(-710, False)     ' Same as VBx
    End Property
    
    Private Property Get ShowGrabHandles() As Boolean Implements AmbientProperties.ShowGrabHandles
        Return GetAmbientProp(-711, True)     ' Same as VBx
    End Property
    
    Private Property Get ShowHatching() As Boolean Implements AmbientProperties.ShowHatching
        Return GetAmbientProp(-712, True)     ' Same as VBx
    End Property

    Private Property Get DisplayAsDefault() As Boolean Implements AmbientProperties.DisplayAsDefault
        Return GetAmbientProp(-713, False)     ' Same as VBx
    End Property

    Private Property Get SupportsMnemonics() As Boolean Implements AmbientProperties.SupportsMnemonics
        Return GetAmbientProp(-714, False)     ' Same as VBx
    End Property

    Private Property Get Palette() As stdole.IPictureDisp Implements AmbientProperties.Palette
        Dim retVal As Variant = GetAmbientProp(-726, Nothing)     ' Same as VBx
        If retVal Is Nothing Then
            ' If the host doesn't support Palette, VBx UserControl throws an error here...
            Err.Raise 5, , "ActiveX control does not support Palette ambient property"
        End If
        If retVal = 0 Then
            Return Nothing
        Else
            ' FIXME convert HPALETTE to StdPicture?
            Return Nothing
        End If
        Return CType(Of IPictureDisp)(retVal)
    End Property

    Private Property Get RightToLeft() As Boolean Implements AmbientProperties.RightToLeft
        Return GetAmbientProp(-732, False)     ' Same as VBx
    End Property
End Class

[WindowsControl("/miscellaneous/ICONS??/Frame??.png")]
[ClassId("33AD5010-6699-11CF-B70C-00AA0060D393")]
[InterfaceId("9D6977D6-0C4E-418D-A5F2-3AFFDB1F49A2")]    ' FIXME implement {33AD5011-6699-11CF-B70C-00AA0060D393} for backcompat
' WARNING: above InterfaceId is referred to as IID_ITBUserControl in tB Sources
[COMCreatable(False)]
[COMExtensible(True)]
[EventsUseDispInterface]
[ComImport(True)]
Class UserControl
          
    Enum VbClipBehavior
        vbClipNone = 0
        vbClipUseRegion = 1
    End Enum
    
    Enum VbDataBindingBehavior
        vbDataBindingNone = 0
        vbDataBindingSimple = 1
        vbDataBindingComplex = 2
    End Enum
    
    Enum VbDataSourceBehavior
        vbDataSourceNone = 0
        vbDataSource = 1
    End Enum
    
    Enum VbHitTestBehavior
        vbHitTestNone = 0
        vbHitTestUseRegion = 1
        vbHitTestPaint = 2
    End Enum
        
     #Region "INHERITANCE"
     
        Implements WindowsControls.IWindowsControl
        [ImplementsViaPrivateFriendlies] Implements WinNativeFormsBASE.BaseUserControl Via _BaseUserControl = New WinNativeFormsBASE.BaseUserControl
        [ImplementsViaPrivateFriendlies] Implements GraphicsBase Via _BaseGraphics = New GraphicsBase()
        [ImplementsViaPrivateFriendlies] Implements OLEDragDropHelper Via _BaseOLEDragDropHelper = New OLEDragDropHelper
        
        [WithDispatchForwarding] Implements Control
        Implements TbCommonContainerPrivate
        Implements TbUserControlPrivate
        Implements IOleObject
        Implements IPersistStreamInit
        Implements IPersist
        Implements IOleControl
        Implements IPersistStorage
        Implements IPersistPropertyBag
        Implements IProvideClassInfo
        Implements IViewObject
        Implements IOleInPlaceObject
        Implements ISpecifyPropertyPages
        Implements IPerPropertyBrowsing
        Implements IOleInPlaceActiveObject
        'Implements IQuickActivate              ' FIXME put this back on
        Implements IOleInPlaceObjectWindowless     ' FIXME only when Windowless = True
        Implements IViewObjectEx                   ' FIXME only when Windowless = True (for hittesting of transparent controls)
        Implements WinNativeFormsBASE.IScheduledCallback
        Implements IUnsupportedInterface
             
    #End Region
        
    #Region "STATE"
    
            Public ReadOnly ForceResizeToContainer As Boolean = False
            Public ReadOnly ControlContainer As Boolean = False
            'Public ReadOnly OverrideMiscStatus As Long = 0              
            
            Private WithEvents RootWindowElement As WindowsControls.WindowElement
            
            'Private IOleObject_SetClientSite_WasCalled As Boolean
            
            Private Const HWND_BOTTOM                       As Long = 1
            Private Const PW_CLIENTONLY                     As Long = &H00000001
            Private Const PW_RENDERFULLCONTENT              As Long = &H00000002
            Private Const MK_LBUTTON                        As Long = 1
            Private Const MK_RBUTTON                        As Long = 2
            Private Const MK_MBUTTON                        As Long = 16
            Private Const XFORMCOORDS_POSITION              As Long	= &H1
            Private Const XFORMCOORDS_SIZE                  As Long	= &H2
            Private Const XFORMCOORDS_HIMETRICTOCONTAINER   As Long	= &H4
            Private Const XFORMCOORDS_CONTAINERTOHIMETRIC   As Long	= &H8
            Private Const DVASPECT_CONTENT                  As Long = 1
                        
        ' FIXME PropertyPages, indexed prop-get needs to be exposed

        [Unimplemented]
            Public AccessKeys As String
        [Unimplemented]
            Public Alignable As Boolean = False
        '[ Unimplemented ]
            Public BorderStyle As VBRUN.ControlBorderStyleConstants = ControlBorderStyleConstants.vbNoBorder


        Public BackStyle As BackFillStyleConstants = BackFillStyleConstants.vbBFOpaque

        [Serialize(True, "CanGetFocus")]
        Private CanGetFocusINIT As Boolean = True
        
        Public ClipBehavior As VbClipBehavior = VbClipBehavior.vbClipUseRegion

        [Unimplemented]
            Public DataBindingBehavior As VbDataBindingBehavior = VbDataBindingBehavior.vbDataBindingNone
        [Unimplemented]
            Public DataSourceBehavior As VbDataSourceBehavior = VbDataSourceBehavior.vbDataSourceNone
        
        Public DefaultCancel As Boolean = False
        
        [Unimplemented]
            Public EditAtDesignTime As Boolean = False
        [Unimplemented]
            Public ForwardFocus As Boolean = False
        [Unimplemented]
            Public HitBehavior As VbHitTestBehavior = VbHitTestBehavior.vbHitTestUseRegion

            Public InvisibleAtRuntime As Boolean = False
        [Unimplemented]
            Public PaletteMode As VBRUN.PaletteModeConstants = VBRUN.PaletteModeConstants.vbPaletteModeContainer
        [Unimplemented]
            Public Public As Boolean = True
        [Unimplemented]
            Public RightToLeft As Boolean = False
            
       ' FIXME this should only be serialized at DESIGN TIME
       [Serialize(True, "ToolboxBitmap")]
       [CustomDesigner("designer_PictureBytes")]
           Private ReadOnly ToolboxBitmapINIT() As Byte
            
        Public Windowless As Boolean = False
            
        [CustomDesigner("designer_SpectrumWindows")]
        [Unimplemented]
            Public MaskColor As OLE_COLOR = SystemColorConstants.vb3DFace

        [Unimplemented]
        [Serialize(True, "MaskPicture")]
        [CustomDesigner("designer_PictureBytes")]
            Private ReadOnly MaskPictureINIT() As Byte
        [Unimplemented]
        [Serialize(False)]
            Public MaskPicture As StdPicture

        [Serialize(True, "Picture")]
        [CustomDesigner("designer_PictureBytes")]
            Private ReadOnly PictureINIT() As Byte
            
        [Unimplemented]
        [Serialize(True, "Palette")]
        [CustomDesigner("designer_PictureBytes")]
            Private ReadOnly PaletteINIT() As Byte
        [Unimplemented]
        [Serialize(False)]
            Public Palette As StdPicture

        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalSetWindowPos Lib "user32" Alias "SetWindowPos" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalLoadTypeLib Lib "oleaut32" Alias "LoadTypeLib" (ByVal szFile As String, ByRef pptlib As ITypeLib) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalStringFromGUID2 Lib "ole32" Alias "StringFromGUID2" (ByRef rguid As WinNativeFormsBASE.GUID2, ByVal lpsz As LongPtr, ByVal cchMax As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalOleRegGetUserType Lib "ole32" Alias "OleRegGetUserType" (ByVal clsid As LongPtr, ByVal dwFormOfType As Long, ByVal pszUserType As LongPtr) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalIIDFromString Lib "ole32" Alias "IIDFromString" (ByVal lpsz As String, ByVal lpiid As LongPtr) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalSetParent Lib "user32" Alias "SetParent" (ByVal hWndChild As LongPtr, ByVal hWndNewParent As LongPtr) As LongPtr
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalShowWindow Lib "user32" Alias "ShowWindow" (ByVal hWnd As LongPtr, ByVal nCmdShow As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalDestroyWindow Lib "user32" Alias "DestroyWindow" (ByVal hWnd As LongPtr) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalPrintWindow Lib "user32" Alias "PrintWindow" (ByVal hwnd As LongPtr, ByVal hdcBlt As LongPtr, ByVal nFlags As Long) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalCreateBitmap Lib "gdi32" Alias "CreateBitmap" (ByVal nWidth As Long, ByVal nHeight As Long, ByVal nPlanes As Long, ByVal nBitCount As Long, ByVal lpBits As LongPtr) As LongPtr
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalSetViewportOrgEx Lib "gdi32" Alias "SetViewportOrgEx" (ByVal hdc As LongPtr, ByVal x As Long, ByVal y As Long, ByRef lpPoint As WinNativeFormsBASE.POINT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalGetViewportOrgEx Lib "gdi32" Alias "GetViewportOrgEx" (ByVal hdc As LongPtr, ByRef lpPoint As WinNativeFormsBASE.POINT) As Long
        [UseGetLastError(False), DLLStackCheck(False)]
        Private Declare PtrSafe Sub InternalSleep Lib "kernel32.dll" Alias "Sleep" (ByVal dwMilliseconds As Long)

        [Serialize(False)]
            Public Property Get Ambient() As AmbientProperties
                Dim siteDispatch As stdole.IDispatch = CType(Of IDispatch)(Me.InternalState.OleClientSite)
                Return New AmbientPropertiesPassThru(siteDispatch)
            End Property

        [Unimplemented]
        [Serialize(False)]
            Public Sub AsyncRead(ByVal Target As String, ByVal AsyncType As Long, ByVal PropertyName As Variant, ByVal AsyncReadOptions As Variant)
            End Sub

        [Unimplemented]
        [Serialize(False)]
            Public Sub CancelAsyncRead(ByVal Property As Variant)
            End Sub
            
        [Unimplemented]
        [Serialize(False)]
            Public Function CanPropertyChange(ByVal PropertyName As String) As Boolean
            End Function
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get ContainedControls() As ContainedControls
                Return New EmptyContainedControls
            End Property
            
        [Serialize(False)]
            Public Property Get ContainerHwnd() As LongPtr
                On Error Resume Next
                Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
                Dim retVal As LongPtr
                site.GetWindow(retVal)      ' can fail in Access/VBA if called before activated via DoVerb?
                Return retVal
            End Property
            
        [Unimplemented]
        [Serialize(False)]
            Public Sub DataMemberChanged(ByVal DataMember As String)
            End Sub
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get DataMembers() As DataMembers
            End Property
            
        [Serialize(False)]
            Public Property Get EventsFrozen() As Boolean
                Return CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen
            End Property
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get Hyperlink() As Hyperlink
            End Property
            
        [Unimplemented]
        [Serialize(False)]
            Public Property Get ParentControls() As ParentControls
                Return New EmptyParentControls
            End Property
            
        [Unimplemented]
            Public Sub PopUpMenu(ByVal Menu As Object, Optional ByVal Flags As Variant, Optional ByVal X As Variant, Optional ByVal Y As Variant, Optional ByVal DefaultMenu As Variant)
            End Sub
            
        Public Sub Size(ByVal Width As Single, ByVal Height As Single)
            Dim size As SIZEL
            size.cx = CLng(ScaleX(Width, vbTwips, vbHimetric))
            size.cy = CLng(ScaleY(Height, vbTwips, vbHimetric))
            IOleObject_SetExtent(1, size)
        End Sub

        [Unimplemented]
            Public Sub ValidateControls()
            End Sub
            
        Public Sub OLEDrag()
            CommonOLEDrag(Me)
        End Sub

        [Unimplemented]
        [Serialize(False)]
            Public Property Get Image() As StdPicture
            End Property
                        
    #End Region

    #Region "EVENTS"
    
        [DefaultDesignerEvent]
        [Description("")]
            Event Initialize()
        [Description("")]
        [DispId(&HEAEA0004)]
        [DispId(&HEAEA0004)]
            Event Click()
        [Description("")]
        [DispId(&HEAEA0005)]
            Event DblClick()
        [Description("")]
        [DispId(&HEAEA0006)]
            Event GotFocus()
        [Description("")]
        [DispId(&HEAEA0008)]
            Event KeyDown(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0009)]
            Event KeyPress(KeyAscii As Integer)
        [Description("")]
        [DispId(&HEAEA000A)]
            Event KeyUp(KeyCode As Integer, Shift As Integer)
        [Description("")]
        [DispId(&HEAEA0007)]
            Event LostFocus()
        [Description("")]
        [DispId(&HEAEA0001)]
            Event MouseDown(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0002)]
            Event MouseMove(Button As Integer, Shift As Integer, X As Single, Y As Single)
        [Description("")]
        [DispId(&HEAEA0003)]
            Event MouseUp(Button As Integer, Shift As Integer, X As Single, Y As Single)

        [Description("")]
            Event Paint()
        [Description("")]
            Event Resize()
            
        [Description("")]
            Event Terminate()
            
        [Description("")]
        [Unimplemented]
        [DispId(&HEAEA000B)]
            Event DragDrop(Source As Control, X As Single, Y As Single)
        [Description("")]
        [Unimplemented]
        [DispId(&HEAEA000C)]
            Event DragOver(Source As Control, X As Single, Y As Single, State As Integer)
            
        Event OLECompleteDrag(Effect As Long)
        Event OLEDragDrop(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single)
        Event OLEDragOver(Data As DataObject, Effect As Long, Button As Integer, Shift As Integer, X As Single, Y As Single, State As Integer)
        Event OLEGiveFeedback(Effect As Long, DefaultCursors As Boolean)
        Event OLESetData(Data As DataObject, DataFormat As Integer)
        Event OLEStartDrag(Data As DataObject, AllowedEffects As Long)

        [Description("")]
            Event InitProperties()
        [Description("")]
            Event ReadProperties(ByRef PropBag As PropertyBag)
        [Description("")]
            Event WriteProperties(ByRef PropBag As PropertyBag)
        [Description("")]
            Event EnterFocus()
        [Description("")]
            Event ExitFocus()
        [Description("")]
            Event Show()
        [Description("")]
            Event Hide()

        [Unimplemented]
            Event AccessKeyPress(KeyAscii As Integer)
        
            Event AmbientChanged(PropertyName As String)
        [Unimplemented]
            Event AsyncReadComplete(AsyncProp As AsyncProperty)
        [Unimplemented]
            Event AsyncReadProgress(AsyncProp As AsyncProperty)

        Event HitTest(X As Single, Y As Single, HitResult As Integer)
        [Unimplemented]
            Event GetDataMember(DataMember As String, Data As Object)

        #If LOG_USERCONTROL Then
            Event ExperimentalLog(ByVal Text As String)
        #End If
        
    #End Region
               
    #Region "MEMBERS"
            
        Private InternalState As UcInternalState
             
        #If LOG_TERMINATE Then
            Private Sub Class_Terminate()
                    Debug.Print CurrentComponentName & "." & CurrentProcedureName
            End Sub
        #End If
        
        ' Private Sub Class_BeforeFirstMethodAccess()
        '     ' If Me.Extender IsNot Nothing Then
        '     '     Debug.Print Me.Extender.Name & "." & CurrentProcedureName & " *** UC"
        '     ' Else
        '     '     Debug.Print CurrentComponentName & "." & CurrentProcedureName & " *** UC"
        '     ' End If
        '     '[_HiddenModule].EnsureContainerIsLoaded(Me)
        ' End Sub
        
        ' Private Sub HandleCreate() _
        '         Handles RootWindowElement.Create
            
        '     InitializeMe()
        ' End Sub
        
        Private Sub HandleInitialize(ByVal ControlContext As WindowsControls.WindowsControlContext) _
                Implements IWindowsControl.Initialize
            
            'InternalSleep(5000)
            Me.InternalStateReset()     ' resets all the base class state
            'ResetUcInternalState(InternalState)
            Me.InternalStateResetOLEDragDrop()
            Me.InternalStateResetGraphics()
            
            With ControlContext.GetSerializer
                'Debug.Print CurrentComponentName & "." & CurrentProcedureName

                ' grab the outer class CLSID, as we will be needing it
                InternalState.RootCLSID = .GetRootCLSID
                
                ' We could handle this better if we had full inheritance support
                ' This is needed to make properties on the outer interface accessible at design time in property lists etc.
                CType(Of ITwinBasicInternalClassSupport)(Me).OverrideDispatchHandler .GetRootClassDispatch  ' this causes a circular reference that needs to be manually broken in IOleObject_Close
                
                ' FIXME Deserializing here is not quite correct for proper VB6 back compat
                ' (it needs to be done on first access to any member, and again on NEXT member access AFTER a close in a re-open scenario)
                If Not .Deserialize(Me) Then
                    BackColor = SystemColorConstants.vbButtonFace
                End If
                
                InternalState.IsDesignMode = .IsDesignMode
                InternalState.IsTbDebugging = .IsTbDebugging
            End With
            
            Dim Picture As StdPicture
            CommonLoadPictureInit(Picture, Me.PictureINIT)
            Set Me.Picture = Picture
            
            'InternalSleep(5000)
            
            With CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX)
                .CanGetFocus = Me.CanGetFocusINIT
                .BaseGraphicsInfoPtr = _BaseGraphics.InitBaseGraphicsInfo()
            End With
            
            Dim InitData As WinNativeFormsBASE.WindowCreationData
            InitData.ClassName = If(HasDC = True, "ThunderUserControlDC", "ThunderUserControl")
            InitData.WindowStyles = If(Me.ClipControls = True, WinNativeFormsBASE.WS_CLIPCHILDREN, 0&)
            InitData.Flags = NeedsPrePostMessages Or _
                                IsUserControl Or _
                                ManualMouseCapture Or _
                                ForwardMouseDown Or _
                                ForwardMouseMove Or _
                                ForwardMouseUp Or _
                                ForwardButtonClick Or _
                                ForwardDoubleClick Or _
                                ForwardKeyDown Or _
                                ForwardKeyUp Or _
                                ForwardKeyPress Or _
                                ScaleAdjustMouseEvents
            Set Me.RootWindowElement = CreateRootWindowElement(ControlContext, InitData)
            
            _BaseGraphics.InitGraphics(Me.RootWindowElement)
            InitOleDragDropHelper()
            
            
            
            ' FIXME This is where VB6 raises the Initialize event.  BUT we need the freestanding HWND available already...
            ' problem here is that the HWND is not yet available for this control.
            ' FIXME need to check ScaleWidth/ScaleHeight are the DESIGN-TIME width/heights at this point
            'Stop
            'InitializeMe
            'RaiseEvent Initialize()
        End Sub
        
        Private Sub InitOleDragDropHelper()
            _BaseOLEDragDropHelper.OLEDragDropInit(Me, ControlContext, RootWindowElement, True, False, False)
        End Sub
        
        [Serialize(False)]
        Public Property Get Width() As Double
            Return Me.ControlContext.GetScaledWidth
        End Property
        
        [Serialize(False)]
        Public Property Let Width(ByVal Value As Double)
            If Value <> Width Then
                Me.ControlContext.SetScaledWidth(Value)
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent Resize()
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get Height() As Double
            Return Me.ControlContext.GetScaledHeight
        End Property
        
        [Serialize(False)]
        Public Property Let Height(ByVal Value As Double)
            If Value <> Height Then
                Me.ControlContext.SetScaledHeight(Value)
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent Resize()
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
            End If
        End Property
        
        Private Sub InitializeMe()
                        
            'Debug.Print Me.Extender.Name & "." & CurrentProcedureName()
            #If LOG_USERCONTROL Then
                Log("InitializeMe")
            #End If
            InternalState.IsInitialized = True
            
            ' for the Initialize event, there's no need to have the final size of the control
            ' the ScaleWidth/Height etc should be based off the design-time size of the designed control
            'Stop
            
            InternalState.MutedResizeEventsCount += 1
                [_HiddenModule].EnsureContainerIsLoaded(Me)
                'ControlContext.EnsureContainerIsLoaded
                
                Dim RootWindowElement As Any = Me.RootWindowElement
                #If LOG_USERCONTROL Then
                    Log("InitializeMe (1)")
                #End If
                Me.[_BaseGraphics].SyncScaleMode(Me, RootWindowElement)

                _BaseGraphics.ChangeHDC(0, RootWindowElement.Handle, RootWindowElement, Me.Picture, Me, False)
                #If LOG_USERCONTROL Then
                    Log("InitializeMe (2)")
                #End If
            InternalState.MutedResizeEventsCount -= 1
            
            If Not Me.InternalState.IsInitialized1 Then
                 Me.InternalState.IsInitialized1 = True
                 Me.InternalState.IgnorePropertyChangedNotifications += 1
                 If InternalState.IsTbDebugging = False Then
                     On Error Resume Next
                 End If
                 RaiseEvent Initialize()
                 Me.InternalState.IgnorePropertyChangedNotifications -= 1
            End If
             #If LOG_USERCONTROL Then
                Log("InitializeMe (3)")
             #End If
            On Error Resume Next
            Dim OleClientSite As Any = Me.InternalState.OleClientSite
            If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()  ' MSACCESS errors on this
            #If LOG_USERCONTROL Then
                Log("InitializeMe (4)")
            #End If
        End Sub
        
        Private Sub HandlePreLoad() _
                Handles RootWindowElement.PreLoadForm
            
            'Debug.Print CurrentComponentName & "." & CurrentProcedureName

            ' At this point the HWND is available, but not correct size etc.           
            Me.[_BaseGraphics].SyncScaleMode(Me, Me.RootWindowElement)
            SyncOLEDropMode()
        End Sub
                
        Private Sub HandleDestroy() _
                Implements IWindowsControl.Destroy
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If
            
            #If LOG_USERCONTROL Then
                Log("HandleDestroy")
            #End If
            
            ' disconnect anything that causes a circular reference here
            'Debug.Print "UserControl.HandleDestroy"
            Me.InternalStateResetOLEDragDrop()
            Me.InternalStateResetGraphics()
            ResetUcInternalState(InternalState)
        End Sub
                
        Private Sub HandleEnterFocus() _
                Handles RootWindowElement.EnterFocus
                               
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus")
            #End If
            
            InternalState.hasFocusOnChild = True
            
            On Error Resume Next
            Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus -> controlSite.OnFocus(1)")
            #End If
            controlSite.OnFocus(1)      ' this will trigger DoVerb(OLEIVERB_INPLACEACTIVATE)
            #If LOG_USERCONTROL Then
                Log("HandleEnterFocus -> controlSite.OnFocus(1)... DONE")
            #End If
                
            If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent EnterFocus()
            End If
                    
        End Sub

        Private Sub HandlePreMessage(ByVal Msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef MutedReturnValue As Variant, ByRef PostMessageCookie As Long) _
                Handles RootWindowElement.PreProcessMessage
            If Msg = WinNativeFormsBASE.WM_SHOWWINDOW Then
                InternalState.ActualVisibilityState = (wParam <> 0)
            End If
            
            If (Me.ControlContainer = True) And (Msg < &H400) Then
                #If LOG_USERCONTROL Then
                    Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam))
                #End If
            	Dim simpleFrameSite As Any = CType(Of ISimpleFrameSite)(Me.InternalState.OleClientSite)
                Dim result As LongPtr
                On Error Resume Next
                simpleFrameSite.PreMessageFilter(Me.hWnd, Msg, wParam, lParam, result, PostMessageCookie)
                If Err.LastHresult = WinNativeFormsBASE.S_FALSE Then
                    #If LOG_USERCONTROL Then
                        Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE CONSUMED (result: " & result & ")")
                    #End If
                	MutedReturnValue = result ' the site has consumbed the message
                ElseIf Err.Number <> 0 Then
                    #If LOG_USERCONTROL Then
                        Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NOT USED")
                    #End If
                    Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL   ' PostMessage() not necessary later
                Else
                    #If LOG_USERCONTROL Then
                        Log("HandlePreMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NEEDS FURTHER PROCESSING (S_OK, interim: " & result & ")")
                    #End If
                End If
            End If
        End Sub

        Private Sub HandlePostMessage(ByVal Msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef ReturnValue As LongPtr, ByVal PostMessageCookie As Long) _
                Handles RootWindowElement.PostProcessMessage
            If (Me.ControlContainer = True) And (Msg < &H400) Then
                #If LOG_USERCONTROL Then
                    Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam))
                #End If
            	Dim simpleFrameSite As Any = CType(Of ISimpleFrameSite)(Me.InternalState.OleClientSite)
                On Error Resume Next
                simpleFrameSite.PostMessageFilter(Me.hWnd, Msg, wParam, lParam, ReturnValue, PostMessageCookie)
                If Err.Number = 0 Then
                    #If LOG_USERCONTROL Then
                        Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE PROCESSED BY SITE (return: " & ReturnValue & ")")
                    #End If
                Else
                    #If LOG_USERCONTROL Then
                        Log("HandlePostMessage", Hex(Msg), Hex(wParam), Hex(lParam), " --> MESSAGE NOT PROCESSED")
                    #End If
                End If
            End If
        End Sub
        
        Private Sub RootWindowElement_ImmediateGotFocus()
            If InternalState.siteFrame IsNot Nothing Then
                InternalState.siteFrame.SetActiveObject(Me, 0)
            End If
        End Sub
            
        Private Sub HandleExitFocus() _
                Handles RootWindowElement.ExitFocus
            #If LOG_USERCONTROL Then
                Log("HandleExitFocus")
            #End If
            
            If InternalState.hasFocusOnChild = False Then Exit Sub
            InternalState.hasFocusOnChild = False
            
            ' FIXME ordering here not checked
            
            On Error Resume Next

            Dim OleClientSite As Any = Me.InternalState.OleClientSite
            Dim site As Any = CType(Of IOleInPlaceSite)(OleClientSite)
            site.OnUIDeactivate(0)
                
            Dim controlSite As IOleControlSite = CType(Of IOleControlSite)(OleClientSite)
            controlSite.OnFocus(0)
            
            If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent ExitFocus()
            End If
            
            If InternalState.siteFrame IsNot Nothing Then
                InternalState.siteFrame.SetActiveObject(Nothing, 0)
            End If
                        
            #If LOG_USERCONTROL Then
                Log("HandleExitFocus", "Err.Number:", Hex(Err.Number))
            #End If
        End Sub
                
        Private Sub HandleGotFocus() _
            Handles RootWindowElement.GotFocus
            
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus")
            #End If
            
            If CanGetFocus = False Then Exit Sub
            InternalState.hasFocus = True
            
            Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> site.OnUIActivate()")
            #End If
            
            'MsgBox IsDesignMode
            ' This can cause 'Catastrophic failure' messages (and others) in VBA UserForms in design mode if we don't catch the error here
            On Error Resume Next
            site.OnUIActivate()         ' by calling this now, prevents the next controlSite.OnFocus(1) call from triggering DoVerb(OLEIVERB_INPLACEACTIVATE)
            On Error GoTo 0
            
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> site.OnUIActivate()... DONE")
            #End If
            If InternalState.siteFrame IsNot Nothing Then
                #If LOG_USERCONTROL Then
                    Log("HandleGotFocus -> siteFrame.SetMenu(0, 0, 0)")
                #End If
                 On Error Resume Next
                 InternalState.siteFrame.SetMenu(0, 0, 0)      ' this can throw
                 On Error GoTo 0
                #If LOG_USERCONTROL Then
                    Log("HandleGotFocus -> siteFrame.SetMenu(0, 0, 0)... DONE")
                #End If
            End If

            'Dim controlSite As Any = CType(Of IOleControlSite)(OleClientSite)
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> controlSite.OnFocus(1)")
            #End If
            'controlSite.OnFocus(1) ' if we do this, then VBCCR.CommandButton (and many others) compiled by us don't focus properly, e.g. CommandButtonW.Click doesn't fire
            #If LOG_USERCONTROL Then
                Log("HandleGotFocus -> controlSite.OnFocus(1)")
            #End If
            
            
                            
            If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent EnterFocus()
                RaiseEvent GotFocus()
            End If
        End Sub

        Private Sub HandleLostFocus() _
                Handles RootWindowElement.LostFocus
                            
            #If LOG_USERCONTROL Then
                Log("HandleLostFocus")
            #End If
            
            If InternalState.hasFocus = False Then Exit Sub
            If CanGetFocus = False Then Exit Sub
            InternalState.hasFocus = False
            
            ' FIXME ordering here not checked
            
            On Error Resume Next        ' added to avoid issues in Access
            Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
            site.OnUIDeactivate(0)
                
            Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
            controlSite.OnFocus(0)
            
            If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent LostFocus()
                HandleExitFocus()
            End If
        End Sub
        
        Private Sub HandleLoad() _
                Handles RootWindowElement.Load

            #If LOG_USERCONTROL Then
                Log("HandleLoad")
            #End If
        End Sub
        
        Private Sub InternalRaiseResize() _
                Implements TbCommonContainerPrivate.RaiseResize
            
            # If LOG_USERCONTROL Then
                Log("InternalRaiseResize")
            #End If
            
        	If InternalState.MutedResizeEventsCount = 0 Then
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent Resize()
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                InternalState.InitialResizeEventFired = True
            End If
        End Sub

        Private Sub InternalRaisePaint() _
                Implements TbCommonContainerPrivate.RaisePaint
            
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
        	RaiseEvent Paint()
            Debug.TracePrint "*** UC.InternalRaisePaint DONE"
        End Sub
        
        Private Sub HandleEraseBackground(ByVal hdc As LongPtr, ByRef Handled As Boolean) _
                Handles RootWindowElement.EraseBackground
                
            #If LOG_USERCONTROL Then
                Log("HandleEraseBackground")
            #End If
            If InternalState.IsHandlingPaint = False Then
                If InternalState.IsInitialized = False Then InitializeMe
            
                Dim preservedDC As LongPtr = Me.hDC
                Me.hDC = hdc
                Me.Cls
                Me.hDC = preservedDC
                Handled = True     ' swallow up the event
            End If
        End Sub
        
        Private Sub HandlePaint(ByRef Handled As Boolean) _
                Handles RootWindowElement.Paint
                
            If InternalState.IsInitialized = False Then InitializeMe
            
            #If LOG_USERCONTROL Then
                Log("HandlePaint")
            #End If
            
            InternalState.IsHandlingPaint = True
            
            Dim ps As WinNativeFormsBASE.PAINTSTRUCT
            Dim RootWindowElement As Any = Me.RootWindowElement
            RootWindowElement.BeginPaint(ps)    ' you MUST use this method, and NOT the BeginPaint API 
                
            #If LOG_USERCONTROL Then
                Log("HandlePaint", "ps.hdc: ", Hex(ps.hdc), "GetDC():", WinNativeFormsBASE.GetDC(hWnd))
            #End If
                
                Me.[_BaseGraphics].OnPaint(ps.hdc)
                
                ' If Me.ClipControls = True And IsDesignMode = False Then
                '     ' FIXME need better method.
                '     Dim Ctrl As Control
                '     For Each Ctrl In Me.Parent.Controls
                '         On Error Resume Next
                '             Dim isContainedByUs As Boolean = False
                '             isContainedByUs = Ctrl.Container Is Me
                '             If isContainedByUs Then
                '                 WinNativeFormsBASE.WindowsAPI.RedrawWindow(Ctrl.Hwnd, 0, 0, WinNativeFormsBASE.RDW_ERASE Or WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_ERASENOW Or WinNativeFormsBASE.RDW_UPDATENOW Or WinNativeFormsBASE.RDW_FRAME)
                '             End If
                '     Next
                '     On Error GoTo 0
                ' End If

            'ValidateRect(Me.hWnd, 0)
            RootWindowElement.EndPaint(ps)
            'Handled = True     ' We purposely DONT swallow up the event, as the extenders WM_PAINT post-filter can render onto the window (e.g. lightweight controls)
            
            InternalState.IsHandlingPaint = False
            
            #If LOG_USERCONTROL Then
                Log("HandlePaint.... DONE")
            #End If
        End Sub
                                        
        [Serialize(False)]
        Public Property Get hWnd() As LongPtr
            If Me.InternalState.IsWindowlessActivated Then Return 0
            
            If Me.RootWindowElement IsNot Nothing Then
                Return Me.RootWindowElement.Handle
            End If
        End Property
        
        [Serialize(False)]
        Public Property Get DpiScale() As Double
            Return Me.RootWindowElement.DPI / 96
        End Property
        
        Public Sub PropertyChanged(Optional ByVal PropertyName As Variant)
            If Me.InternalState.IgnorePropertyChangedNotifications = 0 Then
                InternalState.PropertiesChanged = True
            End If
        End Sub
        
    #End Region
    
    #If LOG_USERCONTROL Then
        Private Sub Log(ParamArray Values() As Variant)
            'MsgBox Format(Now, "hh:nn:ss") & " " & Join(Values, ", ")
            RaiseEvent ExperimentalLog(Format(Now, "hh:nn:ss") & " " & Join(Values, ", "))
        End Sub
    #End If
    
    Private Sub IOleObject_SetClientSite(ByVal pClientSite As IOleClientSite) Implements IOleObject.SetClientSite
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetClientSite", ObjPtr(pClientSite))
        #End If
        
        Debug.TracePrint "IOleObject_SetClientSite", Hex(ObjPtr(pClientSite))
        'IOleObject_SetClientSite_WasCalled = True
        Set InternalState.OleClientSite = pClientSite
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetClientSite ... DONE", ObjPtr(pClientSite))
        #End If
        
        
        'InitializeMe
    End Sub
    
    Private Sub IOleObject_GetClientSite(ppClientSite As IOleClientSite) Implements IOleObject.GetClientSite
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetClientSite")
        #End If
        SetOutParamToNothing(VarPtr(ppClientSite))
        Set ppClientSite = InternalState.OleClientSite
    End Sub
    
    Private Sub IOleObject_SetHostNames(ByVal szContainerApp As LongPtr, ByVal szContainerObj As LongPtr) Implements IOleObject.SetHostNames
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetHostNames", szContainerApp, szContainerObj)
        #End If
        ' MSACCESS calls this during initialization.  VBx doesn't
    End Sub
    
    Private Sub IOleObject_Close(ByVal dwSaveOption As Long) Implements IOleObject.Close
        #If LOG_USERCONTROL Then
            Log("IOleObject_Close", dwSaveOption)
        #End If
               
        Debug.TracePrint "IOleObject_Close", dwSaveOption
        
        If InternalState.IsClosed Then Exit Sub
        InternalState.IsClosed = True
        
        ' FIXME at what point should the timers actually stop?
        Dim RootWindowElement As Any = Me.RootWindowElement
        Me.RootWindowElement.StopTimers()
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent Terminate()

        ' FIXME at what point does the window actually get hidden, and detached?
        If RootWindowElement.Handle <> 0 Then
            InternalShowWindow(RootWindowElement.Handle, WinNativeFormsBASE.SW_HIDE)
            InternalSetParent(RootWindowElement.Handle, 0)
        End If
                
        Set InternalState.OleClientSite = Nothing
        
        With CType(Of ITwinBasicInternalClassSupport)(Me)
            .OverrideDispatchHandler Nothing  ' this breaks the circular reference
        End With

        ' FIXME should the window actually get destroyed at this point?
        RootWindowElement.DestroyHandle()
    End Sub
    
    Private Sub IOleObject_SetMoniker(ByVal dwWhichMoniker As Long, ByVal pmk As WinNativeFormsBASE.IMoniker) Implements IOleObject.SetMoniker
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetMoniker", dwWhichMoniker, ObjPtr(pmk))
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleObject_GetMoniker(ByVal dwAssign As Long, ByVal dwWhichMoniker As Long, pmk As WinNativeFormsBASE.IMoniker) Implements IOleObject.GetMoniker
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetMoniker", dwAssign, dwWhichMoniker)
        #End If
        SetOutParamToNothing(VarPtr(pmk))       ' FIXME debugging variables inspection would not be safe here until this has completed
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleObject_InitFromData(ByVal pDataObject As WinNativeFormsBASE.IDataObject, ByVal fCreation As Long, ByVal dwReserved As Long) Implements IOleObject.InitFromData
        #If LOG_USERCONTROL Then
            Log("IOleObject_InitFromData", ObjPtr(pDataObject), fCreation, dwReserved)
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleObject_GetClipboardData(ByVal dwReserved As Long, ppDataObject As WinNativeFormsBASE.IDataObject) Implements IOleObject.GetClipboardData
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetClipboardData", dwReserved, ObjPtr(ppDataObject))
        #End If
        SetOutParamToNothing(VarPtr(ppDataObject))      ' FIXME debugging variables inspection would not be safe here until this has completed
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleObject_EnumVerbs(ByRef ppEnumOleVerb As IEnumOLEVERB) Implements IOleObject.EnumVerbs
        #If LOG_USERCONTROL Then
            Log("IOleObject_EnumVerbs", ObjPtr(ppEnumOleVerb))
        #End If
        SetOutParamToNothing(VarPtr(ppEnumOleVerb))         ' FIXME debugging variables inspection would not be safe here until this has completed
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    [Serialize(False)]
    Private Property Get WindowlessRectLeft() As Long _
            Implements TbUserControlPrivate.WindowlessRectLeft
        Return InternalState.WindowlessRect.Left
    End Property
    [Serialize(False)]
    Private Property Get WindowlessRectTop() As Long _
            Implements TbUserControlPrivate.WindowlessRectTop
        Return InternalState.WindowlessRect.Top
    End Property
    [Serialize(False)]
    Private Property Get WindowlessRectRight() As Long _
            Implements TbUserControlPrivate.WindowlessRectRight
        Return InternalState.WindowlessRect.Right
    End Property
    [Serialize(False)]
    Private Property Get WindowlessRectBottom() As Long _
            Implements TbUserControlPrivate.WindowlessRectBottom
        Return InternalState.WindowlessRect.Bottom
    End Property
    
    Private Sub IOleObject_DoVerb(ByVal iVerb As Long, ByVal lpmsg As LongPtr, ByVal pActiveSite As IOleClientSite, ByVal lindex As Long, ByVal hwndParent As LongPtr, ByRef lprcPosRect As WinNativeFormsBASE.RECT) Implements IOleObject.DoVerb
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_DoVerb", iVerb, lpmsg, ObjPtr(pActiveSite), lindex, hwndParent, "Width", lprcPosRect.Right - lprcPosRect.Left, "Height", lprcPosRect.Bottom - lprcPosRect.Top)
        #End If
                    
        'Exit Sub '**********
        
        Debug.TracePrint "*** IOleObject_DoVerb 1"
        Dim site As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        ' If site Is Nothing Then
        '     Debug.Print IOleObject_SetClientSite_WasCalled
        '     Stop
        ' End If
        Debug.TracePrint "*** IOleObject_DoVerb 2"
                        
        ' NOTE: WinNativeFormsBASE.OLEIVERB_PRIMARY on a VB6 user control shows the first property page
                    
        Select Case iVerb
            Case WinNativeFormsBASE.OLEIVERB_HIDE
                
                If InternalState.ActualVisibilityState = False Then Exit Sub
                InternalShowWindow(hWnd, WinNativeFormsBASE.SW_HIDE)

                If InternalState.ConsumerVisibilityState = True Then
                    If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                        InternalState.ConsumerVisibilityState = False
                        If InternalState.IsTbDebugging = False Then
                            On Error Resume Next
                        End If
                        RaiseEvent Hide()
                    Else
                        InternalState.QueuedShowEvent = True
                    End If
                End If
                                
        	Case WinNativeFormsBASE.OLEIVERB_SHOW, _               
                    WinNativeFormsBASE.OLEIVERB_INPLACEACTIVATE
                    
                Debug.TracePrint "*** IOleObject_DoVerb 3"
                
                If InternalState.ActualVisibilityState = True Then Exit Sub
                
                ' In VB6 UserControl implementation, SHOW and UIACTIVATE appear identical.
                
                If InternalState.WindowIsInPlace = False Then
                
                    If Me.Windowless = True Then
                        On Error Resume Next
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "testing for IOleInPlaceSiteWindowless suppport")
                        #End If
                        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "testing for IOleInPlaceSiteWindowless suppport... DONE")
                        #End If
                        
                        If siteWindowless Is Nothing Then
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "reverting to WindowedMode...")
                            #End If
                            GoTo WindowedMode
                        End If
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.CanWindowlessActivate")
                        #End If
                        siteWindowless.CanWindowlessActivate()
                        Dim activateResult As Long = Err.LastHresult
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "siteWindowless.CanWindowlessActivate... DONE.   Result: " & Hex(activateResult))
                        #End If
                        
                        If activateResult = WinNativeFormsBASE.S_FALSE Then
                            ' The container site doesn't support windowless, so proceed with normal windowed-mode
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "reverting to WindowedMode...(2)")
                            #End If
                            GoTo WindowedMode
                        End If
                        
                        On Error GoTo 0
                        
                        InternalState.IsWindowlessActivated = True
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.OnInPlaceActivateEx")
                        #End If
                        siteWindowless.OnInPlaceActivateEx(CLngPtr(0), 1)       ' ACTIVATE_WINDOWLESS
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.OnInPlaceActivateEx... DONE")
                        #End If
                        ' site will typically query us for IOleInPlaceObjectWindowless at this point (optionally implemented)
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindow")
                        #End If
                        siteWindowless.GetWindow(parentWnd)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindow... DONE")
                        #End If

                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindowContext")
                        #End If
                        siteWindowless.GetWindowContext(InternalState.siteFrame, InternalState.siteDoc, posRect, clipRect, FrameInfo)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetWindowContext... DONE")
                        #End If

                        ' VB6 does this...
                        Dim pDC As LongPtr
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetDC")
                        #End If
                        siteWindowless.GetDC(CLngPtr(0), 1, pDC)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.GetDC... DONE")
                        #End If
                        ' FIXME investigate what VB6 uses this for.  What API calls does it make here?

                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.ReleaseDC")
                        #End If
                        siteWindowless.ReleaseDC(pDC)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.ReleaseDC... DONE")
                        #End If
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.InvalidateRect")
                        #End If
                        siteWindowless.InvalidateRect(CLngPtr(0), 1)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling siteWindowless.InvalidateRect... DONE")
                        #End If
                        
                        LSet InternalState.WindowlessRect = lprcPosRect
                        
                        ' the site should now call IViewObject.Draw() etc appropriately.
                    Else

                    WindowedMode:
                        Debug.TracePrint "*** IOleObject_DoVerb 4"
                        Dim resizeToContainer As Boolean = If(iVerb = WinNativeFormsBASE.OLEIVERB_SHOW, True, False)
                    
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.CanInPlaceActivate")
                        #End If
                        site.CanInPlaceActivate()
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.CanInPlaceActivate... DONE")
                        #End If

                        Debug.TracePrint "*** IOleObject_DoVerb 5"
                        
                        If Err.LastHresult = WinNativeFormsBASE.S_FALSE Then
                            ' VB6 bombs out here too
                            Err.Raise 5, , "Container does not support in-place activation"
                        End If
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 6"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.OnInPlaceActivate")
                        #End If
                        site.OnInPlaceActivate()
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.OnInPlaceActivate... DONE")
                        #End If
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 7"
                        
                        Dim parentWnd As LongPtr
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindow")
                        #End If
                        site.GetWindow(parentWnd)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindow... DONE")
                        #End If
                        Dim FrameInfo As OLEINPLACEFRAMEINFO
                        Dim posRect As WinNativeFormsBASE.RECT
                        Dim clipRect As WinNativeFormsBASE.RECT
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 8"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindowContext")
                        #End If
                        site.GetWindowContext(InternalState.siteFrame, InternalState.siteDoc, posRect, clipRect, FrameInfo)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling site.GetWindowContext... DONE")
                        #End If
                        
                        ' FIXME the returned clipRect should restrict the paint clipping region for our control (as per VBx)
                                                
                        ' In VB6, hwndParent is authoratitive, ignoring FrameInfo.hwndFrame (though they are usually the same).
                        ' Only at this point does the window get attached to the real container via SetParent...
                        InternalState.ContainerWindow = hwndParent

                        Debug.TracePrint "*** IOleObject_DoVerb 9"
                        
                        ' For a NEWLY ADDED control (i.e. InitNew was called), VBx implementation also calls IViewObject_Draw around here (just before raising the UserControl Resize event).

                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetWindowPos", "width:", posRect.Right - posRect.Left, "height:", posRect.Bottom - posRect.Top, "Me.PixelsWidth(BEFORE)", Me.PixelsWidth, "Me.PixelsHeight(BEFORE)", Me.PixelsHeight)
                        #End If
                        InternalSetWindowPos(Me.hWnd, 0, posRect.Left, posRect.Top, posRect.Right - posRect.Left, posRect.Bottom - posRect.Top, WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                        #End If
                        Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                        Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                        If InternalState.IsTbDebugging = False Then
                            On Error Resume Next
                        End If
                        RaiseEvent Resize()
                        On Error GoTo 0
                        Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 10"
                        
                        Dim styles As Long = WinNativeFormsBASE.GetWindowLongW(hWnd, WinNativeFormsBASE.WindowProperties.GWL_STYLE)
                        styles = styles And (Not WinNativeFormsBASE.WS_POPUP)
                        styles = styles Or WinNativeFormsBASE.WS_CHILD Or WinNativeFormsBASE.WS_CLIPSIBLINGS
                        WinNativeFormsBASE.SetWindowLongW(hWnd, WinNativeFormsBASE.WindowProperties.GWL_STYLE, styles)
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetParent")
                        #End If
                        
                        Debug.TracePrint "*** IOleObject_DoVerb 11"
                        InternalSetParent(hWnd, InternalState.ContainerWindow)
                        Debug.TracePrint "*** IOleObject_DoVerb 12"
                        
                        #If LOG_USERCONTROL Then
                            Log("IOleObject_DoVerb", "calling SetParent... DONE")
                        #End If
                        
                        InternalState.MutedResizeEventsCount += 1
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "calling ShowWindow")
                            #End If
                            InternalSetWindowPos(Me.hWnd, HWND_BOTTOM, 0, 0, 0, 0, WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOCOPYBITS Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOSIZE)
                            InternalShowWindow(hWnd, WinNativeFormsBASE.SW_SHOWNA)
                            #If LOG_USERCONTROL Then
                                Log("IOleObject_DoVerb", "calling ShowWindow... DONE")
                            #End If
                            'IOleInPlaceObject_SetObjectRects(lprcPosRect, lprcPosRect)
                            InternalState.MutedResizeEventsCount -= 1
                                                                        
                        Debug.TracePrint "*** IOleObject_DoVerb 13"
                        
                        If Me.ForceResizeToContainer And resizeToContainer Then
                            SynchronizeWindowSizeWithParent(hWnd, InternalState.ContainerWindow)
                            
                            Debug.TracePrint "*** IOleObject_DoVerb 13a"
                        End If
                    End If

                    InternalState.WindowIsInPlace = True
    
                Else
                    InternalShowWindow(hWnd, WinNativeFormsBASE.SW_SHOWNA)
                End If

                #If LOG_USERCONTROL Then
                    Log("IOleObject_DoVerb", "OleClientSite.ShowObject()")
                #End If
                InternalState.OleClientSite.ShowObject() ' this is called AFTER the control is attached to the real parent above
                #If LOG_USERCONTROL Then
                    Log("IOleObject_DoVerb", "OleClientSite.ShowObject()... DONE")
                #End If
                
                If InternalState.ConsumerVisibilityState = False Then
                    If CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False Then
                        InternalState.ConsumerVisibilityState = True
                        If InternalState.IsTbDebugging = False Then
                            On Error Resume Next
                        End If
                        RaiseEvent Show()
                    Else
                        InternalState.QueuedShowEvent = True
                    End If
                End If
                                
            Case WinNativeFormsBASE.OLEIVERB_UIACTIVATE
                
                If Me.Windowless = False Then
                    RootWindowElement.ActivateAX()
                    If Err.LastHresult = WinNativeFormsBASE.S_FALSE Then
                        ' No focusable child control, so focus the main hwnd
                        WinNativeFormsBASE.WindowsAPI.SetFocus(hWnd)        ' do this, else iGrid doesn't activate properly in VBA UserForms
                    End If
                End If
                #If LOG_USERCONTROL Then
                    Log("HandleEnterFocus -> site.OnUIActivate()")
                #End If
                site.OnUIActivate()
                #If LOG_USERCONTROL Then
                    Log("HandleEnterFocus -> site.OnUIActivate()... DONE")
                #End If
                If site IsNot Nothing Then
                    #If LOG_USERCONTROL Then
                        Log("HandleEnterFocus -> siteFrame.SetMenu(0, 0, 0)")
                    #End If
                    On Error Resume Next
                    InternalState.siteFrame.SetMenu(0, 0, 0)
                    On Error GoTo 0
                    #If LOG_USERCONTROL Then
                        Log("HandleEnterFocus -> siteFrame.SetMenu(0, 0, 0)... DONE")
                    #End If
                End If
        End Select
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_DoVerb", iVerb, lpmsg, ObjPtr(pActiveSite), lindex, hwndParent, "Width", lprcPosRect.Right - lprcPosRect.Left, "Height", lprcPosRect.Bottom - lprcPosRect.Top, "... DONE")
        #End If
    End Sub
    
    Private Sub IOleObject_Update() Implements IOleObject.Update
        #If LOG_USERCONTROL Then
            Log("IOleObject_Update")
        #End If
    End Sub
    
    Private Sub IOleObject_IsUpToDate() Implements IOleObject.IsUpToDate
        #If LOG_USERCONTROL Then
            Log("IOleObject_IsUpToDate")
        #End If
    End Sub

    Private Sub IOleObject_GetUserClassID(ByVal pClsid As LongPtr) Implements IOleObject.GetUserClassID
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserClassID", "{RootCLSID: " & RootCLSID & "}")
        #End If
        InternalIIDFromString(InternalState.RootCLSID, pClsid)
    End Sub
    
    Private Sub IOleObject_SetExtent(ByVal dwDrawAspect As Long, ByRef psizel As SIZEL) Implements IOleObject.SetExtent
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetExtent *", dwDrawAspect, psizel.cx, psizel.cy)
        #End If
        
        InternalState.[_ExtentX] = psizel.cx
        InternalState.[_ExtentY] = psizel.cy
        
        InternalState.WindowlessRect.Right = InternalState.WindowlessRect.Left + psizel.cx
        InternalState.WindowlessRect.Bottom = InternalState.WindowlessRect.Top + psizel.cy
            
        If Me.hWnd <> 0 Then
        	Dim RootWindowElement As Any = Me.RootWindowElement
            'Dim current_cx As Double = Me.RootWindowElement.ScaleX(Me.PixelsWidth, vbScaledPixels, vbHimetric)
            'Dim current_cy As Double = Me.RootWindowElement.ScaleY(Me.PixelsHeight, vbScaledPixels, vbHimetric)

            Dim rect As WinNativeFormsBASE.RECT
            WinNativeFormsBASE.GetWindowRect(Me.hWnd, rect)
            Dim current_cx As Long = CLng(RootWindowElement.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric))
            Dim current_cy As Long = CLng(RootWindowElement.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric))
            
            If (current_cx = psizel.cx) And (current_cy = psizel.cy) Then
                ' No change
                Exit Sub
            End If

            Dim cx As Double = RootWindowElement.ScaleX(psizel.cx, vbHimetric, vbPixels)
            Dim cy As Double = RootWindowElement.ScaleY(psizel.cy, vbHimetric, vbPixels)
            
            InternalSetWindowPos(Me.hWnd, 0, 0, 0, CLng(cx), CLng(cy), WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
            
            Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
            Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent Resize()
            Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
        End If
        
        ' VBx does IViewObject_Draw here
        
        On Error Resume Next
        Dim OleClientSite As Any = Me.InternalState.OleClientSite
        If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()  ' RequestNewObjectLayout can fail in MSACCESS
        
        InternalState.PropertiesChanged = True
    End Sub
    
    Private Sub IOleObject_GetExtent(ByVal dwDrawAspect As Long, ByRef psizel As SIZEL) Implements IOleObject.GetExtent
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetExtent *", dwDrawAspect, "Me.PixelsWidth", Me.PixelsWidth, "Me.PixelsHeight", Me.PixelsHeight)
        #End If
        
        psizel.cx = CLng(InternalState.[_ExtentX])
        psizel.cy = CLng(InternalState.[_ExtentY])
            
        ' If IsWindowlessActivated Then
        '     psizel.cx = WindowlessRect.Right - WindowlessRect.Left
        '     psizel.cy = WindowlessRect.Bottom - WindowlessRect.Top
        ' Else
        '     ' Get the real HWND pixel width/height
        '     'psizel.cx = Me.RootWindowElement.ScaleX(Me.PixelsWidth, vbScaledPixels, vbHimetric)         doesn't include borders
        '     'psizel.cy = Me.RootWindowElement.ScaleY(Me.PixelsHeight, vbScaledPixels, vbHimetric)
            
            
            
        '     ' Dim RootWindowElement As Any = Me.RootWindowElement
        '     ' Dim rect As WinNativeFormsBASE.RECT
        '     ' WinNativeFormsBASE.GetWindowRect(Me.hWnd, rect)
        '     ' Debug.TracePrint "*** GetExtent RESULT HEIGHT: " & (rect.Bottom - rect.Top)
        '     ' psizel.cx = RootWindowElement.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric)
        '     ' psizel.cy = RootWindowElement.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric)

        '     ' Static OrigWidth As Long = 0
        '     ' If OrigWidth = 0 Then
        '     ' OrigWidth = psizel.cx
        '     ' Else
        '     '     psizel.cx = _ExtentX
        '     ' End If
            
        '     ' Static OrigHeight As Long = 0
        '     ' If OrigHeight = 0 Then
        '     '     OrigHeight = psizel.cy
        '     ' Else
        '     '     psizel.cy = OrigHeight
        '     ' End If
        ' End If
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetExtent", dwDrawAspect, "result: (" & psizel.cx & "x" & psizel.cy & ")")
        #End If
    End Sub

    Private Sub IOleObject_GetUserType(ByVal dwFormOfType As Long, ByVal pszUserType As LongPtr) Implements IOleObject.GetUserType
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserType", dwFormOfType, pszUserType)
        #End If
            
        Dim temp As WinNativeFormsBASE.GUID2
        InternalIIDFromString(InternalState.RootCLSID, VarPtr(temp))
        Dim hr As Long = InternalOleRegGetUserType(VarPtr(temp), dwFormOfType, pszUserType)
        
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetUserType (HRESULT): " & Hex(hr))
        #End If
    End Sub
        
    Private Sub IOleObject_Advise(ByVal pAdvSink As WinNativeFormsBASE.IAdviseSink, pdwConnection As Long) Implements IOleObject.Advise
        #If LOG_USERCONTROL Then
            Log("IOleObject_Advise", ObjPtr(pAdvSink), pdwConnection)
        #End If
        ' FIXME would need to maintain an array of connections here
        'Set IOleObject_adviseSink = pAdvSink
        'pdwConnection = 1
    End Sub
    
    Private Sub IOleObject_Unadvise(ByVal dwConnection As Long) Implements IOleObject.Unadvise
        #If LOG_USERCONTROL Then
            Log("IOleObject_Unadvise", dwConnection)
        #End If
        'Set IOleObject_adviseSink = Nothing
    End Sub
    
    Private Sub IOleObject_EnumAdvise(ByRef ppenumAdvise As WinNativeFormsBASE.IEnumSTATDATA) Implements IOleObject.EnumAdvise
        #If LOG_USERCONTROL Then
            Log("IOleObject_EnumAdvise", ObjPtr(ppenumAdvise))
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleObject_GetMiscStatus(ByVal dwAspect As Long, ByRef pdwStatus As Long) Implements IOleObject.GetMiscStatus
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetMiscStatus")
        #End If
        ' WARNING: any changes made here also need to be made in tb compiler to match (see RuntimeGetUserControlMiscStatus/_FormDesigner constructor)
        ' so that the generated registry MiscStatus key during registration matches.
        ' If Me.OverrideMiscStatus <> 0 Then
        ' 	pdwStatus = OverrideMiscStatus
        '     Exit Sub
        ' End If
        
        Dim outStatus As Long = OLEMISC.OLEMISC_SETCLIENTSITEFIRST Or _
                                OLEMISC.OLEMISC_INSIDEOUT Or _
                                OLEMISC.OLEMISC_CANTLINKINSIDE Or _
                                OLEMISC.OLEMISC_RECOMPOSEONRESIZE Or _
                                OLEMISC.OLEMISC_ACTIVATEWHENVISIBLE
                    
        If Me.ControlContainer = True Then
            outStatus += OLEMISC.OLEMISC_SIMPLEFRAME
        End If
        
        If Me.InvisibleAtRuntime = True Then
            outStatus += OLEMISC.OLEMISC_INVISIBLEATRUNTIME
        End If
        
        If CanGetFocus = False Then
            outStatus += OLEMISC.OLEMISC_NOUIACTIVATE
        End If

        If Alignable = True Then
            outStatus += OLEMISC.OLEMISC_ALIGNABLE
        End If
        
        If DefaultCancel = True Then
            outStatus += OLEMISC.OLEMISC_ACTSLIKEBUTTON
        End If

        If ForwardFocus = True Then
            outStatus += OLEMISC.OLEMISC_ACTSLIKELABEL
        End If
        
        pdwStatus = outStatus
        #If LOG_USERCONTROL Then
            Log("IOleObject_GetMiscStatus", dwAspect, "==>", pdwStatus)
        #End If
    End Sub
    
    Private Sub IOleObject_SetColorScheme(ByVal pLogpal As LongPtr) Implements IOleObject.SetColorScheme
        #If LOG_USERCONTROL Then
            Log("IOleObject_SetColorScheme", pLogpal)
        #End If
    End Sub
    
    Private Sub IPersist_GetClassID(pClassID As GUID) _
            Implements IPersist.GetClassID, _
                        IPersistStreamInit.GetClassID, _
                        IPersistStorage.GetClassID, _
                        IPersistPropertyBag.GetClassID

        #If LOG_USERCONTROL Then
            Log("IPersistStream_GetClassID")
        #End If
        InternalIIDFromString(InternalState.RootCLSID, VarPtr(pClassID))
    End Sub

    Private Sub IPersistStream_IsDirty() Implements IPersistStreamInit.IsDirty, IPersistStorage.IsDirty
        #If LOG_USERCONTROL Then
            Log("IPersistStream_IsDirty")
        #End If
        ' FIXME Access doesn't save for just changes of the control size if we do this
        If InternalState.PropertiesChanged = False Then
             Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
        End If
    End Sub
    
    Private Sub ReadPropertiesFromPropBag(propBag As PropertyBag)
        On Error Resume Next
        
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (1)")
        #End If
        ' Before firing ReadProperties, we need to set the correct size of the control
        ' this will also fire the Resize event, which is expected here, as per VBx
        
        InternalState.[_ExtentX] = CLng(propBag.ReadProperty("_ExtentX", -1))     ' in twips
        InternalState.[_ExtentY] = CLng(propBag.ReadProperty("_ExtentY", -1))     ' in twips

        Debug.TracePrint "ReadPropertiesFromPropBag (2)", "_ExtentX:", InternalState.[_ExtentX], "_ExtentY", InternalState.[_ExtentY]
        
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (2)", "_ExtentX:", _ExtentX, "_ExtentY", _ExtentY)
        #End If
        Dim RootWindowElement As Any = Me.RootWindowElement
        
        If (InternalState.[_ExtentX] = -1) Or (InternalState.[_ExtentY] = -1) Then
        	' Previously, tB serialization didn't include the _ExtentX/_ExtentY values, so we have to get them from the
            '  tb extender instead.  The alternative below is not host-agnostic, but works for our older serializations.
            Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(Me.InternalState.OleClientSite)
            Dim posRect As WinNativeFormsBASE.RECT
            Dim clipRect As WinNativeFormsBASE.RECT
            inPlaceSite.GetWindowContext(Nothing, Nothing, posRect, clipRect, CLngPtr(0))
            InternalSetWindowPos(Me.hWnd, 0, 0, 0, posRect.Right - posRect.Left, posRect.Bottom - posRect.Top, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
            InternalState.[_ExtentX] = RootWindowElement.ScaleX(posRect.Right - posRect.Left, vbPixels, vbTwips)
            InternalState.[_ExtentY] = RootWindowElement.ScaleY(posRect.Bottom - posRect.Top, vbPixels, vbTwips)
        Else
            'InternalChangeSizeNoEvents(Me, Me.RootWindowElement.ScaleX(_ExtentX, vbTwips, vbScaledPixels), Me.RootWindowElement.ScaleY(_ExtentY, vbTwips, vbScaledPixels))
            Dim newPixelWidth As Long
            Dim newPixelHeight As Long
            
            ' If Me.Windowless = True Then
                 newPixelWidth = CLng(RootWindowElement.ScaleX(InternalState.[_ExtentX], vbHimetric, vbPixels))
                 newPixelHeight = CLng(RootWindowElement.ScaleY(InternalState.[_ExtentY], vbHimetric, vbPixels))
            ' 	Stop
            ' Else
            '    newPixelWidth = Me.RootWindowElement.ScaleX(_ExtentX, vbTwips, vbPixels)
            '    newPixelHeight = Me.RootWindowElement.ScaleY(_ExtentY, vbTwips, vbPixels)
            'End If
            
            #If LOG_USERCONTROL Then
                Log("ReadPropertiesFromPropBag (2a)", "calling SetWindowPos", "newPixelWidth", newPixelWidth, "newPixelHeight", newPixelHeight)
            #End If
            Debug.TracePrint "ReadPropertiesFromPropBag (2a)", "calling SetWindowPos", "newPixelWidth", newPixelWidth, "newPixelHeight", newPixelHeight
            InternalSetWindowPos(Me.hWnd, 0, 0, 0, newPixelWidth, newPixelHeight, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)

            ' this is to fix any minor discrepency due to floating point scaling
            'Me.ScaleWidth = Me.RootWindowElement.ScaleX(_ExtentX, vbTwips, Me.ScaleMode)
            'Me.ScaleHeight = Me.RootWindowElement.ScaleY(_ExtentY, vbTwips, Me.ScaleMode)
        End If
                
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (3)")
        #End If
        Me.InternalState.IgnorePropertyChangedNotifications += 1
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
    	RaiseEvent ReadProperties(propBag)      ' This THROWS in the MSACCESS version?
        Me.InternalState.IgnorePropertyChangedNotifications -= 1
        
        InternalState.HasFinishedLoading = True
        #If LOG_USERCONTROL Then
            Log("ReadPropertiesFromPropBag (4)")
        #End If
    End Sub
    
    Private Sub IPersistPropertyBag_Load(ByVal pPropBag As IPropertyBag, ByVal pErrorLog As stdole.IUnknown) Implements IPersistPropertyBag.Load
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Load")
        #End If
        If InternalState.IsInitialized = False Then InitializeMe
        ReadPropertiesFromPropBag(CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCRead2(pPropBag)))
    End Sub
    Private Sub IPersistPropertyBag_Save(ByVal pPropBag As IPropertyBag, ByVal fClearDirty As Long, ByVal fSaveAllProperties As Long) Implements IPersistPropertyBag.Save
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Save")
        #End If
        
        'Stop
        Dim propBag As Any = CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCWrite2(pPropBag))
        #If LOG_USERCONTROL Then
            Log("IPersistPropertyBag_Save(1)")
        #End If
        
        ' FIXME does _ExtentX/Y get set BEFORE or AFTER in the VB6 implementation
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent WriteProperties(propBag)
        
        'Dim twipsWidth As Double = Me.RootWindowElement.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbTwips)
        'Dim twipsHeight As Double = Me.RootWindowElement.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbTwips)
        'Log("IPersistPropertyBag_Save (2)", "Me.ScaleWidth", Me.ScaleWidth, "Me.ScaleHeight", Me.ScaleHeight, "_ExtentX:", twipsWidth, "_ExtentY", twipsHeight)

        Dim twipsWidth As Long
        Dim twipsHeight As Long
        Dim RootWindowElement As Any = Me.RootWindowElement
'         If Me.hWnd <> 0 Then
'             Dim rect As WinNativeFormsBASE.RECT
'             WinNativeFormsBASE.GetWindowRect(Me.hWnd, rect)
'             twipsWidth = RootWindowElement.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric)
'             twipsHeight = RootWindowElement.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric)
'         Else
'         	twipsWidth = RootWindowElement.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbHimetric)
'             twipsHeight = RootWindowElement.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbHimetric)
'         End If
' '        Stop
'         propBag.WriteProperty("_ExtentX", twipsWidth)
'         propBag.WriteProperty("_ExtentY", twipsHeight)
        
        propBag.WriteProperty("_ExtentX", InternalState.[_ExtentX])
        propBag.WriteProperty("_ExtentY", InternalState.[_ExtentY])
                
        If fClearDirty Then
            InternalState.PropertiesChanged = False
        End If
    End Sub
    
    Private Sub IPersistStream_Load(ByVal pstm As WinNativeFormsBASE.IStream) Implements IPersistStreamInit.Load
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load")
        #End If
        
        On Error GoTo StreamError
        Dim A As String = "IPersistStream_Load"
        
        If InternalState.IsInitialized = False Then InitializeMe
        
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load", ObjPtr(pstm))
        #End If
        
        Dim styles As Long = WinNativeFormsBASE.GetWindowLongW(hWnd, WinNativeFormsBASE.WindowProperties.GWL_STYLE)
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load (BEFORE)", "hWnd: ", Hex(hWnd), "oldStyles: ", Hex(styles))
        #End If
        

        Dim streamStats As WinNativeFormsBASE.STATSTG
        pstm.Stat streamStats, WinNativeFormsBASE.STATFLAG_NONAME
                
        Dim currentPosition As LongLong
        pstm.Seek 0, WinNativeFormsBASE.STREAM_SEEK_CUR, currentPosition

        Dim loadData() As Byte
        Dim propBag As PropertyBag
        
        Const magicIdSize As Long = 4
        If streamStats.cbSize >= (currentPosition + magicIdSize) Then
            Dim loadDataLen As Long = CLng(streamStats.cbSize - currentPosition - magicIdSize)
            #If LOG_USERCONTROL Then
                Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen)
            #End If
            
            ' FIXME We use a magic ID header, as we haven't yet checked whether VB6 adds anything 
            '   to the persisted stream other than the property bag data
            Dim magicId As Long
            Dim readAmount As Long
            pstm.Read(VarPtr(magicId), magicIdSize, readAmount)

            If (readAmount = magicIdSize) And (magicId = &HEAEAEAEA) Then
                ReDim loadData(loadDataLen) As Byte

                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen, "... READING")
                #End If
                
                readAmount = 0
                pstm.Read(VarPtr(loadData(0)), loadDataLen, readAmount)
                
                If readAmount = loadDataLen Then
                    ReadPropertiesFromPropBag(CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCRead(loadData)))
                End If
                
                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "SIZE:", loadDataLen, "... DONE")
                #End If
            Else
                #If LOG_USERCONTROL Then
                    Log("IPersistStream_Load", ObjPtr(pstm), "BAD OLE STREAM (MAGIC ID) FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST")
                #End If
                Debug.Print "BAD OLE STREAM (MAGIC ID) FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST"
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent InitProperties()
                InternalSetWindowPos(Me.hWnd, 0, 0, 0, 50, 50, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
            End If
        Else
            #If LOG_USERCONTROL Then
                Log("IPersistStream_Load", ObjPtr(pstm), "BAD OLE STREAM FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST")
            #End If
            Debug.Print "BAD OLE STREAM FOR " & Me.Ambient.DisplayName & ", PERSISTED DATA LOST"

            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent InitProperties()
            InternalSetWindowPos(Me.hWnd, 0, 0, 0, 50, 50, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
        End If
        
        On Error Resume Next
        Dim OleClientSite As Any = Me.InternalState.OleClientSite
        If OleClientSite IsNot Nothing Then OleClientSite.RequestNewObjectLayout()
        
        InternalState.HasFinishedLoading = True
        Exit Sub
        
    StreamError:
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Load", ObjPtr(pstm), "ERROR:", Err.Number, Err.Description)
        #End If
        Err.Raise 5
        
    End Sub
    
    Private Sub IPersistStream_Save(ByVal pstm As WinNativeFormsBASE.IStream, ByVal fClearDirty As Long) Implements IPersistStreamInit.Save
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save", ObjPtr(pstm), fClearDirty)
        #End If
        
        Dim propBag As Any = CType(Of PropertyBag)([_HiddenModule].CreateClassPropertyBagUCWrite())

        ' FIXME does _ExtentX/Y get set BEFORE or AFTER in the VB6 implementation
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent WriteProperties(propBag)
        
        'Dim twipsWidth As Double = Me.RootWindowElement.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbTwips)
        'Dim twipsHeight As Double = Me.RootWindowElement.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbTwips)
        
        Dim twipsWidth As Long
        Dim twipsHeight As Long
        Dim RootWindowElement As Any = Me.RootWindowElement
        If Me.hWnd <> 0 Then
            Dim rect As WinNativeFormsBASE.RECT
            WinNativeFormsBASE.GetWindowRect(Me.hWnd, rect)
            twipsWidth = CLng(RootWindowElement.ScaleX(rect.Right - rect.Left, vbPixels, vbHimetric))
            twipsHeight = CLng(RootWindowElement.ScaleY(rect.Bottom - rect.Top, vbPixels, vbHimetric))
        Else
            twipsWidth = CLng(RootWindowElement.ScaleX(Me.ScaleWidth, Me.ScaleMode, vbHimetric))
            twipsHeight = CLng(RootWindowElement.ScaleY(Me.ScaleHeight, Me.ScaleMode, vbHimetric))
        End If
        
        propBag.WriteProperty("_ExtentX", twipsWidth)
        propBag.WriteProperty("_ExtentY", twipsHeight)
       
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save (2)", "Me.ScaleWidth", Me.ScaleWidth, "Me.ScaleHeight", Me.ScaleHeight, "_ExtentX:", twipsWidth, "_ExtentY", twipsHeight)
        #End If
        
        Dim contentsArray() As Byte
        ' propBag.Contents is artificially restricted, as per the VB6 implementation, so we have to access it differently...
        contentsArray = [_HiddenModule].GetPropertyBagUCWriterContents(propBag)
        
        Dim contentsLength As Long = (UBound(contentsArray) - LBound(contentsArray)) + 1
        #If LOG_USERCONTROL Then
            Log("IPersistStream_Save", "UBOUND: ", UBound(contentsArray), "LBOUND: ", LBound(contentsArray))
            Log("IPersistStream_Save", "LENGTH: ", contentsLength)
        #End If
        
        If contentsLength > 0 Then
            Dim written As Long
            Const magicIdSize As Long = 4
            Dim magicId As Long = &HEAEAEAEA
            pstm.Write(VarPtr(magicId), magicIdSize, written)

            If written <> magicIdSize Then
                Err.Raise 5
            End If

            written = 0
            pstm.Write(VarPtr(contentsArray(0)), contentsLength, written)
        
            If written <> contentsLength Then
                Err.Raise 5
            End If
        End If
        
        If fClearDirty Then
            InternalState.PropertiesChanged = False
        End If
    End Sub
    
    Private Sub IPersistStream_GetSizeMax(pcbSize As LongLong) Implements IPersistStreamInit.GetSizeMax
        #If LOG_USERCONTROL Then
            Log("IPersistStream_GetSizeMax")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub

    Private Sub IPersistStreamInit_InitNew() Implements IPersistStreamInit.InitNew, IPersistPropertyBag.InitNew
        #If LOG_USERCONTROL Then
            Log("IPersistStreamInit_InitNew")
        #End If
        If InternalState.IsInitialized = False Then InitializeMe
        #If LOG_USERCONTROL Then
            Log("IPersistStreamInit_InitNew... DONE")
        #End If
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent InitProperties()
        InternalState.HasFinishedLoading = True
    End Sub
    
    Private Sub IOleControl_GetControlInfo(pCI As CONTROLINFO) Implements IOleControl.GetControlInfo
        #If LOG_USERCONTROL Then
            Log("IOleControl_GetControlInfo")
        #End If
        ' FIXME need to implement this properly        
        pCI.cb = LenB(pCI)
        pCI.cAccel = 0
        pCI.dwFlags = 0
        pCI.hAccel = 0
    End Sub
    
    Private Sub IOleControl_OnMnemonic(pMsg As MSG) Implements IOleControl.OnMnemonic
        #If LOG_USERCONTROL Then
            Log("IOleControl_OnMnemonic")
        #End If
        
        If pMsg.message = WinNativeFormsBASE.WM_KEYDOWN Then
            ' We only support the Cancel/Default values for now.
            If (pMsg.wParam = vbKeyEscape) Or (pMsg.wParam = vbKeyReturn) Or (pMsg.wParam = vbKeyExecute) Then
                Dim asciiKey As Integer = CInt(pMsg.wParam)
                RaiseEvent AccessKeyPress(asciiKey)
            End If
        End If
        ' FIXME need to implement this
        'Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleControl_OnAmbientPropertyChange(ByVal dispID As Long) Implements IOleControl.OnAmbientPropertyChange
        #If LOG_USERCONTROL Then
            Log("IOleControl_OnAmbientPropertyChange", dispID)
        #End If
        Dim namedProp As String
        Select Case dispID
        	Case DISPID_AMBIENT_BACKCOLOR: namedProp = "BackColor"
        	Case DISPID_AMBIENT_DISPLAYNAME: namedProp = "DisplayName"
        	Case DISPID_AMBIENT_FONT: namedProp = "Font"
        	Case DISPID_AMBIENT_FORECOLOR: namedProp = "ForeColor"
        	Case DISPID_AMBIENT_LOCALEID: namedProp = "LocaleID"
        	Case DISPID_AMBIENT_MESSAGEREFLECT: namedProp = "MessageReflect"
        	Case DISPID_AMBIENT_SCALEUNITS: namedProp = "ScaleUnits"
        	Case DISPID_AMBIENT_TEXTALIGN: namedProp = "TextAlign"
        	Case DISPID_AMBIENT_USERMODE: namedProp = "UserMode"
        	Case DISPID_AMBIENT_UIDEAD: namedProp = "UIDead"
        	Case DISPID_AMBIENT_SHOWGRABHANDLES: namedProp = "ShowGrabHandles"
        	Case DISPID_AMBIENT_SHOWHATCHING: namedProp = "ShowHatching"
        	Case DISPID_AMBIENT_DISPLAYASDEFAULT: namedProp = "DisplayAsDefault"
        	Case DISPID_AMBIENT_SUPPORTSMNEMONICS: namedProp = "SupportsMnemonics"
        	'Case DISPID_AMBIENT_AUTOCLIP: namedProp = "AutoClip"
        	'Case DISPID_AMBIENT_APPEARANCE: namedProp = "Appearance"
        	'Case DISPID_AMBIENT_CODEPAGE: namedProp = "CodePage"
        	Case DISPID_AMBIENT_PALETTE: namedProp = "Palette"
        	'Case DISPID_AMBIENT_CHARSET: namedProp = "Charset"
        	'Case DISPID_AMBIENT_TRANSFERPRIORITY: namedProp = "TransferPriority"
        	Case DISPID_AMBIENT_RIGHTTOLEFT: namedProp = "RightToLeft"
        	'Case DISPID_AMBIENT_TOPTOBOTTOM: namedProp = "TopToBottom"
        End Select
        If Len(namedProp) > 0 Then
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent AmbientChanged(namedProp)
        End If
    End Sub
    
    Public AAA_EventsAreFrozen As Boolean
    
    Private Sub IOleControl_FreezeEvents(ByVal bFreeze As Long) Implements IOleControl.FreezeEvents
        #If LOG_USERCONTROL Then
            Log("IOleControl_FreezeEvents", bFreeze)
        #End If
        AAA_EventsAreFrozen = bFreeze <> 0
        CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = bFreeze <> 0
        
        With CType(Of ITwinBasicInternalClassSupport)(Me)
            .FreezeRaiseEvents(CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen)
        End With
        
        If (CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False) And (InternalState.QueuedShowEvent = True) Then
            ' Can't RaiseEvent Show/Hide directly here, as Access doesn't change the internal freeze-event state until we've returned from this call
            ' Switching from DesignView to FormView demonstrates the problem, where we further RaiseEvent on the host inside the Show/Hide implementation
            Me.ScheduleCallback(Me)
        End If
    End Sub
    
    Private Sub IScheduledCallback_Execute()
        If (CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).EventsAreFrozen = False) And (InternalState.QueuedShowEvent = True) Then
            InternalState.QueuedShowEvent = False
            If InternalState.ActualVisibilityState <> InternalState.ConsumerVisibilityState Then
                InternalState.ConsumerVisibilityState = InternalState.ActualVisibilityState
                    
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                    
                If InternalState.ActualVisibilityState Then
                    RaiseEvent Show()
                Else
                    RaiseEvent Hide()
                End If
            End If
        End If
    End Sub

    Private Sub IProvideClassInfo_GetClassInfo(ByRef ppTI As ITypeInfo) Implements IProvideClassInfo.GetClassInfo
        #If LOG_USERCONTROL Then
            Log("IProvideClassInfo_GetClassInfo")
        #End If
        
        SetOutParamToNothing(VarPtr(ppTI))

        Dim tlib As ITypeLib
        InternalLoadTypeLib(Global.App.ModulePath, tlib)

        If tlib Is Nothing Then
        	'Debug.Print "ActiveX TypeLib error: unable to load type library from file [" & Global.App.ModulePath & "]"
            Exit Sub
        End If

        #If LOG_USERCONTROL Then
            Log("TYPELIB: " & ObjPtr(tlib))
        #End If
        
        Dim guid As WinNativeFormsBASE.GUID2
        InternalIIDFromString(InternalState.RootCLSID, VarPtr(guid))
        tlib.GetTypeInfoOfGuid(guid, ppTI)

        If ppTI Is Nothing Then
        	Debug.Print "ActiveX TypeLib error: unable to load type info from file [" & Global.App.ModulePath & "]"
            Exit Sub
        End If

        #If LOG_USERCONTROL Then
            Log("TYPEINFO: " & ObjPtr(ppTI))
        #End If
    End Sub
        
    Private Sub IViewObject_Draw(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByVal ptd As LongPtr, ByVal hdcTargetDev As LongPtr, ByVal hdcDraw As LongPtr, lprcBounds As WinNativeFormsBASE.RECT, lprcWBounds As WinNativeFormsBASE.RECT, ByVal pfnContinue As LongPtr, ByVal dwContinue As LongPtr) Implements IViewObject.Draw
        #If LOG_USERCONTROL Then
            Log("IViewObject_Draw", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw), "lprcBounds: ", VarPtr(lprcBounds))
        #End If
        
        If Me.InternalState.IsWindowlessActivated Then
            #If LOG_USERCONTROL Then
                Log("IViewObject_Draw", "*** WINDOWLESS ***", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw))
            #End If
                    
                ' We're drawing into the containers window, so we need to adjust the coordinate system so that drawing occurs offset
                Dim oldViewPort As WinNativeFormsBASE.POINT
                InternalGetViewportOrgEx(hdcDraw, oldViewPort)
                InternalSetViewportOrgEx(hdcDraw, oldViewPort.X + InternalState.WindowlessRect.Left, oldViewPort.Y + InternalState.WindowlessRect.Top, CLngPtr(0))
                #If LOG_USERCONTROL Then
                    Log("IViewObject_Draw", "WindowlessRect.Left:", WindowlessRect.Left, "WindowlessRect.Top:", WindowlessRect.Top, "oldViewPort.X:", oldViewPort.X, "oldViewPort.Y:", oldViewPort.Y)
                #End If
                Me.OnPaint(hdcDraw, True)
                InternalSetViewportOrgEx(hdcDraw, oldViewPort.X, oldViewPort.Y, CLngPtr(0))
            
                #If LOG_USERCONTROL Then
                    Log("IViewObject_Draw", "--> DONE")
                #End If
                
        ElseIf (VarPtr(lprcBounds) <> 0) And (hdcDraw <> 0) Then
            'If WindowIsInPlace = False Then
            
                ' This method does not work well on older OSes, e.g. Win 7 it will produce black rect due to the OS not allowing capture from offscreen areas
                'Int3Breakpoint
                
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "dwDrawAspect: ", dwDrawAspect, "lindex: ", lindex, "pvAspect: ", Hex(pvAspect), "ptd: ", Hex(ptd), "hdcDraw: ", Hex(hdcDraw), "lprcBounds.Left: ", lprcBounds.Left, "lprcBounds.Top: ", lprcBounds.Top, "lprcBounds.Right: ", lprcBounds.Right, "lprcBounds.Bottom: ", lprcBounds.Bottom)
                ' #End If
                    
                ' ' This won't actually make the window visible on screen, as the parent is a 0x0 window
                ' '  VBx seems to use this method rather than ShowWindow
                ' Dim oldStyles As Long = WinNativeFormsBASE.GetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE)
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "oldStyles: ", Hex(oldStyles))
                ' #End If
                
                ' WinNativeFormsBASE.SetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE, oldStyles Or WinNativeFormsBASE.WS_VISIBLE)
                ' 'UpdateWindow(hWnd)          ' FIXME is this needed?
                                
                ' Dim hDC As LongPtr = WinNativeFormsBASE.CreateCompatibleDC(hdcDraw)

                ' Dim _width As Long = lprcBounds.Right - lprcBounds.Left
                ' Dim _height As Long = lprcBounds.Bottom - lprcBounds.Top
                
                ' ' Use the provided width/height for the drawing.  This is needed to support VBA UserForm 'Zoom' property
                ' Dim widthBefore As Double = Me.PixelsWidth * Me.DpiScale
                ' Dim heightBefore As Double = Me.PixelsHeight * Me.DpiScale
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos")
                ' #End If
                
                ' InternalSetWindowPos(Me.hWnd, 0, 0, 0, _width, _height, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                ' #End If
                
                
                ' Dim lpBits As LongPtr = [_HiddenModule].AllocMem(_width * _height * 4)
                ' Dim hbmp As LongPtr = InternalCreateBitmap(_width, _height, 1, 32, lpBits)
                ' Dim oldBitmap As LongPtr = WinNativeFormsBASE.SelectObject(hDC, hbmp)
                
                ' InternalPrintWindow(hWnd, hDC, 0)
                ' WinNativeFormsBASE.BitBlt(hdcDraw, lprcBounds.Left, lprcBounds.Top, Width, Height, hDC, 0, 0, vbSrcCopy)

                ' WinNativeFormsBASE.SelectObject(hDC, oldBitmap)
                ' WinNativeFormsBASE.DeleteDC(hDC)
                ' WinNativeFormsBASE.DeleteObject(hbmp)

                ' [_HiddenModule].FreeMem(lpBits)
                
                ' WinNativeFormsBASE.SetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE, oldStyles)
                
                
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos (reverting)")
                ' #End If
                
                ' InternalSetWindowPos(Me.hWnd, 0, 0, 0, widthBefore, heightBefore, WinNativeFormsBASE.SWP_NOMOVE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
                ' #If LOG_USERCONTROL Then
                '     Log("IOleObject_DoVerb", "calling SetWindowPos... DONE", "Me.PixelsWidth(AFTER)", Me.PixelsWidth, "Me.PixelsHeight(AFTER)", Me.PixelsHeight)
                ' #End If
                
                ' #If LOG_USERCONTROL Then
                '     Log("IViewObject_Draw", "--> DONE")
                ' #End If
                
                
                
                Dim _width As Long = lprcBounds.Right - lprcBounds.Left
                Dim _height As Long = lprcBounds.Bottom - lprcBounds.Top

                Dim oldStyles As Long = WinNativeFormsBASE.GetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE)
                Dim oldExStyles As Long = WinNativeFormsBASE.GetWindowLongW(hWnd, WinNativeFormsBASE.GWL_EXSTYLE)
                WinNativeFormsBASE.SetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE, oldStyles Or WinNativeFormsBASE.WS_VISIBLE)
               
                Dim hDC As LongPtr = WinNativeFormsBASE.CreateCompatibleDC(hdcDraw)
                Dim hbmp As LongPtr = WinNativeFormsBASE.CreateCompatibleBitmap(hdcDraw, _width, _height)
                Dim oldBitmap As LongPtr = WinNativeFormsBASE.SelectObject(hDC, hbmp)
                
                'WinNativeFormsBASE.SendMessageW(hWnd, WinNativeFormsBASE.WM_ERASEBKGND, hDC, 0) 'Causes double _Print event to be fired due to it already firing from our internal WM_PRINTCLIENT implementation
                Dim oldRect As WinNativeFormsBASE.RECT
                WinNativeFormsBASE.GetWindowRect(hWnd, oldRect)
                InternalSetWindowPos(hWnd, 0, 0, 0, _width, _height, WinNativeFormsBASE.SWP_NOACTIVATE)
                WinNativeFormsBASE.SendMessageW(hWnd, WinNativeFormsBASE.WM_PRINTCLIENT, hDC, &H80000006&)    ' client and non-client area plus flag only used by us
                WinNativeFormsBASE.BitBlt(hdcDraw, lprcBounds.Left, lprcBounds.Top, _width, _height, hDC, 0, 0, vbSrcCopy)
                WinNativeFormsBASE.SetWindowLongW(hWnd, WinNativeFormsBASE.GWL_STYLE, oldStyles)
                WinNativeFormsBASE.SelectObject(hDC, oldBitmap)
                WinNativeFormsBASE.DeleteObject(hbmp)
                WinNativeFormsBASE.DeleteDC(hDC)
                InternalSetWindowPos(hWnd, 0, oldRect.Left, oldRect.Top, oldRect.Right - oldRect.Left, oldRect.Bottom - oldRect.Top, WinNativeFormsBASE.SWP_NOACTIVATE)
                
           ' End If

            If hWnd <> 0 Then
                'Debug.Print "IViewObject_Draw", Hex(hWnd), lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top
                'SetWindowPos(hWnd, 0, lprcBounds.Left, lprcBounds.Top, lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top, 0)
                'Me.PixelsLeft = lprcBounds.Left
                'Me.PixelsTop = lprcBounds.Top
                'Me.PixelsWidth = lprcBounds.Right - lprcBounds.Left
                'Me.PixelsHeight = lprcBounds.Bottom - lprcBounds.Top
                'Me.InternalMove(Me, lprcBounds.Left, lprcBounds.Top, lprcBounds.Right - lprcBounds.Left, lprcBounds.Bottom - lprcBounds.Top)
                'Me.ControlContext.ChangedPosition()
            End If
        End If
        
        #If LOG_USERCONTROL Then
            Log("IViewObject_Draw ... DONE", VarPtr(lprcBounds))
        #End If
    End Sub
    
    Private Sub IViewObject_GetColorSet(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal ppColorSet As LongPtr) Implements IViewObject.GetColorSet
        #If LOG_USERCONTROL Then
            Log("IViewObject_GetColorSet", dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, ppColorSet)
        #End If
    End Sub
    
    Private Sub IViewObject_Freeze(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, pdwFreeze As Long) Implements IViewObject.Freeze
        #If LOG_USERCONTROL Then
            Log("IViewObject_Freeze", dwDrawAspect, lindex, pvAspect)
        #End If
    End Sub
    
    Private Sub IViewObject_Unfreeze(ByVal dwFreeze As Long) Implements IViewObject.Unfreeze
        #If LOG_USERCONTROL Then
            Log("IViewObject_Unfreeze", dwFreeze)
        #End If
    End Sub
    
    Private Sub IViewObject_SetAdvise(ByVal aspects As Long, ByVal advf As Long, ByVal pAdvSink As WinNativeFormsBASE.IAdviseSink) Implements IViewObject.SetAdvise
        #If LOG_USERCONTROL Then
            Log("IViewObject_SetAdvise", aspects, advf, ObjPtr(pAdvSink))
        #End If
        Set InternalState.IViewObject_adviseSink = pAdvSink
    End Sub
    
    Private Sub IViewObject_GetAdvise(pAspects As Long, pAdvf As Long, ppAdvSink As WinNativeFormsBASE.IAdviseSink) Implements IViewObject.GetAdvise
        #If LOG_USERCONTROL Then
            Log("IViewObject_GetAdvise", pAspects, pAdvf, ObjPtr(ppAdvSink))
        #End If
        SetOutParamToNothing(VarPtr(ppAdvSink))
        Set ppAdvSink = InternalState.IViewObject_adviseSink
    End Sub
    
    
    Private Sub IViewObjectEx_Draw(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, _ 
                ByVal ptd As LongPtr, ByVal hdcTargetDev As LongPtr, ByVal hdcDraw As LongPtr, _
                ByRef lprcBounds As WinNativeFormsBASE.RECT, ByRef lprcWBounds As WinNativeFormsBASE.RECT, ByVal pfnContinue As LongPtr, ByVal dwContinue As LongPtr)
        IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hdcTargetDev, hdcDraw, lprcBounds, lprcWBounds, pfnContinue, dwContinue)
    End Sub
    Private Sub IViewObjectEx_GetColorSet(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, _ 
                ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal ppColorSet As LongPtr)
        IViewObject_GetColorSet(dwDrawAspect, lindex, pvAspect, ptd, ByVal hicTargetDev, ppColorSet)
    End Sub
    Private Sub IViewObjectEx_Freeze(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal pvAspect As LongPtr, ByRef pdwFreeze As Long)
        IViewObject_Freeze(dwDrawAspect, lindex, pvAspect, pdwFreeze)
    End Sub
    Private Sub IViewObjectEx_Unfreeze(ByVal dwFreeze As Long)
        IViewObject_Unfreeze(dwFreeze)
    End Sub
    Private Sub IViewObjectEx_SetAdvise(ByVal aspects As Long, ByVal advf As Long, ByVal pAdvSink As WinNativeFormsBASE.IAdviseSink)
        IViewObject_SetAdvise(aspects, advf, pAdvSink)
    End Sub
    Private Sub IViewObjectEx_GetAdvise(ByRef pAspects As Long, ByRef pAdvf As Long, ByRef ppAdvSink As WinNativeFormsBASE.IAdviseSink)
        IViewObject_GetAdvise(pAspects, pAdvf, ppAdvSink)
    End Sub
    Private Sub IViewObjectEx_GetExtent(ByVal dwDrawAspect As Long, ByVal lindex As Long, ByVal ptd As LongPtr, ByRef lpsizel As SIZEL)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetExtent", dwDrawAspect, lindex, Hex(ptd))
        #End If
        IOleObject_GetExtent(dwDrawAspect, lpsizel)
    End Sub
    Private Sub IViewObjectEx_GetRect(ByVal dwAspect As Long, ByRef pRect As WinNativeFormsBASE.RECT)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetRect", dwAspect)
        #End If
        LSet pRect = InternalState.WindowlessRect
    End Sub
    Private Sub IViewObjectEx_GetViewStatus(ByRef pdwStatus As Long)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetViewStatus")
        #End If
        If Me.BackStyle = BackFillStyleConstants.vbBFOpaque Then
        	pdwStatus = 1 ' VIEWSTATUS_OPAQUE
        Else
            pdwStatus = 0   ' transparent
        End If
        /*
        VIEWSTATUS_OPAQUE = 1,
        VIEWSTATUS_SOLIDBKGND = 2,
        VIEWSTATUS_DVASPECTOPAQUE = 4,
        VIEWSTATUS_DVASPECTTRANSPARENT = 8,
        VIEWSTATUS_SURFACE = 16,
        VIEWSTATUS_3DSURFACE = 32
        */
    End Sub
    Private Sub IViewObjectEx_QueryHitPoint(ByVal dwAspect As Long, ByRef pRectBounds As WinNativeFormsBASE.RECT, ByVal ptlLocXY As LongLong, ByVal lCloseHint As Long, ByRef pHitResult As Long)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_QueryHitPoint")
        #End If
        
        If InternalState.IsWindowlessActivated And (BackStyle = BackFillStyleConstants.vbBFTransparent) Then
            Dim hitResult As Integer = CInt(vbHitResultTransparent)       ' I think HitTestBehaviour affects this initial value
            Dim X As Single = CSng(ptlLocXY And &HFFFFFFFF^)
            Dim Y As Single = CSng(ptlLocXY >> 16 >> 16)     ' FIXME >> bug
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent HitTest(CSng(X - pRectBounds.Left), CSng(Y - pRectBounds.Top), hitResult)
            pHitResult = hitResult
        Else
            pHitResult = vbHitResultHit
        End If
    End Sub
    Private Sub IViewObjectEx_QueryHitRect(ByVal dwAspect As Long, ByRef pRectBounds As WinNativeFormsBASE.RECT, ByRef pRectLoc As WinNativeFormsBASE.RECT, ByVal lCloseHint As Long, ByRef pHitResult As Long)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_QueryHitRect")
        #End If
        
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    Private Sub IViewObjectEx_GetNaturalExtent(ByVal dwAspect As Long, ByVal lindex As Long, ByVal ptd As LongPtr, ByVal hicTargetDev As LongPtr, ByVal pExtentInfo As LongPtr, ByRef pSizel As SIZEL)
        #If LOG_USERCONTROL Then
            Log("IViewObjectEx_GetNaturalExtent")
        #End If
        
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub


    Private Sub IPersistStorage_InitNew(ByVal pStg As WinNativeFormsBASE.IStorage) Implements VB.IPersistStorage.InitNew
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_InitNew", ObjPtr(pStg))
        #End If
        
        If InternalState.IsInitialized = False Then InitializeMe
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        RaiseEvent InitProperties()
        InternalState.HasFinishedLoading = True
    End Sub
    
    Private Sub IPersistStorage_Load(ByVal pStg As WinNativeFormsBASE.IStorage) Implements VB.IPersistStorage.Load
        Dim A As String = "IPersistStorage_Load"
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg))
        #End If

        On Error GoTo StreamError

        Dim stream As WinNativeFormsBASE.IStream
        pStg.OpenStream(StrPtr("DATA"), 0, WinNativeFormsBASE.STGM_READ Or WinNativeFormsBASE.STGM_SHARE_EXCLUSIVE, 0, stream)
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg), ObjPtr(stream))
        #End If
        
        IPersistStream_Load(stream)
        
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Load", ObjPtr(pStg), "... DONE")
        #End If
        
        Exit Sub
        
StreamError:
        MsgBox("ActiveX Stream Error: " & Hex(Err.Number) & ", " & Err.Description)
        Err.ReturnHResult = &H800AEAEA
    End Sub

    Private Sub IPersistStorage_Save(ByVal pStg As WinNativeFormsBASE.IStorage) Implements VB.IPersistStorage.Save
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg))
        #End If
        
        On Error GoTo StreamError

        Dim stream As WinNativeFormsBASE.IStream
        pStg.CreateStream(StrPtr("DATA"), WinNativeFormsBASE.STGM_CREATE Or WinNativeFormsBASE.STGM_READWRITE Or WinNativeFormsBASE.STGM_SHARE_EXCLUSIVE, 0, 0, stream)
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg), " [1]", ObjPtr(stream))
        #End If
        
        IPersistStream_Save(stream, 1)
        
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_Save", ObjPtr(pStg), "... DONE")
        #End If
        Exit Sub
        
    StreamError:
        MsgBox("ActiveX Stream Error: " & Hex(Err.Number) & ", " & Err.Description)
    End Sub

    Private Sub IPersistStorage_SaveCompleted(ByVal pStgNew As WinNativeFormsBASE.IStorage) Implements VB.IPersistStorage.SaveCompleted
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_SaveCompleted", ObjPtr(pStgNew))
        #End If
    End Sub

    Private Sub IPersistStorage_HandsOffStorage() Implements VB.IPersistStorage.HandsOffStorage
        #If LOG_USERCONTROL Then
            Log("IPersistStorage_HandsOffStorage")
        #End If
    End Sub
    
    Private Sub IUnsupportedInterface_UnsupportedInterfaceRequested(ByRef iid As WinNativeFormsBASE.GUID2, ByRef out As stdole.IUnknown) Implements IUnsupportedInterface.UnsupportedInterfaceRequested
        Dim temp As String = String$(40, " ")
        InternalStringFromGUID2(iid, StrPtr(temp), 40)
        #If LOG_USERCONTROL Then
            Log("UNSUPPORTED-INTERFACE: " & temp)
        #End If
    End Sub
    
    Sub Refresh()
    	If Me.Windowless = True Then
            WinNativeFormsBASE.WindowsAPI.InvalidateRect(Me.ContainerHwnd, Me.InternalState.WindowlessRect, 1)
            'WinNativeFormsBASE.WindowsAPI.USER32_RedrawWindow(Me.RootWindowElement, 0, 0, WinNativeFormsBASE.RDW_ERASE Or WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_UPDATENOW)
        Else
            WinNativeFormsBASE.WindowsAPI.USER32_RedrawWindow(Me.RootWindowElement, 0, 0, WinNativeFormsBASE.RDW_ERASE Or WinNativeFormsBASE.RDW_INVALIDATE Or WinNativeFormsBASE.RDW_UPDATENOW)
        End If
    End Sub
    
    Private Sub IOleInPlaceObject_InPlaceDeactivate() Implements IOleInPlaceObject.InPlaceDeactivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate")
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 1"
        
        If InternalState.ConsumerVisibilityState = True Then
            InternalState.ConsumerVisibilityState = False
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            RaiseEvent Hide()
            On Error GoTo 0
        End If

        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 2"
        
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 1)
        #End If
        
'        Stop
        Dim site As IOleInPlaceSite = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        On Error Resume Next
        site.OnUIDeactivate(0)
        
        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "OnUIDeactivate Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 3"
        

        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 2)
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 4"
        
        Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        controlSite.OnFocus(0)

        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "controlSite.OnFocus(0) Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If

        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 3)
        #End If
        
        If InternalState.IsTbDebugging = False Then
            On Error Resume Next
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 5"
        
        If InternalState.hasFocusOnChild = True Then RaiseEvent ExitFocus()
        If InternalState.hasFocus = True Then RaiseEvent LostFocus()
                
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_InPlaceDeactivate", 4)
        #End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 6"
        
        
        ' Doing this causes problems with controls sited on Excel/VBA multi-page control
        ' when switching between pages, VBA UserForm invokes IOleInPlaceObject_InPlaceDeactivate
        ' and the below call then triggers WM_DESTROY to be sent to our window, presumably because the container HWND is destroyed
        ' So first, we detach ourselves from the parent, so that we don't receive WM_DESTROY
        InternalShowWindow(RootWindowElement.Handle, WinNativeFormsBASE.SW_HIDE)
        InternalSetParent(RootWindowElement.Handle, 0)
        site.OnInPlaceDeactivate()
        InternalState.WindowIsInPlace = False
        'Set siteFrame = Nothing
        
        If Err.Number <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_InPlaceDeactivate", "site.OnInPlaceDeactivate Err.Number:", Hex(Err.Number))
            #End If
            Err.Clear
        End If
        
        Debug.TracePrint "IOleInPlaceObject_InPlaceDeactivate *** 7"
        
    End Sub
    
    Private Sub IOleInPlaceObject_GetWindow(phwnd As LongPtr) _
            Implements IOleInPlaceObject.GetWindow, _
                        IOleInPlaceActiveObject.GetWindow
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_GetWindow")
        #End If
        
        If Me.InternalState.IsWindowlessActivated Then
        	phwnd = 0
            Exit Sub
        End If
        
        Dim RootWindowElement As Any = Me.RootWindowElement
        If RootWindowElement IsNot Nothing Then
            phwnd = RootWindowElement.Handle
        End If
        
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_GetWindow... DONE, returned: ", phwnd)
        #End If
    End Sub
    
    Private Sub IOleInPlaceObject_ContextSensitiveHelp(ByVal fEnterMode As Long) _
            Implements IOleInPlaceObject.ContextSensitiveHelp, _
                        IOleInPlaceActiveObject.ContextSensitiveHelp
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_ContextSensitiveHelp")
        #End If
        
'        Stop
    End Sub
    
    Private Sub IOleInPlaceObject_ReactivateAndUndo() Implements IOleInPlaceObject.ReactivateAndUndo
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_ReactivateAndUndo")
        #End If
        
'        Stop
    End Sub
    
    Private Sub IOleInPlaceObject_SetObjectRects(lprcPosRect As WinNativeFormsBASE.RECT, lprcClipRect As WinNativeFormsBASE.RECT) Implements IOleInPlaceObject.SetObjectRects
       ' Stop
       Dim RootWindowElement As Any = Me.RootWindowElement
       
       'Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Left: " & lprcPosRect.Left & " .Top: " & lprcPosRect.Top & " .Right: " & lprcPosRect.Right & " .Bottom: " & lprcPosRect.Bottom & " HEIGHT: " & (lprcPosRect.Bottom - lprcPosRect.Top)
       'InternalSetWindowPos(RootWindowElement.Handle, 0, lprcPosRect.Left, lprcPosRect.Top, (lprcPosRect.Right - lprcPosRect.Left), (lprcPosRect.Bottom - lprcPosRect.Top), 0)
       
       'Exit Sub
       
       
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_SetObjectRects", "VarPtr(lprcPosRect)", VarPtr(lprcPosRect), "VarPtr(lprcClipRect)", VarPtr(lprcClipRect))
        #End If
        If VarPtr(lprcPosRect) <> 0 Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_SetObjectRects", "width:", lprcPosRect.Right - lprcPosRect.Left, "height:", lprcPosRect.Bottom - lprcPosRect.Top)
            #End If
        Else
            Exit Sub
        End If

        Dim NoChange As Boolean = False
        
        Dim newLeft As Double = lprcPosRect.Left / RootWindowElement.UnitPixelScale
        Dim newTop As Double = lprcPosRect.Top / RootWindowElement.UnitPixelScale
        Dim newWidth As Double = (lprcPosRect.Right - lprcPosRect.Left) / RootWindowElement.UnitPixelScale
        Dim newHeight As Double = (lprcPosRect.Bottom - lprcPosRect.Top) / RootWindowElement.UnitPixelScale
        
        If Me.Windowless Then
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_SetObjectRects *** WINDOWLESS")
            #End If
            LSet InternalState.WindowlessRect = lprcPosRect
            
            NoChange = (Me.PixelsLeft = newLeft) AndAlso (Me.PixelsTop = newTop) AndAlso _
                       (Me.PixelsWidth = newWidth) AndAlso (Me.PixelsHeight = newHeight)
        Else
            Dim windowRect As WinNativeFormsBASE.RECT
            WinNativeFormsBASE.GetWindowRect(RootWindowElement.Handle, windowRect)
            Dim parentHwnd As LongPtr = WinNativeFormsBASE.GetParent(RootWindowElement.Handle)
            Dim topLeftPoint As POINT
            topLeftPoint.x = windowRect.Left
            topLeftPoint.y = windowRect.Top
            WinNativeFormsBASE.ScreenToClient(parentHwnd, topLeftPoint)
            Dim bottomRightPoint As POINT
            bottomRightPoint.x = windowRect.Right
            bottomRightPoint.y = windowRect.Bottom
            WinNativeFormsBASE.ScreenToClient(parentHwnd, bottomRightPoint)
            
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Left: " & topLeftPoint.x
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Top: " & topLeftPoint.y
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Right: " & bottomRightPoint.x
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects windowRect.Bottom: " & bottomRightPoint.y
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Left: " & lprcPosRect.Left
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Top: " & lprcPosRect.Top
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Right: " & lprcPosRect.Right
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects lprcPosRect.Bottom: " & lprcPosRect.Bottom
            
            NoChange = (topLeftPoint.x = lprcPosRect.Left) AndAlso (topLeftPoint.y = lprcPosRect.Top) AndAlso _
                    (bottomRightPoint.x = lprcPosRect.Right) AndAlso (bottomRightPoint.y = lprcPosRect.Bottom)
        End If
        
        If NoChange Then
            Debug.TracePrint "IOleInPlaceObject_SetObjectRects", "*** NO CHANGE"
            #If LOG_USERCONTROL Then
                Log("IOleInPlaceObject_SetObjectRects", "*** NO CHANGE")
            #End If
            Exit Sub
            If InternalState.InitialResizeEventFired = False Then
                Dim HasFinishedLoading As Boolean = Me.InternalState.HasFinishedLoading
                Me.InternalState.IgnorePropertyChangedNotifications += (HasFinishedLoading = False)
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                RaiseEvent Resize()
                Me.InternalState.IgnorePropertyChangedNotifications -= (HasFinishedLoading = False)
                InternalState.InitialResizeEventFired = True
            End If
            Exit Sub
        End If
        
        Debug.TracePrint "IOleInPlaceObject_SetObjectRects", "*** CHANGE DETECTED"
        
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_SetObjectRects", "*** CHANGE DETECTED!")
        #End If
        InternalState.MutedResizeEventsCount += 1
        '    Me.PixelsLeft = newLeft
        '    Me.PixelsTop = newTop
        '    Me.PixelsWidth = newWidth
       '     Me.PixelsHeight = newHeight
            InternalSetWindowPos(RootWindowElement.Handle, 0, lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right - lprcPosRect.Left, lprcPosRect.Bottom - lprcPosRect.Top, WinNativeFormsBASE.SWP_NOACTIVATE)
      ' MsgBox "Me.PixelsHeight: " & Me.PixelsHeight & ", newHeight: " & newHeight
      InternalState.MutedResizeEventsCount -= 1
 
        'Debug.Print Now() & " **** CHANGED WIDTH: " & Me.PixelsWidth
        'Stop
        'Me.InternalMove(Me, lprcPosRect.Left, lprcPosRect.Top, lprcPosRect.Right - lprcPosRect.Left, lprcPosRect.Bottom - lprcPosRect.Top)
        Me.ControlContext.ChangedPosition()
        InternalRaiseResize()
    End Sub
    
    Private Sub IOleInPlaceObject_UIDeactivate() Implements IOleInPlaceObject.UIDeactivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObject_UIDeactivate")
        #End If
                
        Me.RootWindowElement.DeactivateStart()
        
        'Dim controlSite As IOleControlSite = OleClientSite
        'controlSite.OnFocus(0)
        
        Dim inPlaceSite As Any = CType(Of IOleInPlaceSite)(InternalState.OleClientSite)
        On Error Resume Next
        Debug.TracePrint "*** IOleInPlaceObject_UIDeactivate STARTED"
        inPlaceSite.OnUIDeactivate(0)           ' this is needed, else once we get focus, other controls stop working in UserForms
        Debug.TracePrint "*** IOleInPlaceObject_UIDeactivate DONE"
        DoEvents()      ' needed, otherwise two iGrids on same form cause freeze due to fighting over focus
        Me.RootWindowElement.DeactivateEnd()
        
    End Sub
    
    Private Sub IOleInPlaceObjectWindowless_GetWindow(ByRef phwnd As LongPtr)
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_GetWindow")
        #End If
        phwnd = 0       ' windowless
    End Sub
    Private Sub IOleInPlaceObjectWindowless_ContextSensitiveHelp(ByVal fEnterMode As Long)
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_ContextSensitiveHelp", fEnterMode)
        #End If
    End Sub
    Private Sub IOleInPlaceObjectWindowless_InPlaceDeactivate()
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_InPlaceDeactivate")
        #End If
    	IOleInPlaceObject_InPlaceDeactivate()
    End Sub
    Private Sub IOleInPlaceObjectWindowless_UIDeactivate()
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_UIDeactivate")
        #End If
    	IOleInPlaceObject_UIDeactivate()
    End Sub
    Private Sub IOleInPlaceObjectWindowless_SetObjectRects(ByRef lprcPosRect As WinNativeFormsBASE.RECT, ByRef lprcClipRect As WinNativeFormsBASE.RECT)
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_SetObjectRects")
        #End If
    	IOleInPlaceObject_SetObjectRects(lprcPosRect, lprcClipRect)
    End Sub
    Private Sub IOleInPlaceObjectWindowless_ReactivateAndUndo()
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_ReactivateAndUndo")
        #End If
    	IOleInPlaceObject_ReactivateAndUndo()
    End Sub
    
    Private MouseCapturingControl As Control = Nothing
    Private Sub BeginWindowlessMouseCapture(targetControl As Control)
        #If LOG_USERCONTROL Then
            Log("BeginWindowlessMouseCapture", targetControl.Name)
        #End If
        On Error Resume Next
        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
        siteWindowless.SetCapture(1)
        Set MouseCapturingControl = targetControl
    End Sub
    Private Function EndWindowlessMouseCapture(targetControl As Control) As Boolean
        #If LOG_USERCONTROL Then
            Log("EndWindowlessMouseCapture")
        #End If
        
        If MouseCapturingControl Is targetControl Then
            #If LOG_USERCONTROL Then
                Log("EndWindowlessMouseCapture", targetControl.Name)
            #End If
            
            Set MouseCapturingControl = Nothing
            On Error Resume Next
            Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
            siteWindowless.SetCapture(0)
            Return True
        End If
        Return False
    End Function
    
'        Private IsSettingFocusToUs As Boolean
    Private Sub IOleInPlaceObjectWindowless_OnWindowMessage(ByVal msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, ByRef lpResult As LongPtr)
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_OnWindowMessage", Hex(msg), Hex(wParam), Hex(lParam))
        #End If
        
        Dim x As Long
        Dim y As Long
        Dim targetControl As Control
        Dim mouseEventName As String
        Dim eventNeedsArgs As Boolean = True
        Dim setMouseCapture As Boolean = False
        Dim releaseMouseCapture As Boolean = False
        Dim shiftState As Integer
        
        Select Case msg
            Case WinNativeFormsBASE.WM_SETFOCUS
                InternalState.hasFocus = True
                'If IsSettingFocusToUs = True Then
                '    Set controlSite = OleClientSite
                    'controlSite.OnFocus(1)
                'End If
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent EnterFocus()
                RaiseEvent GotFocus()
                        
            Case WinNativeFormsBASE.WM_KILLFOCUS
                InternalState.hasFocus = False
                'Set controlSite = OleClientSite
                'controlSite.OnFocus(0)
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent LostFocus()
                RaiseEvent ExitFocus()
            
            Case WinNativeFormsBASE.WM_MOUSEMOVE
                mouseEventName = "MouseMove"
            
            Case WinNativeFormsBASE.WM_LBUTTONDOWN, _
                    WinNativeFormsBASE.WM_MBUTTONDOWN, _
                    WinNativeFormsBASE.WM_RBUTTONDOWN
                mouseEventName = "MouseDown"
                setMouseCapture = True
                
                If (CanGetFocus = True) And (InternalState.hasFocus = False) Then
                    
                    Dim site As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.OnUIActivate()")
                    #End If
                    
                    site.OnUIActivate()         ' by calling this now, prevents the next controlSite.OnFocus(1) call from triggering DoVerb(OLEIVERB_INPLACEACTIVATE)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.OnUIActivate()... DONE")
                    #End If
                    
                    If InternalState.siteFrame IsNot Nothing Then
                        #If LOG_USERCONTROL Then
                            Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> siteFrame.SetMenu(0, 0, 0)")
                        #End If
                        
                        On Error Resume Next
                        InternalState.siteFrame.SetMenu(0, 0, 0) ' this can throw
                        On Error GoTo 0
                        #If LOG_USERCONTROL Then
                            Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> siteFrame.SetMenu(0, 0, 0)... DONE")
                        #End If
                        
                    End If

                    Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.SetFocus(1)")
                    #End If
                    
                    'IsSettingFocusToUs = True
                    site.SetFocus(1)
                    'IsSettingFocusToUs = False
                    #If LOG_USERCONTROL Then
                        Log("IOleInPlaceObjectWindowless_OnWindowMessage WM_BUTTONDOWN -> site.SetFocus(1)... DONE")
                    #End If
                    
                End If
            
            Case WinNativeFormsBASE.WM_LBUTTONUP, _
                    WinNativeFormsBASE.WM_MBUTTONUP, _
                    WinNativeFormsBASE.WM_RBUTTONUP
         	    mouseEventName = "MouseUp"
                releaseMouseCapture = True
            
            Case WinNativeFormsBASE.WM_LBUTTONDBLCLK, _
                    WinNativeFormsBASE.WM_MBUTTONDBLCLK, _
                    WinNativeFormsBASE.WM_RBUTTONDBLCLK
                mouseEventName = "DblClick"
                eventNeedsArgs = False
            
            Case WinNativeFormsBASE.WM_SYSKEYDOWN, _
                    WinNativeFormsBASE.WM_KEYDOWN
                shiftState = CInt(GetShiftState())
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyDown(CInt(wParam And &HFF), shiftState)
                lpResult = 0
                Exit Sub        ' consume the message
            
            Case WinNativeFormsBASE.WM_SYSKEYUP, _
                    WinNativeFormsBASE.WM_KEYUP
                shiftState = CInt(GetShiftState())
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyUp(CInt(wParam And &HFF), shiftState)
                lpResult = 0
                Exit Sub        ' consume the message
            
            Case WinNativeFormsBASE.WM_CHAR
                
                If InternalState.IsTbDebugging = False Then
                    On Error Resume Next
                End If
                
                RaiseEvent KeyPress(CInt(wParam And &HFFFF&))
                lpResult = 0
                Exit Sub        ' consume the message
        End Select
        
        If Len(mouseEventName) > 0 Then
            Dim ControlContext As Any = Me.ControlContext
            x = CLng(lParam And &HFFFF&) - InternalState.WindowlessRect.Left
            y = CLng((lParam >> 16) And &HFFFF&) - InternalState.WindowlessRect.Top
            Set targetControl = CType(Of Control)(ControlContext.GetLightweightControlAtPosition(x, y))
            ' FIXME what about controls like Shape, do they interrupt the sequence, or does UserControl.MouseMove get called?
            If targetControl Is Nothing Then Set targetControl = Me
            
            If setMouseCapture = True Then
            	BeginWindowlessMouseCapture(targetControl)
            End If
            
            If InternalState.IsTbDebugging = False Then
                On Error Resume Next
            End If
            
            If eventNeedsArgs = True Then
                shiftState = CInt(GetShiftState())
                Dim button As Integer = 0
                
                If wParam And MK_LBUTTON Then button += CInt(vbLeftButton)
                If wParam And MK_RBUTTON Then button += CInt(vbRightButton)
                If wParam And MK_MBUTTON Then button += CInt(vbMiddleButton)

                Dim unitScale As Double = RootWindowElement.UnitPixelScale
                Dim targetX As Long = CLng((x / unitScale) * ControlContext.GetScaleModePixelsMultiplierX())
                Dim targetY As Long = CLng((y / unitScale) * ControlContext.GetScaleModePixelsMultiplierY())
                RaiseEventByName(targetControl, mouseEventName, Array(shiftState, button, targetX, targetY))
            Else
                RaiseEventByName(targetControl, mouseEventName)
            End If
            
            If releaseMouseCapture = True Then
            	If EndWindowlessMouseCapture(targetControl) = True Then
                	RaiseEventByName(targetControl, "Click")
            	End If
            End If
        
            lpResult = 0
            Exit Sub        ' consume the message
        End If
        
        Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
        siteWindowless.OnDefWindowMessage(msg, wParam, lParam, lpResult)
    End Sub
    Private Sub IOleInPlaceObjectWindowless_GetDropTarget(ByRef ppDropTarget As WinNativeFormsBASE.IDropTarget)
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceObjectWindowless_GetDropTarget")
        #End If
        
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub ISpecifyPropertyPages_GetPages(pPages As CAUUID) Implements ISpecifyPropertyPages.GetPages
        #If LOG_USERCONTROL Then
            Log("ISpecifyPropertyPages_GetPages")
        #End If
        
        pPages.cElems = 0
    End Sub
    
    Private Function GetDisplayString(ByVal dispID As Long) As String _
            Implements IPerPropertyBrowsing.GetDisplayString
    	Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Function
    
    Private Sub MapPropertyToPage(ByVal dispID As Long, ByRef pClsid As GUID) _
            Implements IPerPropertyBrowsing.MapPropertyToPage
    	Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub GetPredefinedStrings(ByVal dispID As Long, ByRef pCaStringsOut As CALPOLESTR, ByRef pCaCookiesOut As CADWORD) _
            Implements IPerPropertyBrowsing.GetPredefinedStrings
    	Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub GetPredefinedValue(ByVal dispID As Long, ByVal dwCookie As Long, /* out */ ByRef pVarOut As Variant) _
            Implements IPerPropertyBrowsing.GetPredefinedValue
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub TranslateAccelerator(ByRef lpmsg As MSG) _
            Implements IOleInPlaceActiveObject.TranslateAccelerator
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.TranslateAccelerator")
        #End If
        
            
        If (KeyPreview = True) And (lpmsg.hwnd <> RootWindowElement.Handle) Then
            Select Case lpmsg.message
            	Case WinNativeFormsBASE.WM_KEYDOWN, _
                        WinNativeFormsBASE.WM_KEYUP, _
                        WinNativeFormsBASE.WM_CHAR
                        
                    WinNativeFormsBASE.SendMessageW(hWnd, lpmsg.message, lpmsg.wParam, lpmsg.lParam)
            End Select
        End If
        
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE ' we don't want to swallow the message
    End Sub
    
    Private Sub OnFrameWindowActivate(ByVal fActivate As Long) _
            Implements IOleInPlaceActiveObject.OnFrameWindowActivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.OnFrameWindowActivate")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Private Sub OnDocWindowActivate(ByVal fActivate As Long) _
            Implements IOleInPlaceActiveObject.OnDocWindowActivate
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.OnDocWindowActivate")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Private Sub ResizeBorder(ByRef prcBorder As WinNativeFormsBASE.RECT, ByVal pUIWindow As IOleInPlaceUIWindow, ByVal fFrameWindow As Long) _
            Implements IOleInPlaceActiveObject.ResizeBorder
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.ResizeBorder")
        #End If
        
    	Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    Private Sub EnableModeless(ByVal fEnable As Long) _
            Implements IOleInPlaceActiveObject.EnableModeless
        #If LOG_USERCONTROL Then
            Log("IOleInPlaceActiveObject.EnableModeless")
        #End If
        
        Stop
        ' FIXME look into what VB6 does here
    End Sub
    
    [Serialize(False)]
    Public Property Get Extender() As Object
        On Error Resume Next
        Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        controlSite.GetExtendedControl(Extender)
    End Property
    
    Public Sub SetFocus()
        WinNativeFormsBASE.WindowsAPI.USER32_SetFocus(Me.RootWindowElement)
    End Sub

    [Serialize(False)]
    Public Property Get Parent() As Object
        Return Extender.Parent
    End Property
    
    Private Function TranslateContainerXToHimetric(ByVal containerValue As Single) As Long _
            Implements TbUserControlPrivate.TranslateContainerXToHimetric
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueOut As POINTL
        Dim valueIn As POINTF
        valueIn.x = containerValue
        controlSite.TransformCoords(valueOut, valueIn, XFORMCOORDS_CONTAINERTOHIMETRIC Or XFORMCOORDS_POSITION)
        Return valueOut.x
    End Function
    
    Private Function TranslateContainerYToHimetric(ByVal containerValue As Single) As Long _
            Implements TbUserControlPrivate.TranslateContainerYToHimetric
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueOut As POINTL
        Dim valueIn As POINTF
        valueIn.y = containerValue
        controlSite.TransformCoords(valueOut, valueIn, XFORMCOORDS_CONTAINERTOHIMETRIC Or XFORMCOORDS_POSITION)
        Return valueOut.y
    End Function
    
    Private Function TranslateHimetricToContainerX(ByVal himetricValue As Long) As Single _
            Implements TbUserControlPrivate.TranslateHimetricToContainerX
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueIn As POINTL
        Dim valueOut As POINTF
        valueIn.x = himetricValue
        controlSite.TransformCoords(valueIn, valueOut, XFORMCOORDS_HIMETRICTOCONTAINER Or XFORMCOORDS_POSITION)
        Return valueOut.x
    End Function
    
    Private Function TranslateHimetricToContainerY(ByVal himetricValue As Long) As Single _
            Implements TbUserControlPrivate.TranslateHimetricToContainerY
    	Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim valueIn As POINTL
        Dim valueOut As POINTF
        valueIn.y = himetricValue
        controlSite.TransformCoords(valueIn, valueOut, XFORMCOORDS_HIMETRICTOCONTAINER Or XFORMCOORDS_POSITION)
        Return valueOut.y
    End Function
    
    Private Sub HandleBackStyleChange() _   
    	    Handles BackStyle.OnPropertyLet
            
        Me.InternalRaiseViewChanged
    End Sub

    ' Private Sub QuickActivate(ByRef pQaContainer As QACONTAINER, ByRef pQaControl As QACONTROL) _
    '         Implements IQuickActivate.QuickActivate
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.QuickActivate")
    '     #End If
    '     On Error Resume Next

    '     IOleObject_SetClientSite(pQaContainer.pClientSite)
    '     IViewObject_SetAdvise(1, 0, pQaContainer.pAdviseSink)
        
    '     pQaControl.cbSize = LenB(pQaControl)
    '     IOleObject_GetMiscStatus(0, pQaControl.dwMiscStatus)    ' FIXME DVA_CONTENT
    '     pQaControl.dwViewStatus = 0
    '     pQaControl.dwPropNotifyCookie = 0
    '     pQaControl.dwPointerActivationPolicy = 0
    '     pQaControl.dwEventCookie = 0
        
    '     'MsgBox Hex(pQaControl.dwMiscStatus)
    ' End Sub
    
    'Private  Sub SetContentExtent(ByRef pSizel As SIZEL) _
    '         Implements IQuickActivate.SetContentExtent
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.SetContentExtent")
    '     #End If
    '     IOleObject_SetExtent(1, pSizel)                          ' FIXME DVA_CONTENT
    ' End Sub
    
    ' Private Sub GetContentExtent(ByRef pSizel As SIZEL) _
    '         Implements IQuickActivate.GetContentExtent
        
    '     #If LOG_USERCONTROL Then
    '     Log("IQuickActivate.GetContentExtent")
    '     #End If
    '     IOleObject_GetExtent(1, pSizel)                             ' FIXME DVA_CONTENT
    ' End Sub
    
    Private Sub InternalRaiseViewChanged() _ 
            Implements TbCommonContainerPrivate.RaiseViewChanged
        
        # If LOG_USERCONTROL Then
            Log("InternalRaiseViewChanged (0)")
        #End If
        
        If Me.InternalState.IsWindowlessActivated Then
            On Error Resume Next
            Dim siteWindowless As Any = CType(Of IOleInPlaceSiteWindowless)(InternalState.OleClientSite)
            siteWindowless.InvalidateRect(InternalState.WindowlessRect, 1)
        End If
        
        #If LOG_USERCONTROL Then
            Log("InternalRaiseViewChanged (1)")
        #End If
        
        Dim IViewObject_adviseSink As Any = Me.InternalState.IViewObject_adviseSink
        If IViewObject_adviseSink IsNot Nothing Then
            'If Me.EventsAreFrozen = False Then
                #If LOG_USERCONTROL Then
                    Log("InternalRaiseViewChanged2")
                #End If
                
                ' VBX sends OnViewChange notifications even if we're activated (i.e. when IViewObject.Draw is not being used)
                IViewObject_adviseSink.OnViewChange(DVASPECT_CONTENT, -1)
            'End If
        End If
    End Sub
    
    Private Sub RootWindowElement_UnconsumedKeyboardMessage(ByRef Msg As MSG, Consumed As Boolean)
        On Error Resume Next
        Dim controlSite As Any = CType(Of IOleControlSite)(InternalState.OleClientSite)
        Dim modifiers As Long = GetShiftState()
        controlSite.TranslateAccelerator(Msg, modifiers)
        Dim hr As Long = Err.LastHresult
        If hr = 0 Then
        	Consumed = True
        End If
    End Sub
    
    [Serialize(False)]
    Public Property Get ActiveControl() As Control
        Return CType(Of Control)(Me.RootWindowElement.FormActiveControl)
    End Property

    [Serialize(False)]
    Public Property Get Count() As Long
        Return CLng(Me.Controls.Count)
    End Property
            
    [Unimplemented]
        Public Function Point(ByVal X As Single, ByVal Y As Single) As Long
        End Function
                
    [Unimplemented]
        Public Property Get PropertyPages(ByVal Index As Integer) As String
        End Property

    [Unimplemented]
        Public Property Let PropertyPages(ByVal Index As Integer, ByVal Value As String)
        End Property

    [Enumerator]
    Public Function InternalEnumerator() As stdole.IUnknown     ' FIXME should not be exposed
        Return CallByDispId(Me.Controls, -4, vbGet)
    End Function
    
    [Serialize(False)]
    [Description("")]
    Property Get CanGetFocus() As Boolean
        Return CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).CanGetFocus
    End Property
    
    [Serialize(False)]
    [Description("")]
    Property Let CanGetFocus(ByVal Value As Boolean)
        CType(Of BaseControlInfo)(Me.InternalBaseControlInfoPtrX).CanGetFocus = Value
    End Property
    
    Private Sub TbCommonContainerPrivate_RaiseChange()
    End Sub
    
    Private Sub TbCommonContainerPrivate_RebuildMenus()
    End Sub
        
End Class