Private Module AxInternalStateMod
    Type AxInternalState
        ClientObject_IOleObject As IOleObject
        ClientObject_IOleControl As IOleControl
        ClientObject_IViewObject As IViewObject
        ClientObject_IOleInPlaceObjectWindowless As IOleInPlaceObjectWindowless
        ClientObject_IOleInPlaceObject As IOleInPlaceObject
        ActiveObject As IOleInPlaceActiveObject
        
        ActiveObjectSetCount As Long
        AdviseConnectionCookie As Long
        AcceleratorTable As LongPtr
        AcceleratorTableCount As Long
        MiscStatus As Long
        UserMode As Boolean
        UIActive As Boolean
        InPlaceActive As Boolean
        InternalHasFocus As Boolean
        InternalContainerHWND As LongPtr
        LogID As Long
        HasExclusiveDefaultValue As Boolean
        IsWindowlessPainting As Boolean
        IsInternalPainting As Boolean
        DrawModeSnapshots As Boolean
        IsSettingExtent As Boolean
        AlreadyFocusing As Boolean
        PreventGetWindowHandleRecursion As Boolean
        IsNewControl As Boolean
        DisplayAsDefault As Boolean
    End Type
    
    Public Sub ResetAxInternalState(InternalState As AxInternalState)
        Set InternalState.ClientObject_IOleObject = Nothing
        Set InternalState.ClientObject_IOleControl = Nothing
        Set InternalState.ClientObject_IViewObject = Nothing
        Set InternalState.ClientObject_IOleInPlaceObjectWindowless = Nothing
        Set InternalState.ClientObject_IOleInPlaceObject = Nothing
        Set InternalState.ActiveObject = Nothing
        
        [_HiddenModule].MemZero(VarPtr(InternalState), LenB(InternalState))
        InternalState.LogID = 1
    End Sub
End Module

[InterfaceId("B1328F90-00CA-4EF3-8A52-3BDB07A1DCA1")]
Interface IActiveXControlExtender Extends stdole.Iunknown
    Function CreateNewInstance() As stdole.IUnknown
    Sub UserModeHandsOffStart()
    Function UserModeHandsOffEnd() As stdole.IUnknown
    Property Get Default() As Boolean
    Property Let Default(ByVal Value As Boolean)
    Property Get Cancel() As Boolean
    Property Let Cancel(ByVal Value As Boolean)
End Interface

[Description("ActiveX Control wrapper")]
'[WindowsControl("/miscellaneous/ActiveXExtender.png")]
[ClassId("C564B7C5-07ED-48D1-92B8-D88411605A39")]
[InterfaceId("D5DD975B-941A-4CBE-A165-7C3CFB2A8992")]
[EventInterfaceId("D04B3CCC-8B5C-4FA6-99AD-5F1000BEF11A")]
[COMCreatable(False)]
'[EventsUseDispInterface]
Class ActiveXControlExtenderX
     
    #Region "INHERITANCE"
    
        'Implements WithEvents T Via ClientObject
        [ImplementsViaPrivateFriendlies] Implements WinNativeFormsBASE.BaseControlActiveXExtender Via _BaseControl' = CreateBaseControlWindowless()
        Implements WindowsControls.IWindowsControl
    
        Implements ITwinBasicDesignerExtensions                 ' [ IDEOnly ]               FIXME
        Implements ITwinBasicRuntimeControlExtensions
        Implements IOleClientSite                               ' FIXME once the form designer doesn't render controls in isolation, this can be moved to the container
        Implements IOleControlSite                              ' FIXME once the form designer doesn't render controls in isolation, this can be moved to the container
        Implements WinNativeFormsBASE.IAdviseSink
        Implements IOleInPlaceFrame
        Implements IOleInPlaceSiteWindowless
        Implements ISimpleFrameSite
        Implements IVBGetControl
        Implements ActiveXControlExtenderBase
        Implements IUnsupportedInterface                        ' This must be the last interface

    #End Region
        
    #Region "STATE"
        Private ClientObjectBase As stdole.IUnknown
        Private ExtenderTemplate As IActiveXControlExtender     ' FIXME need to release this
        Private ExtenderTemplateObj As Object                   ' FIXME need to release this
    
        ' WARNING: these fields are hardcoded in Record::JSONSerialize to override any exposed properties in the
        '  wrapped class T
        Public Visible As Boolean = True
        [Unimplemented]
        [CustomDesigner("designer_MultiLineText")]
            Public ToolTipText As String
        [Unimplemented]
            Public WhatsThisHelpID As Long = 0
        [Unimplemented]
            Public HelpContextID As Long = 0
            
            Public UseIViewObjectSnapshots As Boolean = False
            
        [Description("Opacity, given as a percentage, 0 - 100.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public Opacity As Double = 100
        
        [CustomDesigner("designer_SpectrumWindowsOrClear")]
        [Description("A color, when set, that will appear fully transparent in the window.  REQUIRES TARGET OS 6.2+ FOR CHILD CONTROLS.")]
            Public TransparencyKey As OLE_COLOR = -1
                
        Private WithEvents RootWindowElement As WindowElement
        
        Private InternalState As AxInternalState
        Private ActsLikeButton As Boolean
        
        Private WithEvents ClientObject_IPropertyNotifySink As PropertyNotifySink
        [Serialize(False)] Public RootCLSID As String
                
        Private Const OLEIVERB_HIDE                     As Long = -3
        Private Const OLEIVERB_SHOW                     As Long = -1
        Private Const OLECLOSE_NOSAVE                   As Long = 1
        Private Const DVASPECT_CONTENT                  As Long = 1
        Private Const E_NOINTERFACE                     As Long = &H80004002
        Private Const INPLACE_E_NOTOOLSPACE             As Long = &H800401A1
        Private Const XFORMCOORDS_POSITION              As Long	= &H1
        Private Const XFORMCOORDS_SIZE                  As Long	= &H2
        Private Const XFORMCOORDS_HIMETRICTOCONTAINER   As Long	= &H4
        Private Const XFORMCOORDS_CONTAINERTOHIMETRIC   As Long	= &H8
        Private Const XFORMCOORDS_EVENTCOMPAT           As Long	= &H10
        Private Const MK_LBUTTON                        As Long = 1
        Private Const ACTIVATE_WINDOWLESS               As Long = 1
        
    #End Region

    #Region "EVENTS"
        Event ExperimentalLogAxExtender(ByVal Text As String)
        [Unimplemented]
        [DispId(&HEAEA000B)]
            Event DragDrop(Source As Control, X As Single, Y As Single)
        [Unimplemented]
        [DispId(&HEAEA000C)]
            Event DragOver(Source As Control, X As Single, Y As Single, State As Integer)
        [DispId(&HEAEA0006)]
            Event GotFocus()
        [DispId(&HEAEA0007)]
            Event LostFocus()
        [Unimplemented]
        [DispId(&HEAEA000D)]
            Event Validate(Cancel As Boolean)
    #End Region
               
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalGetUserDefaultLCID Lib "kernel32" Alias "GetUserDefaultLCID" () As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalGetWindow Lib "user32" Alias "GetWindow" (ByVal hWnd As LongPtr, ByVal uCmd As Long) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalSetFocus Lib "user32" Alias "SetFocus" (ByVal hWnd As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Sub InternalSleep Lib "kernel32.dll" Alias "Sleep" (ByVal dwMilliseconds As Long)
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalGetDC Lib "user32" Alias "GetDC" (ByVal hWnd As LongPtr) As LongPtr
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalReleaseDC Lib "user32" Alias "ReleaseDC" (ByVal hWnd As LongPtr, ByVal hDC As LongPtr) As Long
    [UseGetLastError(False), DLLStackCheck(False)]
    Private DeclareWide PtrSafe Function InternalSendMessage Lib "user32" Alias "SendMessageW" (ByVal HWnd As LongPtr, ByVal wMsg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr) As LongPtr
    
    #Region "MEMBERS"

        #If LOG_ACTIVEX Then
        Private Sub Log(ParamArray Values() As Variant)
            Dim logText As String = InternalState.LogID & " " & VBA.Format(VBA.Now, "hh:nn:ss") & " " & Hex(ObjPtr(Me)) & " " & Join(Values, ", ")
            InternalState.LogID += 1
            RaiseEvent ExperimentalLogAxExtender(logText)
            'Debug.Print logText
        End Sub
        #End If

        Public Sub New(ExtenderObj As Object, ByVal ActsLikeButton As Boolean)
            Set _BaseControl = CType(Of WinNativeFormsBASE.BaseControlActiveXExtender)(CreateBaseControlWindowless())
            Set Me.ExtenderTemplateObj = ExtenderObj
            Set Me.ExtenderTemplate = CType(Of IActiveXControlExtender)(ExtenderObj)
            Me.ActsLikeButton = ActsLikeButton
        End Sub
        
        #If LOG_ACTIVEX Or LOG_TERMINATE Then
            Private Sub Class_Terminate()
                #If LOG_ACTIVEX Then
                    Log("ActiveXControlExtender.Class_Terminate")
                #End If
                #If LOG_TERMINATE Then
                    Debug.Print CurrentComponentName & "." & CurrentProcedureName
                #End If
            End Sub
        #End If
        
        Private Sub Class_BeforeFirstMethodAccess()
            'Debug.Print CurrentComponentName & "." & CurrentProcedureName
            [_HiddenModule].EnsureContainerIsLoaded(Me)
        End Sub
        
        Private Sub HandleLoad() _
                Handles RootWindowElement.Load
            
            Dim Opacity As Any = Me.Opacity
            If ((Opacity >= 0) And (Opacity < 100)) Or (TransparencyKey <> -1) Then
                SyncOpacity
            End If
            
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.HandleAfterLoad")
            #End If
            Dim ClientObject_IOleControl As Any = Me.InternalState.ClientObject_IOleControl
            If ClientObject_IOleControl IsNot Nothing Then
                ClientObject_IOleControl.FreezeEvents(0)
            End If
            
        End Sub
        
        Private Sub SyncOpacity() _ 
                Handles Opacity.OnPropertyLet, _
                        TransparencyKey.OnPropertyLet
            
            CommonSyncOpacity(Me.TransparencyKey, Me.Opacity, GetWindowHandle())
        End Sub
        
        Private Sub HandleInitialize(ByVal ControlContext As WindowsControls.WindowsControlContext) _
                Implements IWindowsControl.Initialize
            
            Me.InternalStateReset()     ' resets all the base class state
            ResetAxInternalState(Me.InternalState)
            Set Me.ClientObject_IPropertyNotifySink = Nothing
            
            InitAcceleratorTable()

            With ControlContext.GetSerializer
                If Not .Deserialize(ExtenderTemplateObj) Then
                    'Caption_INIT = "ActiveXExtender"
                End If
                Me.InternalState.UserMode = Not .IsDesignMode
                'Me.InternalState.UserMode = If((Serializer IsNot Nothing) AndAlso Serializer.IsDesignMode, False, True)
                RootCLSID = .GetRootCLSID()
            End With
            
            Dim Opacity As Any = Me.Opacity
            If Opacity > 100 Then Me.Opacity = 100
            If Opacity < 0 Then Me.Opacity = 0
            
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.HandleInitialize")
            #End If
            
            Dim InitData As WinNativeFormsBASE.WindowCreationData
            'InitData.Index = _BaseControl.IndexINIT
            
            'MsgBox(Hex(Me.MiscStatus))
            'If Me.MiscStatus And OLEMISC_ACTSLIKEBUTTON Then           we dont currently have this information at this point
                InitData.Flags = HasExclusiveCancelProp Or _
                                HasExclusiveDefaultProp
            'End If
            ' We create a window element for allowing the runtime to handle the positional side of things
            '  (even though we don't create an actual HWND ourselves)
            
            Set RootWindowElement = _BaseControl.CreateRootWindowElement(ControlContext, InitData)
            
            
            
        
        End Sub
        
        Private Sub HandlePaint(ByRef Handled As Boolean) _
                Handles RootWindowElement.Paint
            
            If InternalState.DrawModeSnapshots Then
                Dim ps As WinNativeFormsBASE.PAINTSTRUCT
                Dim RootWindowElement As Any = Me.RootWindowElement
                RootWindowElement.BeginPaint(ps)    ' you MUST use this method, and NOT the BeginPaint API directly

                    ' This is only used when we're doing windowless painting via IViewObject.Draw()
                    Dim ourRect As WinNativeFormsBASE.RECT = GetRECT()
                    If Me.Visible = True Then
                        InternalState.ClientObject_IViewObject.Draw(DVASPECT_CONTENT, -1, 0, 0, 0, ps.hdc, ourRect, CLngPtr(0), 0, 0)
                    End If
                    
                RootWindowElement.EndPaint(ps)
                Handled = True     ' swallow up the event
            End If

        End Sub
        
        Private Sub HandleCreate() _
                Handles RootWindowElement.Create
            
            [_HiddenModule].ExclusivitySectionEnter(Me.RootCLSID)   ' prevents recursive UserControls
            Me.InternalState.InternalContainerHWND = RootWindowElement.ContainerHWND

                        
            [_HiddenModule].DontInitNextCreatedCOMInstance(True)    ' prevents IPersist*::InitNew being called automagically
            Set ClientObjectBase = ExtenderTemplate.CreateNewInstance()
            [_HiddenModule].DontInitNextCreatedCOMInstance(False)   ' behaviour gets cleared automatically in above New statement, but only if it was definitely an external COM class 
            
            InitOLEInterfaces()
            
            
            ' We do this as late as possible, so that controls like XTreme TabControl can enumerate child controls
            '   and access the Container property of them
            
            
            [_HiddenModule].SuppressRaiseEvents(Me, True)
            ControlContext.InitializeActiveX()       ' this will call the IPersist* methods as necessary, from the serialized data
            Me.InternalState.IsNewControl = (Err.LastHresult = WinNativeFormsBASE.S_FALSE)
            [_HiddenModule].SuppressRaiseEvents(Me, False)
                            
            PrepareOLEInterfaces()
            
            
            ' VBx queries for IID_IViewObjectEx here (but VBx UserControls dont support it)
            ' VBx queries for IID_IVBDSC here
            ' VBx queries for IID_MSDATSRC_DataSource here
            
            Dim ourRect As WinNativeFormsBASE.RECT = GetRECT()
            
            ' If this is a newly added control (i.e. IPersist*->InitNew() was called), then VBx calls SetExtent before activating the object
            If Me.InternalState.IsNewControl = True Then
                SyncControlExtent()
            End If
            
            ' VBx queries for IID_IPointerInactive here
            
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.HandleCreate")
            #End If
            
            InitializeDefaultCancel()
            
            If (InternalState.DrawModeSnapshots = False) AndAlso ((Me.InternalState.UserMode = True) OrElse (UseIViewObjectSnapshots = False)) Then
                If (Me.InternalState.MiscStatus And OLEMISC_INVISIBLEATRUNTIME) = 0 Then
                	Dim ClientObject_IOleObject As Any = Me.InternalState.ClientObject_IOleObject
                    On Error GoTo ChangeDrawMode
                        ClientObject_IOleObject.DoVerb(WinNativeFormsBASE.OLEIVERB_INPLACEACTIVATE, 0, Me, -1, Me.InternalState.InternalContainerHWND, ourRect)
                                        
                    If (Me.Visible = False) And (Me.InternalState.UserMode = True) Then
                        ClientObject_IOleObject.DoVerb(WinNativeFormsBASE.OLEIVERB_HIDE, 0, Me, -1, Me.InternalState.InternalContainerHWND, ourRect)
                    End If
                End If
             End If
            
        ExitPoint:
            [_HiddenModule].ExclusivitySectionLeave(Me.RootCLSID)
            Exit Sub
            
        ChangeDrawMode:
        InternalState.DrawModeSnapshots = True
            Resume ExitPoint
        End Sub
        
        Private Sub HandleDestroy() _
                Implements IWindowsControl.Destroy
            #If LOG_TERMINATE Then
                Debug.Print CurrentComponentName & "." & CurrentProcedureName
            #End If

            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.HandleDestroy")
            #End If
            
            HandsOffOLE()
            'Set Me.Font = Nothing
            [_HiddenModule].ResetFirstMethodAccessFlag(Me)
        End Sub

        
        Private Sub InitAcceleratorTable()
        	Dim accel As ACCEL
            Me.InternalState.AcceleratorTable = USER32_CreateAcceleratorTableW(accel, 1)
            Me.InternalState.AcceleratorTableCount = 1
        End Sub

        Private Sub DestroyAcceleratorTable()
        	If Me.InternalState.AcceleratorTable <> 0 Then
                USER32_DestroyAcceleratorTable(Me.InternalState.AcceleratorTable)
            End If
        End Sub

        Private Sub InitOLEInterfaces()
            Set Me.InternalState.ClientObject_IOleObject = CType(Of IOleObject)(Me.ClientObjectBase)

            ' VB6 doesn't use this, but instead uses the value from the registry, which I think gets embedded
            '  in the OCA file, and ultimately the built executable
            Me.InternalState.ClientObject_IOleObject.GetMiscStatus(1, Me.InternalState.MiscStatus)
            
            #If LOG_ACTIVEX Then
                Log("**** MISCSTATUS: " & Hex(Me.InternalState.MiscStatus))
            #End If
            
            'InternalState.DrawModeSnapshots = True ' ***************
            'InternalState.DrawModeSnapshots = True
            'Debug.Print "Me.MiscStatus: " & Hex(Me.MiscStatus)
            
            Dim RootWindowElement As Any = Me.RootWindowElement
            If ((Me.InternalState.MiscStatus And OLEMISC_ACTIVATEWHENVISIBLE) = 0) And _
                ((Me.InternalState.MiscStatus And OLEMISC_SIMPLEFRAME) = 0) Then
                
                InternalState.DrawModeSnapshots = True        ' we paint manually, using IViewObject.Draw() rather than windowed with DoVerb()
                If Me.InternalState.UserMode = True Then  ' PrepareDesignTimeSnapshot handles the drawing if we're in design-mode
                    RootWindowElement.RequiresWindowlessPainting(False)
                    Me.InternalState.IsWindowlessPainting = True
                End If
            End If
            
            If (Me.InternalState.MiscStatus And OLEMISC_SIMPLEFRAME) Then
                RootWindowElement.IsContainer()
            End If

            If (Me.InternalState.MiscStatus And OLEMISC_NOUIACTIVATE) Or (Me.InternalState.MiscStatus And OLEMISC_ACTSLIKELABEL) Then
                ' NOTE: CodeJock Label has ACTSLIKELABEL but NOT NOUIACTIVATE set
                RootWindowElement.CanGetFocus(False)
            End If
            
            If Me.InternalState.MiscStatus And OLEMISC_SETCLIENTSITEFIRST Then
                Me.InternalState.ClientObject_IOleObject.SetClientSite(Me)
            End If
            
            Set Me.InternalState.ClientObject_IOleControl = CType(Of IOleControl)(Me.ClientObjectBase)
            Me.InternalState.ClientObject_IOleControl.FreezeEvents(1)
            
        End Sub

        Private Sub PrepareOLEInterfaces()
            'On Error Resume Next
                	
                ' FIXME VB6 controls do support IQuickActivate, and the VB6 Ax-extenders do support it if the control offers it.
                ' Stop
                ' Dim quickActivate As IQuickActivate = Me.ClientObject
                ' If quickActivate IsNot Nothing Then
    
                '     On Error GoTo 0

                '     Dim containerInfo As QACONTAINER
                '     Dim controlInfo As QACONTROL
                    
                '     containerInfo.cbSize = LenB(containerInfo)
                '     Set containerInfo.pClientSite = Me
                '     'Set containerInfo.pAdviseSink = Me     ' IAdviseSinkEx
                '     Set containerInfo.pPropertyNotifySink = Me
                '     ' Set containerInfo.pUnkEventSink = Nothing
                '     containerInfo.dwAmbientFlags = 0
                '     containerInfo.colorFore = vbRed
                '     containerInfo.colorBack = vbGreen
                '     Set containerInfo.pFont = New StdFont
                '     Set containerInfo.pUndoMgr = Nothing
                '     containerInfo.dwAppearance = 0
                '     containerInfo.lcid = 0
                '     containerInfo.hpal = 0
                '     containerInfo.hpal = 0
                '     Set containerInfo.pBindHost = Nothing
                '     Set containerInfo.pOleControlSite = Me
                '     Set containerInfo.pServiceProvider = Nothing
                    
                '     controlInfo.cbSize = LenB(controlInfo)

                '     quickActivate.QuickActivate(containerInfo, controlInfo)
                '     Exit Sub
                ' End If
            'On Error GoTo 0
                    
            Dim ClientObject As Any = Me.ClientObjectBase
            If (Me.InternalState.MiscStatus And OLEMISC_SETCLIENTSITEFIRST) = 0 Then
                Me.InternalState.ClientObject_IOleObject.SetClientSite(Me)
            End If
            
            Set Me.InternalState.ClientObject_IViewObject = CType(Of IViewObject)(ClientObject)
            Set Me.InternalState.ClientObject_IOleInPlaceObject = CType(Of IOleInPlaceObject)(ClientObject)

            On Error Resume Next
                ' optionally supported interface
                Set Me.ClientObject_IPropertyNotifySink = CType(Of PropertyNotifySink)(ClientObject)
                Set Me.InternalState.ClientObject_IOleInPlaceObjectWindowless = CType(Of IOleInPlaceObjectWindowless)(ClientObject)
            On Error GoTo 0

            If Me.ClientObject_IPropertyNotifySink IsNot Nothing Then
            	Me.InternalState.HasExclusiveDefaultValue = VBA.[_HiddenModule].HasExclusiveDefaultDispatchValue(ClientObject_IPropertyNotifySink)
                If Me.InternalState.HasExclusiveDefaultValue Then
                    Me.RootWindowElement.IsExclusiveValueWithinContainer()
                End If
            End If

            Me.InternalState.ClientObject_IViewObject.SetAdvise(DVASPECT_CONTENT, 0, Me)
            
            ' FIXME VB6 asks for IViewObjectEx.GetViewStatus here, if it supports the interface
                ' what if IViewObjectEx is not supported?  "Objects not supporting IViewObjectEx are considered to be always transparent"

            ' Dim controlInfo As CONTROLINFO
            ' controlInfo.cb = LenB(controlInfo)
            ' Me.ClientObject_IOleControl.GetControlInfo(controlInfo)
        End Sub
        
        Private Sub HandsOffOLE()
            #If LOG_ACTIVEX Then
                Log("HandsOffOLE")
            #End If
            Me.InternalState.ClientObject_IOleControl.FreezeEvents(1)
            
            If Me.InternalState.UserMode = True Then
                ExtenderTemplate.UserModeHandsOffStart()
                
                ' Uunregister the control for events.  
                ' Fixes some problems with 10Tec iGrid compat, where some paint events get fired in the deactivation
                Set ClientObjectBase = Nothing
            End If
            
            If Me.InternalState.InPlaceActive = True Then
                'Stop
                Me.InternalState.ClientObject_IOleInPlaceObject.InPlaceDeactivate()
            End If
            Me.InternalState.ClientObject_IOleObject.Close(OLECLOSE_NOSAVE)

            If Me.InternalState.UserMode = True Then
                Set ClientObjectBase = ExtenderTemplate.UserModeHandsOffEnd()
            End If

            'Me.InternalState.ClientObject_IOleObject.Unadvise(Me.InternalState.AdviseConnectionCookie)     ' VB6 doesn't do this
            Me.InternalState.ClientObject_IViewObject.SetAdvise(DVASPECT_CONTENT, 0, Nothing)
            Me.InternalState.ClientObject_IOleObject.SetClientSite(Nothing)

            Set Me.InternalState.ClientObject_IOleInPlaceObject = Nothing
            Set Me.InternalState.ClientObject_IOleInPlaceObjectWindowless = Nothing
            Set Me.ClientObject_IPropertyNotifySink = Nothing
            Set Me.InternalState.ClientObject_IOleObject = Nothing
            Set Me.InternalState.ClientObject_IOleControl = Nothing
            Set Me.InternalState.ClientObject_IViewObject = Nothing
            Set Me.ClientObjectBase = Nothing

            DestroyAcceleratorTable()
            #If LOG_ACTIVEX Then
                Log("HandsOffOLE... DONE")
            #End If
        End Sub

        [Serialize(False)]
        Public Property Get Object() As Object
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.Object")
            #End If
        	Return ClientObjectBase
        End Property

        Private Sub SyncControlExtent()
            If InternalState.IsSettingExtent = True Then Exit Sub
            InternalState.IsSettingExtent = True
            
            Dim ourRect As WinNativeFormsBASE.RECT = GetRECT()
                
            Dim mRect As SIZEL  ' SetExtent uses HIMETRIC units
            mRect.cx = CLng(Me.RootWindowElement.ScaleX(ourRect.Right - ourRect.Left, vbPixels, vbHimetric))
            mRect.cy = CLng(Me.RootWindowElement.ScaleY(ourRect.Bottom - ourRect.Top, vbPixels, vbHimetric))
            
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.SyncControlExtent.SetExtent")
            #End If
            On Error Resume Next
            Me.InternalState.ClientObject_IOleObject.SetExtent(DVASPECT_CONTENT, mRect)
            Dim lastHR As Long = Err.LastHresult
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.SyncControlExtent.SetExtent... DONE")
            #End If
                        
            On Error GoTo 0
            
            InternalState.IsSettingExtent = False
        End Sub

        Private Function GetRECT() As WinNativeFormsBASE.RECT
            Dim myRect As WinNativeFormsBASE.RECT
            Dim RootWindowElement As Any = Me.RootWindowElement
            myRect.Left = RootWindowElement.CurrentLeft
            myRect.Top = RootWindowElement.CurrentTop
            myRect.Right = myRect.Left + RootWindowElement.CurrentWidth
            myRect.Bottom = myRect.Top + RootWindowElement.CurrentHeight
            Return myRect
        End Function
        
        Private Function GetWindowHandle() As LongPtr _
        	    Implements ITwinBasicRuntimeControlExtensions.GetWindowHandle

            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.GetWindowHandle")
            #End If
            Return GetWindowHandleWithFallback()
        End Function
        
        Private Function GetMiscStatus() As Long _
                Implements ITwinBasicRuntimeControlExtensions.GetMiscStatus

            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.GetMiscStatus")
            #End If
            Return InternalState.MiscStatus
        End Function
    
        Private Function GetWindowHandleWithFallback() As LongPtr
            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.GetWindowHandleWithFallback")
            #End If
            If InternalState.PreventGetWindowHandleRecursion = True Then
                'MsgBox 666
                Return vbNullPtr
            End If
            
            On Error GoTo NoIOleWindowSupport
                InternalState.PreventGetWindowHandleRecursion = True
                Dim clientWindow As IOleWindow = CType(Of IOleWindow)(Me.InternalState.ClientObject_IOleControl)
                Dim clientWindowHWND As LongPtr
                clientWindow.GetWindow(clientWindowHWND)
            
        NoIOleWindowSupport:
            On Error GoTo -1

            'Dim clientWindow As LongPtr = GetWindowHandle()
            If clientWindowHWND = 0 Then
                ' CODEJOCK controls don't return a HWND for the IOleWindow::GetWindow implementation...
            	On Error Resume Next
                clientWindowHWND = CLngPtr(CallByDispId(CType(Of Object)(ClientObjectBase), DISPID_HWND, VbCallType.vbMethod Or VbCallType.vbGet))
                If clientWindowHWND <> 0 Then
                    #If LOG_ACTIVEX Then
                        Log("ActiveX Control did not provide a IOleWindow::GetWindow value, but ClientObject.[DISPID_HWND] did, so using that (", clientWindow, ")")
                    #End If
                Else
                    clientWindowHWND = CLngPtr(CVar(CType(Of Object)(ClientObjectBase)).hWnd)
                    If clientWindowHWND <> 0 Then
                        #If LOG_ACTIVEX Then
                            Log("ActiveX Control did not provide a IOleWindow::GetWindow value, but ClientObject.hWnd did, so using that (", clientWindow, ")")
                        #End If
                    Else
                        ' Finally, hopefully the control created a child window within the container HWND, so use that...
                        clientWindowHWND = InternalGetWindow(Me.InternalState.InternalContainerHWND, WinNativeFormsBASE.GW_CHILD)
                        clientWindowHWND = InternalGetWindow(clientWindowHWND, WinNativeFormsBASE.GW_CHILD)
                    End If
                End If
            End If
            InternalState.PreventGetWindowHandleRecursion = False
            Return clientWindowHWND
        End Function

        Private Sub OnLostFocus() _
        	    Implements ITwinBasicRuntimeControlExtensions.OnLostFocus

            #If LOG_ACTIVEX Then
                Log("OnLostFocus -> UIDeactivate()")
            #End If
            Me.InternalState.ClientObject_IOleInPlaceObject.UIDeactivate
        End Sub
    
        Private Sub OnGotFocus() _
        	    Implements ITwinBasicRuntimeControlExtensions.OnGotFocus

            #If LOG_ACTIVEX Then
                Log("OnGotFocus")
            #End If
            
            InternalSetFocus(GetWindowHandleWithFallback)
            #If LOG_ACTIVEX Then
                Log("OnGotFocus... DONE")
            #End If
        End Sub

        Private Function IsNonVisualControl() As Boolean _
        	    Implements ITwinBasicRuntimeControlExtensions.IsNonVisualControl

            #If LOG_ACTIVEX Then
                Log("ActiveXControlExtender.IsNonVisualControl")
            #End If
     	    Return (InternalState.MiscStatus And OLEMISC_INVISIBLEATRUNTIME) <> 0
        End Function
            
        Private Sub IUnsupportedInterface_UnsupportedInterfaceRequested(iid As WinNativeFormsBASE.GUID2, ByRef out As stdole.IUnknown) _
                Implements IUnsupportedInterface.UnsupportedInterfaceRequested

            #If LOG_ACTIVEX Then
                Log("UNSUPPORTED INTERFACE: " & GuidToString(iid))
            #End If
        End Sub
            
        [UseGetLastError(False), DLLStackCheck(False)]
        Private DeclareWide PtrSafe Function InternalSetWindowPos Lib "user32" Alias "SetWindowPos" (ByVal hwnd As LongPtr, ByVal hWndInsertAfter As LongPtr, ByVal x As Long, ByVal y As Long, ByVal cx As Long, ByVal cy As Long, ByVal wFlags As Long) As Long
        
        Private Sub HandleResizeWindowless(ByVal oldLeft As Long, ByVal oldTop As Long, ByVal oldWidth As Long, ByVal oldHeight As Long, _
                                               ByVal newLeft As Long, ByVal newTop As Long, ByVal newWidth As Long, ByVal newHeight As Long) _
                Handles RootWindowElement.ResizeWindowless

            SyncControlExtent()
                
             If Me.InternalState.IsWindowlessPainting = True Then
                 CommonResizeWindowless(CLngPtr(Me.Container.hwnd), 0, oldLeft, oldTop, oldWidth, oldHeight, newLeft, newTop, newWidth, newHeight)
            Else
                InternalSetWindowPos(Me.GetWindowHandleWithFallback(), 0, newLeft, newTop, 0, 0, WinNativeFormsBASE.SWP_NOSIZE Or WinNativeFormsBASE.SWP_NOREDRAW Or WinNativeFormsBASE.SWP_NOOWNERZORDER Or WinNativeFormsBASE.SWP_NOACTIVATE Or WinNativeFormsBASE.SWP_NOZORDER)
            End If
        End Sub

        Private Sub RootWindowElement_CapturedMessage(ByRef msg As MSG) _
                Handles RootWindowElement.CapturedMessage

            'Debug.Print "RootWindowElement_CapturedMessage", Hex(msg.message)
            'Log("RootWindowElement_CapturedMessage: " & Hex(msg.message))

            If Me.InternalState.ActiveObject IsNot Nothing Then
            
                'Debug.Print msg.message, msg.wParam, msg.lParam
            
                Select Case msg.message
                    Case WinNativeFormsBASE.WM_KEYDOWN, _
                            WinNativeFormsBASE.WM_KEYUP, _
                            WinNativeFormsBASE.WM_SYSKEYDOWN, _
                            WinNativeFormsBASE.WM_SYSKEYUP

                    Me.InternalState.ActiveObject.TranslateAccelerator(msg)
                    Dim hr As Long = Err.LastHresult

                    If hr = 0 Then
                        ' The message has been consumed
                        msg.message = 0
                        '.Print "    -> consumed by active object!" 
                    Else
                        If msg.message = WinNativeFormsBASE.WM_KEYDOWN Then
                            If (Me.InternalState.MiscStatus And OLEMISC_ACTSLIKEBUTTON) = 0 Then
                                Select Case msg.wParam
                                    Case vbKeyReturn, vbKeyExecute
                                        RootWindowElement.HandleEnterKey()
                                    Case vbKeyEscape
                                        RootWindowElement.HandleEscapeKey()
                                End Select
                            Else
                                Select Case msg.wParam
                                    Case vbKeyReturn, vbKeyExecute
                                        InvokeDefault()
                                    Case vbKeyEscape
                                        RootWindowElement.HandleEscapeKey()
                                End Select
                            End If
                        End If
                    End If
                    
                End Select

                'Log("RootWindowElement_CapturedMessage: " & Hex(msg.message) & " >>> " & Hex(hr))                
            End If
        End Sub
        
        Private Sub ITwinBasicDesignerExtensions_GetPropertyExtensions(ByRef out() As String) _
                Implements ITwinBasicDesignerExtensions.GetPropertyExtensions

            Dim propertyPages As ISpecifyPropertyPages = CType(Of ISpecifyPropertyPages)(Me.ClientObjectBase)
            Dim pages As CAUUID
            propertyPages.GetPages(pages)

            If pages.cElems > 0 Then
            	ReDim out(0)
                out(0) = "Custom"
            End If
        End Sub

        Private Sub ITwinBasicDesignerExtensions_InvokePropertyExtension(ByVal Name As String) _
                Implements ITwinBasicDesignerExtensions.InvokePropertyExtension

            If Name = "Custom" Then
                VBA.[_HiddenModule].ShowPropertyPages(Me.Name, Me.ClientObjectBase)
            End If
        End Sub

        Private Function ITwinBasicDesignerExtensions_GetClientObject() As Object _
                Implements ITwinBasicDesignerExtensions.GetClientObject

        	Return CType(Of Object)(ClientObjectBase)
        End Function

        Private Sub DesignerClick(ByVal X As Long, ByVal Y As Long) _
                Implements ITwinBasicDesignerExtensions.DesignerClick

            SyncControlExtent()

            Dim dpiScale As Double = Me.RootWindowElement.DPI / 96.0
            Dim clickPos As Long = ((CLng(Y * dpiScale)) << 16) Or CLng(X * dpiScale)
            Dim clientWindow As LongPtr = GetWindowHandleWithFallback()

            InternalSendMessage(clientWindow, WinNativeFormsBASE.WM_LBUTTONDOWN, MK_LBUTTON, clickPos)
            InternalSendMessage(clientWindow, WinNativeFormsBASE.WM_LBUTTONUP, MK_LBUTTON, clickPos)
        End Sub

        Private Sub ITwinBasicDesignerExtensions_DesignTimePrepareSnapshot() _
                Implements ITwinBasicDesignerExtensions.DesignTimePrepareSnapshot

            #If LOG_ACTIVEX Then
                Log("ITwinBasicDesignerExtensions_DesignTimePrepareSnapshot")
            #End If
            
            ' We do this so that the control can store its ExtentX/Y itself (in its persistence data), which it will use when being loaded.
            SyncControlExtent()
            
            'Debug.Print "Me.UseIViewObjectSnapshots: ", Me.UseIViewObjectSnapshots
            'Debug.Print "Me.DrawModeSnapshots: ", Me.DrawModeSnapshots
            If (InternalState.DrawModeSnapshots = True) OrElse ((Me.InternalState.UserMode = False) And (Me.UseIViewObjectSnapshots = True)) Then
                Debug.TracePrint "**** DRAWING WITH IViewObject::Draw()"
                'Debug.Print "**** DRAWING WITH IViewObject::Draw()"
                Dim ourRect As WinNativeFormsBASE.RECT = GetRECT()
                'Int3Breakpoint
                Me.InternalState.ClientObject_IViewObject.Draw(DVASPECT_CONTENT, -1, 0, 0, 0, InternalGetDC(Me.InternalState.InternalContainerHWND), ourRect, CLngPtr(0), 0, 0)
            Else
                Debug.TracePrint "**** NOT DRAWING WITH IViewObject::Draw()"
            End If
            
            #If LOG_ACTIVEX Then
                Log("ITwinBasicDesignerExtensions_DesignTimePrepareSnapshot -> DONE")
            #End If
        End Sub
        
        Private Sub ITwinBasicDesignerExtensions_GetIViewObject(ByRef out As IViewObject, ByRef outRect As WinNativeFormsBASE.RECT, ByRef outIsVisible As Boolean) _
                    Implements ITwinBasicDesignerExtensions.GetIViewObject
            Set out = Me.InternalState.ClientObject_IViewObject
            outRect = GetRECT()
            outIsVisible = Me.Visible
        End Sub
        
    #End Region
    
    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IOleClientSite_SaveObject() _
            Implements IOleClientSite.SaveObject

        #If LOG_ACTIVEX Then
            Log("IOleClientSite_SaveObject")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleClientSite_GetMoniker(ByVal dwAssign As Long, ByVal dwWhichMoniker As Long, ppmk As WinNativeFormsBASE.IMoniker) _
            Implements IOleClientSite.GetMoniker

        #If LOG_ACTIVEX Then
            Log("IOleClientSite_GetMoniker")
        #End If
        SetOutParamToNothing(VarPtr(ppmk))
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleClientSite_GetContainer(ByRef ppContainer As IOleContainer) _
            Implements IOleClientSite.GetContainer
        #If LOG_ACTIVEX Then
            Log("IOleClientSite_GetContainer")
        #End If
        SetOutParamToNothing(VarPtr(ppContainer))

        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
        'Int3Breakpoint
        Exit Sub
        ' Just return an empty container for now.  VBCCR.TabStrip property page needs this for the enumeration of image lists
        Set ppContainer = New EmptyOleContainer(Me, RootWindowElement, Me.InternalState.UserMode)
    End Sub
    
    Private Sub IOleClientSite_ShowObject() _
            Implements IOleClientSite.ShowObject

        #If LOG_ACTIVEX Then
            Log("IOleClientSite_ShowObject")
        #End If
        
        ' FIXME VB6 does IOleInPlaceObject_GetWindow here. why?
        'Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
     End Sub
    
    Private Sub IOleClientSite_OnShowWindow(ByVal fShow As Long) _
            Implements IOleClientSite.OnShowWindow

        #If LOG_ACTIVEX Then
            Log("IOleClientSite_OnShowWindow")
        #End If

        ' FIXME what does VB6 actually do here?
    End Sub
    
    Private Sub IOleClientSite_RequestNewObjectLayout() _
            Implements IOleClientSite.RequestNewObjectLayout

        #If LOG_ACTIVEX Then
            Log("IOleClientSite_RequestNewObjectLayout")
        #End If
        
        ' FIXME what does VB6 actually do here?
    End Sub
    
    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IAdviseSink_OnDataChange(ByVal pFormatetc As LongPtr, ByVal pStgmed As LongPtr) _
            Implements WinNativeFormsBASE.IAdviseSink.OnDataChange

        #If LOG_ACTIVEX Then
            Log("IAdviseSink_OnDataChange")
        #End If
    End Sub
    
    Private Sub IAdviseSink_OnViewChange(ByVal dwAspect As Long, ByVal lindex As Long) _
            Implements WinNativeFormsBASE.IAdviseSink.OnViewChange

        If Me.InternalState.IsWindowlessPainting Then
        	Dim rect As WinNativeFormsBASE.RECT = GetRECT()
            WinNativeFormsBASE.WindowsAPI.InvalidateRect(CLngPtr(Me.Container.hwnd), rect, 1)
        End If
        '   Log("IAdviseSink_OnViewChange")
    End Sub
    
    Private Sub IAdviseSink_OnRename(ByVal pmk As WinNativeFormsBASE.IMoniker) _
            Implements WinNativeFormsBASE.IAdviseSink.OnRename

        #If LOG_ACTIVEX Then
            Log("IAdviseSink_OnRename")
        #End If
    End Sub
    
    Private Sub IAdviseSink_OnSave() _
            Implements WinNativeFormsBASE.IAdviseSink.OnSave

        #If LOG_ACTIVEX Then
            Log("IAdviseSink_OnSave")
        #End If
    End Sub
    
    Private Sub IAdviseSink_OnClose() _
            Implements WinNativeFormsBASE.IAdviseSink.OnClose

        #If LOG_ACTIVEX Then
            Log("IAdviseSink_OnClose")
        #End If
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IOleInPlaceSite_CanInPlaceActivate() _
            Implements IOleInPlaceSiteWindowless.CanInPlaceActivate

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_CanInPlaceActivate")
        #End If
        ' return S_OK for 'yes'
        'If Me.InternalState.UserMode = False Then
        'Err.ReturnHresult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSite_GetWindowContext(ByRef ppFrame As IOleInPlaceFrame, ByRef ppDoc As IOleInPlaceUIWindow, ByRef lprcPosRect As WinNativeFormsBASE.RECT, ByRef lprcClipRect As WinNativeFormsBASE.RECT, ByRef lpFrameInfo As OLEINPLACEFRAMEINFO) _
            Implements IOleInPlaceSiteWindowless.GetWindowContext

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_GetWindowContext")
        #End If

        SetOutParamToNothing(VarPtr(ppFrame))
        SetOutParamToNothing(VarPtr(ppDoc))
        
        If VarPtr(ppFrame) <> 0 Then
            Set ppFrame = Me
        End If

        If VarPtr(lprcPosRect) <> 0 Then
            lprcPosRect = GetRECT()
        End If

        If VarPtr(lprcClipRect) <> 0 Then
            lprcClipRect.Left = 0
            lprcClipRect.Top = 0
            lprcClipRect.Right = 32767
            lprcClipRect.Bottom = 32767
        End If

        If VarPtr(lpFrameInfo) <> 0 Then
            If lpFrameInfo.cb >= LenB(lpFrameInfo) Then
                lpFrameInfo.fMDIApp = False
                lpFrameInfo.hwndFrame = Me.InternalState.InternalContainerHWND
                lpFrameInfo.haccel = Me.InternalState.AcceleratorTable
                lpFrameInfo.cAccelEntries = Me.InternalState.AcceleratorTableCount
            End If
        End If

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_GetWindowContext... DONE")
        #End If

    End Sub
    
    Private Sub IOleInPlaceSite_OnInPlaceActivate() _
            Implements IOleInPlaceSiteWindowless.OnInPlaceActivate

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_OnInPlaceActivate")
        #End If
        ' should only be called once the first time control is inplace-activated

        If InternalState.InPlaceActive = True Then Exit Sub
        InternalState.InPlaceActive = True

        On Error Resume Next
            Dim runnableObject As Any = CType(Of IRunnableObject)(Me.InternalState.ClientObject_IOleObject)
            If runnableObject IsNot Nothing Then
                ' VB6 doesn't seem to do this?
                runnableObject.LockRunning(1, 0)
            End If
        On Error GoTo 0

        Set Me.InternalState.ClientObject_IOleInPlaceObject = CType(Of IOleInPlaceObject)(Me.InternalState.ClientObject_IOleObject)
        
        ' see atlhost.h...
		'm_bWindowless = False ;
    End Sub
    
    Private Sub IOleInPlaceSite_Scroll(ByVal scrollExtantX As Long, ByVal scrollExtantY As Long) _
            Implements IOleInPlaceSiteWindowless.Scroll

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_Scroll")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleInPlaceSite_OnInPlaceDeactivate() _
            Implements IOleInPlaceSiteWindowless.OnInPlaceDeactivate

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_OnInPlaceDeactivate")
        #End If
        InternalState.InPlaceActive = False
    End Sub
    
    Private Sub IOleInPlaceSite_OnUIActivate() _
            Implements IOleInPlaceSiteWindowless.OnUIActivate
        
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_OnUIActivate")
        #End If
        If InternalState.UIActive = True Then Exit Sub
        InternalState.UIActive = True
        
        If Me.InternalState.MiscStatus And OLEMISC_ACTSLIKEBUTTON Then
            If InternalState.DisplayAsDefault = False Then
                InternalState.DisplayAsDefault = True
                InternalAmbientPropertyChanged(DISPID_AMBIENT_DISPLAYASDEFAULT)
            End If
        End If
        
        RaiseEvent GotFocus()
    End Sub

    Private Sub IOleInPlaceSite_OnUIDeactivate(ByVal fUndoable As Long) _
           Implements IOleInPlaceSiteWindowless.OnUIDeactivate

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_OnUIDeactivate")
        #End If
        If InternalState.UIActive = False Then Exit Sub
        InternalState.UIActive = False
        
        RaiseEvent LostFocus()
    End Sub
    
    Private Sub IOleInPlaceSite_DiscardUndoState() _
            Implements IOleInPlaceSiteWindowless.DiscardUndoState

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_DiscardUndoState")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleInPlaceSite_DeactivateAndUndo() _
           Implements IOleInPlaceSiteWindowless.DeactivateAndUndo

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_DeactivateAndUndo")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub
    
    Private Sub IOleInPlaceSite_OnPosRectChange(ByRef lprcPosRect As WinNativeFormsBASE.RECT) _
            Implements IOleInPlaceSiteWindowless.OnPosRectChange

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_OnPosRectChange [Left: " & lprcPosRect.Left & ", Top: " & lprcPosRect.Top & ", Width: " & (lprcPosRect.Right - lprcPosRect.Left) & ", Height: " & (lprcPosRect.Bottom - lprcPosRect.Top))
        #End If
        
        On Error Resume Next
        Dim RootWindowElement As Any = Me.RootWindowElement
        Dim myRect As WinNativeFormsBASE.RECT
        myRect.Left = RootWindowElement.CurrentLeft
        myRect.Right = RootWindowElement.CurrentLeft + RootWindowElement.CurrentWidth
        myRect.Top = RootWindowElement.CurrentTop
        myRect.Bottom = RootWindowElement.CurrentTop + RootWindowElement.CurrentHeight
        Me.InternalState.ClientObject_IOleInPlaceObject.SetObjectRects(myRect, myRect)
    End Sub
    
    Private Sub IOleInPlaceSite_GetWindow(ByRef phwnd As LongPtr) _
            Implements IOleInPlaceSiteWindowless.GetWindow

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_GetWindow")
        #End If
        phwnd = Me.InternalState.InternalContainerHWND
        Debug.TracePrint "--> out HWND:" & phwnd
    End Sub
    
    Private Sub IOleInPlaceSite_ContextSensitiveHelp(ByVal fEnterMode As Long) _
            Implements IOleInPlaceSiteWindowless.ContextSensitiveHelp

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSite_ContextSensitiveHelp")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IOleInPlaceSiteEx_OnInPlaceActivateEx(ByVal pfNoRedraw As LongPtr, ByVal dwFlags As Long) _
    	    Implements IOleInPlaceSiteWindowless.OnInPlaceActivateEx

        InternalState.InPlaceActive = True

        ' On Error Resume Next
        '     Dim runnableObject As IRunnableObject = Me.ClientObject_IOleObject
        '     If runnableObject IsNot Nothing Then
        '         ' FIXME VB6 doesn't seem to do this (ACCESS does)
        '         runnableObject.LockRunning(1, 0)
        '     End If
        ' On Error GoTo 0

        Set Me.InternalState.ClientObject_IOleInPlaceObject = CType(Of IOleInPlaceObject)(Me.InternalState.ClientObject_IOleObject)

        If dwFlags And ACTIVATE_WINDOWLESS Then
            Me.UseIViewObjectSnapshots = True
            InternalState.DrawModeSnapshots = True        ' we paint manually, using IViewObject.Draw() rather than windowed with DoVerb()
            If Me.InternalState.UserMode = True Then  ' PrepareDesignTimeSnapshot handles the drawing if we're in design-mode
                Me.RootWindowElement.RequiresWindowlessPainting(False)
                Me.InternalState.IsWindowlessPainting = True
            End If
        End If

        If pfNoRedraw <> 0 Then
        	WriteMemLong(pfNoRedraw, 0)
        End If
        
        If dwFlags And ACTIVATE_WINDOWLESS Then
            If Me.InternalState.UserMode = False Then
                ' This is needed to prevent crashes with Xceed SmartUI ?  
                ' By doing this, the DoVerb(OLEIVERB_INPLACEACTIVATE) call will fail, and cause DrawModeSnapshots = True to be triggered
                ' If we allowed this to proceed, DrawModeSnapshots will be False, and then ultimately IoleObject.Close() causes later crashes on creating the next control (... weird)
                Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
            End If
        End If
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteEx_OnInPlaceActivateEx [dwFlags: ", dwFlags, "]")
        #End If
    End Sub

    Private Sub IOleInPlaceSiteEx_OnInPlaceDeactivateEx(ByVal fNoRedraw As Long) _
    	    Implements IOleInPlaceSiteWindowless.OnInPlaceDeactivateEx

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteEx_OnInPlaceDeactivateEx [fNoRedraw: ", fNoRedraw, "]")
        #End If
        
        IOleInPlaceSite_OnInPlaceDeactivate()
    End Sub

    Private Sub IOleInPlaceSiteEx_RequestUIActivate() _
    	   Implements IOleInPlaceSiteWindowless.RequestUIActivate

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteEx_RequestUIActivate")
        #End If
        ' FIXME what does VB6 do here?
    End Sub
    ' -------------------------------------------------------------------------------------------------------------
    
    Private Sub IOleInPlaceFrame_InsertMenus(ByVal hmenuShared As LongPtr, ByRef lpMenuWidths As OLEMENUGROUPWIDTHS) _
            Implements IOleInPlaceFrame.InsertMenus

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_InsertMenus")
        #End If
    End Sub
    
    Private Sub IOleInPlaceFrame_SetMenu(ByVal hmenuShared As LongPtr, ByVal holemenu As LongPtr, ByVal hwndActiveObject As LongPtr) _
            Implements IOleInPlaceFrame.SetMenu

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_SetMenu")
        #End If
    End Sub
    
    Private Sub IOleInPlaceFrame_RemoveMenus(ByVal hmenuShared As LongPtr) _
            Implements IOleInPlaceFrame.RemoveMenus

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_RemoveMenus")
        #End If
    End Sub
    
    Private Sub IOleInPlaceFrame_SetStatusText(ByVal pszStatusText As LongPtr) _
            Implements IOleInPlaceFrame.SetStatusText

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_SetStatusText")
        #End If
    End Sub
    
    Private Sub IOleInPlaceFrame_EnableModeless(ByVal fEnable As Long) _
            Implements IOleInPlaceFrame.EnableModeless

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_EnableModeless [fEnable: ", fEnable, "]")
        #End If

     	Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceFrame_TranslateAccelerator(ByRef lpmsg As MSG, ByVal wID As Integer) _
            Implements IOleInPlaceFrame.TranslateAccelerator

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_TranslateAccelerator")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE

    End Sub
    
    Private Sub IOleInPlaceFrame_GetBorder(ByRef lprectBorder As WinNativeFormsBASE.RECT) _
            Implements IOleInPlaceFrame.GetBorder

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_GetBorder")
        #End If
    End Sub
    
    Private Sub IOleInPlaceFrame_RequestBorderSpace(ByRef pborderwidths As WinNativeFormsBASE.RECT) _
            Implements IOleInPlaceFrame.RequestBorderSpace

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_RequestBorderSpace")
        #End If
        Err.ReturnHResult = INPLACE_E_NOTOOLSPACE
    End Sub
    
    Private Sub IOleInPlaceFrame_SetBorderSpace(ByRef pborderwidths As WinNativeFormsBASE.RECT) _
            Implements IOleInPlaceFrame.SetBorderSpace

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_SetBorderSpace")
        #End If
    End Sub
        
    Private Sub IOleInPlaceFrame_SetActiveObject(ByVal pActiveObject As IOleInPlaceActiveObject, ByVal pszObjName As LongPtr) _
            Implements IOleInPlaceFrame.SetActiveObject

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_SetActiveObject: " & Hex(ObjPtr(pActiveObject)))
        #End If
        Set Me.InternalState.ActiveObject = pActiveObject
        Me.InternalState.ActiveObjectSetCount += 1

         If pActiveObject IsNot Nothing Then
            'MsgBox Me.Name & " Capturing messages... ON"
             Me.RootWindowElement.CaptureMessages(True)   ' this will cause CapturedMessage events to fire at us
         Else
            'MsgBox Me.Name & " Capturing messages... OFF"
             Me.RootWindowElement.CaptureMessages(False)   ' CapturedMessage wont fire
             
             If Me.InternalState.MiscStatus And OLEMISC_ACTSLIKEBUTTON Then
                If InternalState.DisplayAsDefault = True Then
                    InternalState.DisplayAsDefault = False
                    InternalAmbientPropertyChanged(DISPID_AMBIENT_DISPLAYASDEFAULT)
                End If
             End If
         End If
    End Sub
    
    Private Sub IOleInPlaceFrame_GetWindow(ByRef phwnd As LongPtr) _
            Implements IOleInPlaceFrame.GetWindow

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_GetWindow")
        #End If
        phwnd = GetWindowHandleWithFallback()
    End Sub
    
    Private Sub IOleInPlaceFrame_ContextSensitiveHelp(ByVal fEnterMode As Long) _
            Implements IOleInPlaceFrame.ContextSensitiveHelp

        #If LOG_ACTIVEX Then
            Log("IOleInPlaceFrame_ContextSensitiveHelp")
        #End If
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IOleControlSite_OnControlInfoChanged() _
            Implements IOleControlSite.OnControlInfoChanged

        #If LOG_ACTIVEX Then
            Log("IOleControlSite_OnControlInfoChanged")
        #End If
        ' would need to refresh cached info here
    End Sub

    Private Sub IOleControlSite_LockInPlaceActive(ByVal fLock As Long) _
            Implements IOleControlSite.LockInPlaceActive

        #If LOG_ACTIVEX Then
            Log("IOleControlSite_LockInPlaceActive")
        #End If
        ' FIXME what does VB6 do here?
    End Sub

    Private Sub IOleControlSite_GetExtendedControl(ByRef ppDisp As Object) _
            Implements IOleControlSite.GetExtendedControl

        #If LOG_ACTIVEX Then
            Log("IOleControlSite_GetExtendedControl")
        #End If
        SetOutParamToNothing(VarPtr(ppDisp))
        Set ppDisp = Me.ExtenderTemplateObj 'Me
    End Sub

    Private Sub IOleControlSite_TransformCoords(ByRef pPtlHimetric As POINTL, ByRef pPtfContainer As POINTF, ByVal dwFlags As Long) _
            Implements IOleControlSite.TransformCoords

        #If LOG_ACTIVEX Then
            Log("IOleControlSite_TransformCoords")
        #End If

        Dim RootWindowElement As Any = Me.RootWindowElement
        Dim container As Object = RootWindowElement.Container
        
        If container Is Nothing Then
            ' FIXME once we keep all control objects alive in the IDE, we can change this to use real parent ScaleX/ScaleY

            ' FIXME the IDE currently renders controls as if they are in a container using vbPixels scale mode
            If dwFlags And XFORMCOORDS_HIMETRICTOCONTAINER Then
                pPtfContainer.x = CSng((pPtlHimetric.x * 96.0) / 2540.0)
                pPtfContainer.y = CSng((pPtlHimetric.y * 96.0) / 2540.0)
            ElseIf dwFlags And XFORMCOORDS_CONTAINERTOHIMETRIC Then
                pPtlHimetric.x = CLng(((pPtfContainer.x) / 96.0) * 2540.0)
                pPtlHimetric.y = CLng(((pPtfContainer.y) / 96.0) * 2540.0)
            Else
                Err.Raise 5, , "unexpected arguments"
            End If
            Exit Sub
        End If
        
        If TypeOf container Is Frame Then
            ' Frame container is always in TWIPS mode
            If dwFlags And XFORMCOORDS_HIMETRICTOCONTAINER Then
                pPtfContainer.x = CSng(RootWindowElement.ScaleX(pPtlHimetric.x, vbHimetric, vbTwips))
                pPtfContainer.y = CSng(RootWindowElement.ScaleY(pPtlHimetric.y, vbHimetric, vbTwips))
            ElseIf dwFlags And XFORMCOORDS_CONTAINERTOHIMETRIC Then
                pPtlHimetric.x = CLng(RootWindowElement.ScaleX(pPtfContainer.x, vbTwips, vbHimetric))
                pPtlHimetric.y = CLng(RootWindowElement.ScaleY(pPtfContainer.y, vbTwips, vbHimetric))
            Else
                Err.Raise 5, , "unexpected arguments"
            End If
        Else
            If dwFlags And XFORMCOORDS_HIMETRICTOCONTAINER Then
                pPtfContainer.x = CSng(container.ScaleX(pPtlHimetric.x, vbHimetric, container.ScaleMode))
                pPtfContainer.y = CSng(container.ScaleY(pPtlHimetric.y, vbHimetric, container.ScaleMode))
            ElseIf dwFlags And XFORMCOORDS_CONTAINERTOHIMETRIC Then
                pPtlHimetric.x = CLng(container.ScaleX(pPtfContainer.x, container.ScaleMode, vbHimetric))
                pPtlHimetric.y = CLng(container.ScaleY(pPtfContainer.y, container.ScaleMode, vbHimetric))
            Else
                Err.Raise 5, , "unexpected arguments"
            End If
        End If

    End Sub

    Private Sub IOleControlSite_TranslateAccelerator(ByRef pMsg As MSG, ByVal grfModifiers As Long) _
            Implements IOleControlSite.TranslateAccelerator
        #If LOG_ACTIVEX Then
            Log("IOleControlSite_TranslateAccelerator")
        #End If

        If (pMsg.message = WinNativeFormsBASE.WM_KEYDOWN) And (pMsg.wParam = vbKeyTab) Then
        	InternalSendMessage(Me.InternalState.InternalContainerHWND, pMsg.message, pMsg.wParam, pMsg.lParam)
            Exit Sub        ' S_OK means 'consumed'
        End If

        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub

    Private Sub IOleControlSite_OnFocus(ByVal fGotFocus As Long) _
            Implements IOleControlSite.OnFocus

        If Me.InternalState.AlreadyFocusing Then Exit Sub
        
        If (Me.InternalState.MiscStatus And OLEMISC_NOUIACTIVATE) = 0 Then    ' see https://github.com/twinbasic/twinbasic/issues/1321
            #If LOG_ACTIVEX Then
                Log("IOleControlSite_OnFocus")
            #End If
            InternalState.InternalHasFocus = If(fGotFocus, True, False)

            If InternalState.InternalHasFocus Then 'And InternalState.UIActive = False Then
                If Me.InternalState.ClientObject_IOleInPlaceObject IsNot Nothing Then
                     ' Needed for CODEJOCK controls?
                     Me.InternalState.ClientObject_IOleInPlaceObject.UIDeactivate         ' VB6 doesn't seem to do this
                End If

                If Me.InternalState.ClientObject_IOleObject IsNot Nothing Then
                    Me.InternalState.AlreadyFocusing = True
                    Me.InternalState.ClientObject_IOleObject.DoVerb(WinNativeFormsBASE.OLEIVERB_UIACTIVATE, 0, Me, -1, Me.InternalState.InternalContainerHWND, GetRECT())
                    Me.InternalState.AlreadyFocusing = False
                End If
            End If
            
            If fGotFocus Then
            	Me.RootWindowElement.Activate()
            Else
                Me.RootWindowElement.DeactivateStart()
                Me.RootWindowElement.DeactivateEnd()
            End If
        End If
    End Sub

    Private Sub IOleControlSite_ShowPropertyFrame() _
            Implements IOleControlSite.ShowPropertyFrame

        #If LOG_ACTIVEX Then
            Log("IOleControlSite_ShowPropertyFrame")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.E_NOTIMPL
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub PreMessageFilter(ByVal hwnd As LongPtr, ByVal msg As Long, ByVal wp As LongPtr, ByVal lp As LongPtr, ByRef plResult As LongPtr, ByRef pdwCookie As Long) _
    	    Implements ISimpleFrameSite.PreMessageFilter
        
        If msg = WinNativeFormsBASE.WM_PAINT Then
            'Stop
            If InternalState.IsInternalPainting = False Then
                ' Send WM_PAINT again, letting it be processed normally, and then render any of our 
                ' lightweight controls on top.  This seems to be how VBx does it.
                InternalState.IsInternalPainting = True
                InternalSendMessage(hwnd, msg, wp, lp)
                InternalState.IsInternalPainting = False
                Err.ReturnHResult = WinNativeFormsBASE.S_FALSE  ' this CONSUMES the message
            End If
        Else
            RootWindowElement.HandleAxContainerMsgPre(hwnd, msg, wp, lp, plResult)
        End If

        #If LOG_ACTIVEX Then
            Log("PreMessageFilter [", Hex(msg), "]")
        #End If
    End Sub

    Private Sub PostMessageFilter(ByVal hwnd As LongPtr, ByVal msg As Long, ByVal wp As LongPtr, ByVal lp As LongPtr, ByRef plResult As LongPtr, ByVal pdwCookie As Long) _
    	    Implements ISimpleFrameSite.PostMessageFilter
        
        If msg = WinNativeFormsBASE.WM_PAINT Then
            Dim hdc As LongPtr = InternalGetDC(hwnd)
            RootWindowElement.PaintContainedWindowlessElements(hdc)
        Else
            RootWindowElement.HandleAxContainerMsgPost(hwnd, msg, wp, lp, plResult)
        End If
        
        #If LOG_ACTIVEX Then
            Log("PostMessageFilter [", Hex(msg), "]")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub EnumControls(ByVal dwOleContF As Long, ByVal dwWhich As Long, ByRef ppenum As IEnumUnknown) _
    	        Implements IVBGetControl.EnumControls

        #If LOG_ACTIVEX Then
            Log("IVBGetControl.EnumControls [dwOleContF: ", Hex(dwOleContF), ", dwWhich: ", Hex(dwWhich), "]")
        #End If
        SetOutParamToNothing(VarPtr(ppenum))
        Set ppenum = CType(Of IEnumUnknown)(RootWindowElement.CreateControlsEnumerator(dwOleContF, dwWhich))
    End Sub

    ' -------------------------------------------------------------------------------------------------------------

    Private Sub OnChanged(ByVal dispID As Long) _
            Handles ClientObject_IPropertyNotifySink.OnChanged

        #If LOG_ACTIVEX Then
            Log("IPropertyNotifySink.OnChanged &H" & Hex(dispID))
        #End If
        
        If (dispID = 0) And Me.InternalState.HasExclusiveDefaultValue Then
            ' If the new value is TRUE, then the container must set all other exclusive siblings to FALSE
            ' (this is for radio buttons support)
            Dim newValue As Boolean = (ClientObject_IPropertyNotifySink)
            If newValue Then
                Me.RootWindowElement.ResetExclusiveValuesInContainer()
            End If
        End If
    End Sub

	Private Sub OnRequestEdit(ByVal dispID As Long) _
    	    Handles ClientObject_IPropertyNotifySink.OnRequestEdit
        
        #If LOG_ACTIVEX Then
            Log("IPropertyNotifySink.OnRequestEdit &H" & Hex(dispID))
        #End If
	End Sub
    ' -------------------------------------------------------------------------------------------------------------

    Private Sub IOleInPlaceSiteWindowless_CanWindowlessActivate() Implements IOleInPlaceSiteWindowless.CanWindowlessActivate
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_CanWindowlessActivate")
        #End If
        ' S_OK means 'yes'
        'If Me.InternalState.UserMode = False Then 
        'Err.ReturnHresult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_GetCapture() Implements IOleInPlaceSiteWindowless.GetCapture
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_GetCapture")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_SetCapture(ByVal fCapture As Long) Implements IOleInPlaceSiteWindowless.SetCapture
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_SetCapture")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_GetFocus() Implements IOleInPlaceSiteWindowless.GetFocus
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_GetFocus")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_SetFocus(ByVal fFocus As Long) Implements IOleInPlaceSiteWindowless.SetFocus
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_SetFocus")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_GetDC(pRect As WinNativeFormsBASE.RECT, ByVal grfFlags As Long, phDC As LongPtr) Implements IOleInPlaceSiteWindowless.GetDC
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_GetDC")
        #End If
        phDC = InternalGetDC(Me.InternalState.InternalContainerHWND)
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_ReleaseDC(ByVal hDC As LongPtr) Implements IOleInPlaceSiteWindowless.ReleaseDC
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_ReleaseDC")
        #End If
        InternalReleaseDC(Me.InternalState.InternalContainerHWND, hDC)
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_InvalidateRect(pRect As WinNativeFormsBASE.RECT, ByVal fErase As Long) Implements IOleInPlaceSiteWindowless.InvalidateRect
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_InvalidateRect")
        #End If
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_InvalidateRgn(ByVal hRGN As LongPtr, ByVal fErase As Long) Implements IOleInPlaceSiteWindowless.InvalidateRgn
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_InvalidateRgn")
        #End If
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_ScrollRect(ByVal dx As Long, ByVal dy As Long, pRectScroll As WinNativeFormsBASE.RECT, pRectClip As WinNativeFormsBASE.RECT) Implements IOleInPlaceSiteWindowless.ScrollRect
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_ScrollRect")
        #End If
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_AdjustRect(prc As WinNativeFormsBASE.RECT) Implements IOleInPlaceSiteWindowless.AdjustRect
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_AdjustRect")
        #End If
    End Sub
    
    Private Sub IOleInPlaceSiteWindowless_OnDefWindowMessage(ByVal msg As Long, ByVal wParam As LongPtr, ByVal lParam As LongPtr, plResult As LongPtr) Implements IOleInPlaceSiteWindowless.OnDefWindowMessage
        #If LOG_ACTIVEX Then
            Log("IOleInPlaceSiteWindowless_OnDefWindowMessage")
        #End If
        Err.ReturnHResult = WinNativeFormsBASE.S_FALSE
    End Sub
    
    Private Sub InternalAmbientPropertyChanged(ByVal dispID As Long) _
            Implements ActiveXControlExtenderBase.InternalAmbientPropertyChanged
        
        If InternalState.ClientObject_IOleControl IsNot Nothing Then
            InternalState.ClientObject_IOleControl.OnAmbientPropertyChange(dispID)
        End If
    End Sub
    
    Private Function GetForm() As stdole.IUnknown
        Return Me.ControlContext.GetForm
    End Function

    ' -------------------------------------------------------------------------------------------------------------

    [DispId(-701)]           ' DISPID_AMBIENT_BACKCOLOR
    [Serialize(False)]
    Private Property Get Ambient_BackColor() As OLE_COLOR
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_BackColor")
        #End If
        Dim formObject As Object = GetForm
        If formObject Is Nothing Then GoTo Error
        Return CLng(formObject.BackColor)
    Error:
        Return &H80000005
    End Property

    [DispId(-702)]           ' DISPID_AMBIENT_DISPLAYNAME
    [Serialize(False)]
    Private Property Get Ambient_DisplayName() As String
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_DisplayName")
        #End If
        Return Me.Name
    Error:
        Return "Unknown"
    End Property

    [DispId(-703)]           ' DISPID_AMBIENT_FONT
    [Serialize(False)]
    Private Property Get Ambient_Font() As stdole.Font
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_Font")
        #End If
        ' VBx returns a NEW StdFont each time this is accessed.  
        Dim propBag As New PropertyBag      ' We use a property bag to create an independent copy of the font
        Dim formObject As Object = GetForm
        If (formObject Is Nothing) OrElse (formObject.Font Is Nothing) Then GoTo Error
        If formObject.Font Is Nothing Then
        	formObject.SyncFont
        End If
        propBag.WriteProperty("Font", formObject.Font)
        Set Ambient_Font = CType(Of stdole.Font)(propBag.ReadProperty("Font"))

        Dim font As IFont = CType(Of IFont)(Ambient_Font)
        font.SetRatio(RootWindowElement.DPI, 2540)
        Exit Property
    Error:
        Return New StdFont
    End Property

    [DispId(-704)]           ' DISPID_AMBIENT_FORECOLOR
    [Serialize(False)]
    Private Property Get Ambient_ForeColor() As OLE_COLOR
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_ForeColor")
        #End If
        Dim formObject As Object = GetForm
        If formObject Is Nothing Then GoTo Error
        Return CLng(formObject.ForeColor)
    Error:
        Return &H80000008
    End Property

    [DispId(-705)]           ' DISPID_AMBIENT_LOCALEID
    [Serialize(False)]
    Private Property Get Ambient_LocaleID() As Long
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_LocaleID")
        #End If
        Return InternalGetUserDefaultLCID()         ' FIXME VB6 returns &H0409 (en-us) here despite system locale being &H0809 (en-gb)
    Error:
        Return 0
    End Property

    [DispId(-706)]           ' DISPID_AMBIENT_MESSAGEREFLECT
    [Serialize(False)]
    Private Property Get Ambient_MessageReflect() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_MessageReflect")
        #End If
        Return False                        ' FIXME VB6 does do message reflection
    End Property

    [DispId(-707)]           ' DISPID_AMBIENT_SCALEUNITS
    [Serialize(False)]
    Private Property Get Ambient_ScaleUnits() As String
        #If LOG_ACTIVEX Then
            Log("Ambient_ScaleUnits")
        #End If
        Dim scaleMode As Long = VBRUN.ScaleModeConstants.vbTwips
        On Error Resume Next
            scaleMode = CLng(Me.RootWindowElement.Container.ScaleMode)
        Select Case scaleMode
        	Case VBRUN.ScaleModeConstants.vbTwips: Return "Twip"
        	Case VBRUN.ScaleModeConstants.vbUser: Return "User"
        	Case VBRUN.ScaleModeConstants.vbPixels: Return "Pixel"
        	Case VBRUN.ScaleModeConstants.vbPoints: Return "Point"
        	Case VBRUN.ScaleModeConstants.vbCharacters: Return "Character"
        	Case VBRUN.ScaleModeConstants.vbInches: Return "Inch"
        	Case VBRUN.ScaleModeConstants.vbMillimeters: Return "Millimeter"
        	Case VBRUN.ScaleModeConstants.vbCentimeters: Return "Centimeter"
        	Case VBRUN.ScaleModeConstants.vbScaledPixels: Return "Pixel"
            Case Else
                Return "Twip"
        End Select
    End Property

    [DispId(-708)]           ' DISPID_AMBIENT_TEXTALIGN
    [Serialize(False)]
    Private Property Get Ambient_TextAlign() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_TextAlign")
        #End If
        Return 0    ' VBX always returns 0
    End Property

    [DispId(-709)]           ' DISPID_AMBIENT_USERMODE
    [Serialize(False)]
    Private Property Get Ambient_UserMode() As Boolean
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_UserMode: (result) " & Me.UserMode)
        #End If
        Return Me.InternalState.UserMode
    Error:
        Return True
    End Property

    [DispId(-710)]           ' DISPID_AMBIENT_UIDEAD
    [Serialize(False)]
    Private Property Get Ambient_UIDead() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_UIDead")
        #End If
        Return False            ' FIXME should set this to True when at a breakpoint
    End Property
    
    [DispId(-711)]           ' DISPID_AMBIENT_SHOWGRABHANDLES
    [Serialize(False)]
    Private Property Get Ambient_ShowGrabHandles() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_ShowGrabHandles")
        #End If
        Return False
    End Property

    [DispId(-712)]           ' DISPID_AMBIENT_SHOWHATCHING
    [Serialize(False)]
    Private Property Get Ambient_ShowHatching() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_ShowHatching")
        #End If
        Return False
    End Property

    [DispId(-713)]           ' DISPID_AMBIENT_DISPLAYASDEFAULT
    [Serialize(False)]
    Private Property Get Ambient_DisplayAsDefault() As Boolean
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_DisplayAsDefault")
        #End If
        Return InternalState.DisplayAsDefault
    Error:
        Return False
    End Property

    [DispId(-714)]           ' DISPID_AMBIENT_SUPPORTSMNEMONICS
    [Serialize(False)]
    Private Property Get Ambient_SupportsMnemonics() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_SupportsMnemonics")
        #End If
        Return True
    End Property

    [DispId(-715)]           ' DISPID_AMBIENT_AUTOCLIP
    [Serialize(False)]
    Private Property Get Ambient_AutoClip() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_AutoClip")
        #End If
        Return True
    End Property

    ' THIS IS NOT SUPPORTED ON THE VBX EXTENDER
    ' [ DispId (-716) ]           ' DISPID_AMBIENT_APPEARANCE
    ' [ Serialize (False) ]
    ' Private Property Get Ambient_Appearance() As Long
    '     #If LOG_ACTIVEX Then
    '                   Log("Ambient_Appearance")
    '     Return 0    ' 0 for flat, 1 for 3d
    ' End Property
    
    [DispId(-717)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown717() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown717")
        #End If
        Return True
    End Property
    
    [DispId(-718)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown718() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown718")
        #End If
        Return 1
    End Property
    
    [DispId(-721)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown721() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown721")
        #End If
        Return False
    End Property

    [DispId(-722)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown722() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown722")
        #End If
        Return True
    End Property
    
    [DispId(-723)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown723() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown723")
        #End If
        Return 212
    End Property

    [DispId(-724)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown724() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown724")
        #End If
        Return 212
    End Property

    ' THIS IS NOT SUPPORTED ON THE VBX EXTENDER
    ' [ DispId (-725) ]           ' DISPID_AMBIENT_CODEPAGE
    ' [ Serialize (False) ]
    ' Private Property Get Ambient_CodePage() As Long
    '     #If LOG_ACTIVEX Then
    '   Log("Ambient_CodePage")
    '     Return 0
    ' End Property

    [DispId(-726)]           ' DISPID_AMBIENT_PALETTE
    [Serialize(False)]
    Private Property Get Ambient_Palette() As LongPtr
        #If LOG_ACTIVEX Then
            Log("Ambient_Palette")
        #End If
        Return 0            ' VBX seems to always return 0, regardless of form Palette
    End Property

    ' THIS IS NOT SUPPORTED ON THE VBX EXTENDER
    '  [ DispId (-727) ]           ' DISPID_AMBIENT_CHARSET
    '  [ Serialize (False) ]
    '  Private Property Get Ambient_Charset() As Long
    '  #If LOG_ACTIVEX Then
    '   Log("Ambient_Charset")
    ' #End If
    '      Return 0
    '  End Property

    ' THIS IS NOT SUPPORTED ON THE VBX EXTENDER
    '  [ DispId (-728) ]           ' DISPID_AMBIENT_TRANSFERPRIORITY
    '  [ Serialize (False) ]
    '  Private Property Get Ambient_TransferPriority() As Long
    '      #If LOG_ACTIVEX Then
    '   Log("Ambient_TransferPriority")
    ' #End If
    '      Return 0
    '  End Property

    [DispId(-732)]           ' DISPID_AMBIENT_RIGHTTOLEFT
    [Serialize(False)]
    Private Property Get Ambient_RightToLeft() As Boolean
        On Error GoTo Error
        #If LOG_ACTIVEX Then
            Log("Ambient_RightToLeft")
        #End If
        Dim Container As Any = Me.RootWindowElement.Container
        If Container IsNot Nothing Then
            Return Container.RightToLeft
        End If
        Exit Property
    Error:
        Return False
    End Property

    ' THIS IS NOT SUPPORTED ON THE VBX EXTENDER
    '  [ DispId (-733) ]           ' DISPID_AMBIENT_TOPTOBOTTOM
    '  [ Serialize (False) ]
    '  Private Property Get Ambient_TopToBottom() As Boolean
    '  #If LOG_ACTIVEX Then
    '   Log("Ambient_TopToBottom")
    ' #End If
    '      Return False
    '  End Property

    [DispId(-740)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown740() As Variant
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown740")
        #End If
        Err.Raise 5                 ' VBX raises an error on this one
    End Property
    
    [DispId(-741)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown741() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown741")
        #End If
        Return 0
    End Property
    
    [DispId(-742)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown742() As Variant
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown742")
        #End If
        Err.Raise 5                 ' VBX raises an error on this one
    End Property
    
    [DispId(-743)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown743() As String
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown743")
        #End If
        Return ""       ' VBx returns CurDir path here?
    End Property
    
    [DispId(-744)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown744() As String
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown744")
        #End If
        Return ""       ' VBx returns CurDir path here?
    End Property
    
    [DispId(-745)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown745() As Variant
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown745")
        #End If
        Err.Raise 5                 ' VBX raises an error on this one
    End Property
    
    [DispId(-746)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown746() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown746")
        #End If
        Return 3
    End Property

    [DispId(-747)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown747() As Long
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown747")
        #End If
        Return 0            ' VBx returns a pointer/value of some sort
    End Property
    
    [DispId(-748)]           ' DISPID_AMBIENT_??             FIXME work out what this is
    [Serialize(False)]
    Private Property Get Ambient_Unknown748() As Boolean
        #If LOG_ACTIVEX Then
            Log("Ambient_Unknown748")
        #End If
        Return False
    End Property
    
    ' -------------------------------------------------------------------------------------------------------------
    
    [Serialize(False)]
    Public Property Get Parent() As Object ' As Form  FIXME, needs to work also for UCs
        Return ControlContext.GetForm
    End Property
    
    Public Sub SetFocus()
        InternalSetFocus(GetWindowHandleWithFallback())
    End Sub
    
    ' FIXME for UserControls, if this is not implemented, can cause recursive stack overflow (e.g. VBCCR.ProgressBar)
    [Unimplemented]
    Public Property Get Align() As Boolean
    End Property
    [Unimplemented]
    Public Property Let Align(ByVal Value As Boolean)
    End Property
    
    Private Sub OnPropertyChanged_Visible() _
            Handles Visible.OnPropertyLet

        Dim ourRect As WinNativeFormsBASE.RECT = GetRECT()
        Me.InternalState.ClientObject_IOleObject.DoVerb(If(Me.Visible = False, WinNativeFormsBASE.OLEIVERB_HIDE, WinNativeFormsBASE.OLEIVERB_SHOW), 0, Me, -1, Me.InternalState.InternalContainerHWND, ourRect)
        
        If InternalState.DrawModeSnapshots = True Then
            ' When drawn via IViewObject.Draw(), we have to repaint the container area
        	Me.ControlContext.WindowlessRefresh()
        End If
    End Sub
    
    Public Sub ZOrder([TypeHint(ZOrderConstants)] Optional ByVal Position As Variant)
        WinNativeFormsBASE.CommonZOrder(Position, GetWindowHandleWithFallback())
    End Sub
    
    Friend Sub SetCancelControl(ByVal Value As Boolean)
        RootWindowElement.SetCancelControl(Value)
    End Sub
    
    Friend Sub SetDefaultControl(ByVal Value As Boolean)
        RootWindowElement.SetDefaultControl(Value)
    End Sub
    
    Private Sub InitializeDefaultCancel()
        If ActsLikeButton = True Then
            If ExtenderTemplate.Default = True Then
                RootWindowElement.SetDefaultControl(ExtenderTemplate.Default)
                InternalState.DisplayAsDefault = True
                InternalAmbientPropertyChanged(DISPID_AMBIENT_DISPLAYASDEFAULT)
            End If
                
            If ExtenderTemplate.Cancel = True Then
                RootWindowElement.SetCancelControl(ExtenderTemplate.Cancel)
            End If
        End If
    End Sub
        
    Private Sub InvokeCancel() _
           Handles RootWindowElement.InvokeCancel

        If ActsLikeButton = True Then
            If InternalState.ClientObject_IOleControl IsNot Nothing Then
                Dim msg As MSG
                msg.hwnd = 0
                msg.message = WinNativeFormsBASE.WM_KEYDOWN
                msg.wParam = vbKeyEscape
                msg.lParam = 0
                ' This will pass the message on to UC.AccessKeyPress event
                InternalState.ClientObject_IOleControl.OnMnemonic(msg)
            End If
        End If
    End Sub
         
    Private Sub InvokeDefault() _
           Handles RootWindowElement.InvokeDefault

        If ActsLikeButton = True Then
            If InternalState.ClientObject_IOleControl IsNot Nothing Then
                Dim msg As MSG
                msg.hwnd = 0
                msg.message = WinNativeFormsBASE.WM_KEYDOWN
                msg.wParam = vbKeyReturn
                msg.lParam = 0
                ' This will pass the message on to UC.AccessKeyPress event
                InternalState.ClientObject_IOleControl.OnMnemonic(msg)
            End If
        End If
    End Sub
         
    Private Sub RootWindowElement_RevokeCancel()
        If ActsLikeButton = True Then
            ExtenderTemplate.Cancel = False
        End If
    End Sub
         
    Private Sub RootWindowElement_RevokeDefault()
        If ActsLikeButton = True Then
            ExtenderTemplate.Default = False
            'WinNativeFormsBASE.USER32_SetStyleFlag(RootWindowElement, BS_DEFPUSHBUTTON, False)
        End If
    End Sub
    
    Private Sub RootWindowElement_SyncDefaultState(ByVal value As Boolean)
        If ActsLikeButton = True Then
            InternalState.DisplayAsDefault = value
            InternalAmbientPropertyChanged(DISPID_AMBIENT_DISPLAYASDEFAULT)
        End If
    End Sub
    
End Class


[Description("ActiveX Control wrapper")]
[WindowsControl("/miscellaneous/ActiveXExtender.png")]
[ClassId("FFAF24A4-C5A5-4F1F-8914-D3A7BFEAD4B6")]
[InterfaceId("939AE90D-ED35-4C47-974C-E35EB2626157")]
[COMCreatable(False)]
[EventsUseDispInterface]
Class ActiveXControlExtender(Of T, ActsLikeButton)
     
    #Region "INHERITANCE"
    
        [WithDispatchForwarding] Implements Control
        Implements WithEvents T Via ClientObject
        Implements WithEvents ActiveXControlExtenderX Via ActiveXControlExtenderX
        Implements IActiveXControlExtender
        
    #End Region
    
    Event Something()
    
    Sub New()
        Set ActiveXControlExtenderX = New ActiveXControlExtenderX(Me, ActsLikeButton)
    End Sub
    
    Private tempClientObject As T
    
    Private Function IActiveXControlExtender_CreateNewInstance() As stdole.IUnknown
        Set ClientObject = New T
        Return ClientObject
    End Function
    
    Private Sub IActiveXControlExtender_UserModeHandsOffStart()
        Set tempClientObject = CType(Of T)(Me)
        Set ClientObject = Nothing
    End Sub
    
    Private Function IActiveXControlExtender_UserModeHandsOffEnd() As stdole.IUnknown
        Set IActiveXControlExtender_UserModeHandsOffEnd = tempClientObject
        Set ClientObject = tempClientObject
        Set tempClientObject = Nothing
    End Function
    
    [CompileIf(ActsLikeButton = True)]
    Private Property Get IActiveXControlExtender_Default() As Boolean
        Return Me.Default
    End Property
    
    [CompileIf(ActsLikeButton = True)]
    Private Property Let IActiveXControlExtender_Default(ByVal Value As Boolean)
        Me.Default = Value
    End Property
    
    [CompileIf(ActsLikeButton = True)]
    Private Property Get IActiveXControlExtender_Cancel() As Boolean
        Return Me.Cancel
    End Property
    
    [CompileIf(ActsLikeButton = True)]
    Private Property Let IActiveXControlExtender_Cancel(ByVal Value As Boolean)
        Me.Cancel = Value
    End Property
    
    [CompileIf(ActsLikeButton = False)]
    Private Property Get IActiveXControlExtender_Default() As Boolean
    End Property
    
    [CompileIf(ActsLikeButton = False)]
    Private Property Let IActiveXControlExtender_Default(ByVal Value As Boolean)
    End Property
    
    [CompileIf(ActsLikeButton = False)]
    Private Property Get IActiveXControlExtender_Cancel() As Boolean
    End Property
    
    [CompileIf(ActsLikeButton = False)]
    Private Property Let IActiveXControlExtender_Cancel(ByVal Value As Boolean)
    End Property
    
    [CompileIf(ActsLikeButton = True)]
    Public Cancel As Boolean
        
    [CompileIf(ActsLikeButton = True)]
    Public Default As Boolean
        
    [CompileIf(ActsLikeButton = True)]
    Private Sub CancelChanged() _
            Handles Cancel.OnPropertyLet
        ActiveXControlExtenderX.SetCancelControl(Cancel)
    End Sub
        
    [CompileIf(ActsLikeButton = True)]
    Private Sub DefaultChanged() _
                   Handles Default.OnPropertyLet
        ActiveXControlExtenderX.SetDefaultControl(Default)
    End Sub

End Class

[COMCreatable(False)]
Private Class EmptyOleContainer
	Implements IOleContainer
    
    Private Container As Object
    Private RootWindowElement As WindowElement
    Private UserMode As Boolean

    Sub New(Container As Object, RootWindowElement As WindowElement, UserMode As Boolean)
        Set Me.Container = Container
    	Set Me.RootWindowElement = RootWindowElement
        Me.UserMode = UserMode
    End Sub

    Private Sub IOleContainer_EnumObjects(ByVal grfFlags As Long, ppenum As IEnumUnknown) _
            Implements IOleContainer.EnumObjects

'        Debug.Print "IOleContainer_EnumObjects"
        SetOutParamToNothing(VarPtr(ppenum))

        Set ppenum = CType(Of IEnumUnknown)(Me.RootWindowElement.CreateControlsEnumerator(0, 0))        ' FIXME use VBx flags here
    End Sub
    
    Private Sub IOleContainer_LockContainer(ByVal fLock As Long) _
            Implements IOleContainer.LockContainer
        
'        Debug.Print "IOleContainer_LockContainer"
    End Sub
    
    Private Sub IOleContainer_ParseDisplayName(ByVal pbc As stdole.IUnknown, ByVal pszDisplayName As LongPtr, pchEaten As Long, ppmkOut As WinNativeFormsBASE.IMoniker) _
            Implements IOleContainer.ParseDisplayName
        
        SetOutParamToNothing(VarPtr(ppmkOut))

'        Debug.Print "IOleContainer_ParseDisplayName"
    End Sub

    ' This is accessed through UserControl.Parent.Controls on the VB6 side.  Seen in SSTabEx
    Public Function Controls() As Collection
        'Debug.Print "EmptyOleContainer.Controls"
    	Dim retVal As Collection = New Collection
        Dim Enum As Any = CType(Of IEnumUnknown)(Me.RootWindowElement.CreateControlsEnumerator(0, 0))
        Do
            Dim countOut As Long
            Dim control As stdole.IUnknown
            Enum.Next(1, control, countOut)
            If Err.LastHresult = WinNativeFormsBASE.S_FALSE Then Exit Do
            Dim controlDisp As Object = control
            retVal.Add controlDisp
        Loop
        Return retVal
    End Function

End Class

Private Module ActiveXControlExtenderHelper
	Public Function CreateBaseControlWindowless() As Object         ' FIXME This wrapper needed due to a compiler bug
        Return New WinNativeFormsBASE.BaseControlActiveXExtender(ControlTypeConstants.vbActiveXExtender)
    End Function
End Module

[InterfaceId("C9D71C42-2848-46BC-BE7B-DFDA7ACDC5B6")]
Interface ActiveXControlExtenderBase Extends stdole.IUnknown
    Sub InternalAmbientPropertyChanged(ByVal dispID As Long)
End Interface